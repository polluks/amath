.\" Copyright (c) 2014-2017 Carsten Sonne Larsen <cs@innolan.net>
.\" All rights reserved.
.\" 
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.TH "mathr.h" 3 "Version 1.8.3" "July 21 2017"
.SH NAME
mathr.h \- Real numbers math library 
.SH SYNOPSIS
.br
.PP
.SS "Macros"
.in +1c
.ti -1c
.RI "#define \fBPI\fP   3\&.1415926535897932384626433832795028841971693994"
.br
.ti -1c
.RI "#define \fBEULERS\fP   2\&.7182818284590452353602874713526624977572470937"
.br
.ti -1c
.RI "#define \fBINFP\fP   0x7FF0000000000000ull"
.br
.ti -1c
.RI "#define \fBINFN\fP   0xFFF0000000000000ull"
.br
.ti -1c
.RI "#define \fBNAN\fP   0x7FFFFFFFFFFFFFFFull"
.br
.ti -1c
.RI "#define \fBsgn\fP(x)   (x > 0 ? 1 : x < 0 ? \-1 : 0)"
.br
.ti -1c
.RI "#define \fBabs\fP(x)   (x > 0 ? x : \-x)"
.br
.in -1c
.SS "Functions"
.in +1c
.ti -1c
.RI "double \fBfabs\fP (double x)"
.br
.RI "\fIReturns the absolute value of x\&. \fP"
.ti -1c
.RI "double \fBceil\fP (double x)"
.br
.RI "\fICeiling function\&. \fP"
.ti -1c
.RI "double \fBfloor\fP (double x)"
.br
.RI "\fIFloor function\&. \fP"
.ti -1c
.RI "double \fBround\fP (double x)"
.br
.RI "\fIRound function\&. \fP"
.ti -1c
.RI "double \fBtrunc\fP (double x)"
.br
.RI "\fITruncate function\&. \fP"
.ti -1c
.RI "double \fBexp\fP (double x)"
.br
.RI "\fIReturns the exponential of x\&. \fP"
.ti -1c
.RI "double \fBsqrt\fP (double x)"
.br
.RI "\fISquare root function\&. \fP"
.ti -1c
.RI "double \fBcbrt\fP (double x)"
.br
.RI "\fICube root function\&. \fP"
.ti -1c
.RI "double \fBlog\fP (double x)"
.br
.RI "\fINatural logarithm function (base e) \fP"
.ti -1c
.RI "double \fBlog10\fP (double x)"
.br
.RI "\fIBase 10 logarithm function\&. \fP"
.ti -1c
.RI "double \fBcos\fP (double x)"
.br
.RI "\fICosine function\&. \fP"
.ti -1c
.RI "double \fBsin\fP (double x)"
.br
.RI "\fISine function\&. \fP"
.ti -1c
.RI "double \fBtan\fP (double x)"
.br
.RI "\fITangent function\&. \fP"
.ti -1c
.RI "double \fBsec\fP (double x)"
.br
.RI "\fISecant function\&. \fP"
.ti -1c
.RI "double \fBcsc\fP (double x)"
.br
.RI "\fICosecant function\&. \fP"
.ti -1c
.RI "double \fBcot\fP (double x)"
.br
.RI "\fICotangent function\&. \fP"
.ti -1c
.RI "double \fBexs\fP (double x)"
.br
.RI "\fIExsecant function\&. \fP"
.ti -1c
.RI "double \fBexc\fP (double x)"
.br
.RI "\fIExcosecant function\&. \fP"
.ti -1c
.RI "double \fBcrd\fP (double x)"
.br
.RI "\fIChord function\&. \fP"
.ti -1c
.RI "double \fBacos\fP (double x)"
.br
.RI "\fIInverse cosine function\&. \fP"
.ti -1c
.RI "double \fBasin\fP (double x)"
.br
.RI "\fIInverse sine function\&. \fP"
.ti -1c
.RI "double \fBatan\fP (double x)"
.br
.RI "\fIInverse tangent function\&. \fP"
.ti -1c
.RI "double \fBasec\fP (double x)"
.br
.RI "\fIInverse secant function\&. \fP"
.ti -1c
.RI "double \fBacsc\fP (double x)"
.br
.RI "\fIInverse cosecant function\&. \fP"
.ti -1c
.RI "double \fBacot\fP (double x)"
.br
.RI "\fIInverse cotangent function\&. \fP"
.ti -1c
.RI "double \fBaexs\fP (double x)"
.br
.RI "\fIInverse exsecant function\&. \fP"
.ti -1c
.RI "double \fBaexc\fP (double x)"
.br
.RI "\fIInverse excosecant function\&. \fP"
.ti -1c
.RI "double \fBacrd\fP (double x)"
.br
.RI "\fIInverse chord function\&. \fP"
.ti -1c
.RI "double \fBcosh\fP (double x)"
.br
.RI "\fIHyperbolic cosine function\&. \fP"
.ti -1c
.RI "double \fBsinh\fP (double x)"
.br
.RI "\fIHyperbolic sine function\&. \fP"
.ti -1c
.RI "double \fBtanh\fP (double x)"
.br
.RI "\fIHyperbolic tangent function\&. \fP"
.ti -1c
.RI "double \fBsech\fP (double x)"
.br
.RI "\fIHyperbolic secant function\&. \fP"
.ti -1c
.RI "double \fBcsch\fP (double x)"
.br
.RI "\fIHyperbolic cosecant function\&. \fP"
.ti -1c
.RI "double \fBcoth\fP (double x)"
.br
.RI "\fIHyperbolic cotangent function\&. \fP"
.ti -1c
.RI "double \fBacosh\fP (double x)"
.br
.RI "\fIInverse hyperbolic cosine function\&. \fP"
.ti -1c
.RI "double \fBasinh\fP (double x)"
.br
.RI "\fIInverse hyperbolic sine function\&. \fP"
.ti -1c
.RI "double \fBatanh\fP (double x)"
.br
.RI "\fIInverse hyperbolic tangent function\&. \fP"
.ti -1c
.RI "double \fBasech\fP (double x)"
.br
.RI "\fIInverse hyperbolic secant function\&. \fP"
.ti -1c
.RI "double \fBacsch\fP (double x)"
.br
.RI "\fIInverse hyperbolic cosecant function\&. \fP"
.ti -1c
.RI "double \fBacoth\fP (double x)"
.br
.RI "\fIInverse hyperbolic cotangent function\&. \fP"
.ti -1c
.RI "double \fBver\fP (double x)"
.br
.RI "\fIVersed sine function\&. \fP"
.ti -1c
.RI "double \fBvcs\fP (double x)"
.br
.RI "\fIVersed cosine function\&. \fP"
.ti -1c
.RI "double \fBcvs\fP (double x)"
.br
.RI "\fICoversed sine function\&. \fP"
.ti -1c
.RI "double \fBcvc\fP (double x)"
.br
.RI "\fICoversed cosine function\&. \fP"
.ti -1c
.RI "double \fBhv\fP (double x)"
.br
.RI "\fIHaversed sine function\&. \fP"
.ti -1c
.RI "double \fBhvc\fP (double x)"
.br
.RI "\fIHaversed cosine function\&. \fP"
.ti -1c
.RI "double \fBhcv\fP (double x)"
.br
.RI "\fIHacoversed sine function\&. \fP"
.ti -1c
.RI "double \fBhcc\fP (double x)"
.br
.RI "\fIHacoversed cosine function\&. \fP"
.ti -1c
.RI "double \fBaver\fP (double x)"
.br
.RI "\fIInverse versed sine function\&. \fP"
.ti -1c
.RI "double \fBavcs\fP (double x)"
.br
.RI "\fIInverse versed sine\&. \fP"
.ti -1c
.RI "double \fBacvs\fP (double x)"
.br
.RI "\fIInverse coversed sine function\&. \fP"
.ti -1c
.RI "double \fBacvc\fP (double x)"
.br
.RI "\fIInverse versed cosine\&. \fP"
.ti -1c
.RI "double \fBahv\fP (double x)"
.br
.RI "\fIInverse haversed sine\&. \fP"
.ti -1c
.RI "double \fBahvc\fP (double x)"
.br
.RI "\fIInverse haversed cosine\&. \fP"
.ti -1c
.RI "double \fBahcv\fP (double x)"
.br
.RI "\fIInverse hacoversed sine\&. \fP"
.ti -1c
.RI "double \fBahcc\fP (double x)"
.br
.RI "\fIInverse hacoversed cosine\&. \fP"
.ti -1c
.RI "double \fBpow\fP (double x, double y)"
.br
.RI "\fIExpontation function\&. \fP"
.ti -1c
.RI "double \fBfmod\fP (double x, double y)"
.br
.RI "\fIReturn x mod y in exact arithmetic\&. \fP"
.ti -1c
.RI "double \fBatan2\fP (double y, double x)"
.br
.RI "\fIInverse tangent function\&. \fP"
.ti -1c
.RI "double \fBhypot\fP (double x, double y)"
.br
.RI "\fIhypot \fP"
.ti -1c
.RI "double \fBlog2p\fP (double x, double y)"
.br
.ti -1c
.RI "double \fBlog1p\fP (double x)"
.br
.ti -1c
.RI "double \fBexpm1\fP (double x)"
.br
.ti -1c
.RI "double \fBscalbn\fP (double x, int n)"
.br
.ti -1c
.RI "double \fBcopysign\fP (double x, double y)"
.br
.RI "\fIReturns a value with the magnitude of x and with the sign bit of y\&. \fP"
.ti -1c
.RI "int \fBrempio2\fP (double x, double *y)"
.br
.ti -1c
.RI "unsigned int \fBlog2i\fP (unsigned int x)"
.br
.SH DESCRIPTION
.PP 
.SS "#define abs(x)   (x > 0 ? x : \-x)"
.PP
Definition at line 55 of file mathr\&.h\&.
.SS "#define EULERS   2\&.7182818284590452353602874713526624977572470937"
.PP
Definition at line 50 of file mathr\&.h\&.
.SS "#define INFN   0xFFF0000000000000ull"
.PP
Definition at line 52 of file mathr\&.h\&.
.SS "#define INFP   0x7FF0000000000000ull"
.PP
Definition at line 51 of file mathr\&.h\&.
.SS "#define NAN   0x7FFFFFFFFFFFFFFFull"
.PP
Definition at line 53 of file mathr\&.h\&.
.SS "#define PI   3\&.1415926535897932384626433832795028841971693994"
.PP
Definition at line 49 of file mathr\&.h\&.
.SS "#define sgn(x)   (x > 0 ? 1 : x < 0 ? \-1 : 0)"
.PP
Definition at line 54 of file mathr\&.h\&.
.PP 
.SS "double acos (double x)"
.PP
Inverse cosine function\&. 
.PP
.nf
Method
    acos(x)  = pi/2 - asin(x)
    acos(-x) = pi/2 + asin(x)
.fi
.PP
.PP
.PP
.nf
    For |x|<=0\&.5
    acos(x)  = pi/2 - (x + x*x^2*R(x^2))        (see \fBasin\&.c\fP)
.fi
.PP
.PP
.PP
.nf
    For x>0\&.5
    acos(x)  = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
             = 2asin(sqrt((1-x)/2))
             = 2s + 2s*z*R(z)   \&.\&.\&.z=(1-x)/2, s=sqrt(z)
             = 2f + (2c + 2s*z*R(z))
    where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
    for f so that f+c ~ sqrt(z)\&.
.fi
.PP
.PP
.PP
.nf
    For x<-0\&.5
    acos(x)  = pi - 2asin(sqrt((1-|x|)/2))
             = pi - 0\&.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)
.fi
.PP
.PP
.PP
.nf
Special cases
    if x is NaN, return NaN
    if |x|>1, return NaN
.fi
.PP
 
.PP
Definition at line 92 of file acos\&.c\&.
.SS "double acosh (double x)"

.PP
Inverse hyperbolic cosine function\&. 
.PP
.nf

Based on
    acosh(x) = log [ x + sqrt(x*x-1) ]
.fi
.PP
.PP
.PP
.nf
we have
    acosh(x) = log(x)+ln2, if x is large; else
    acosh(x) = log(2x-1/(sqrt(x*x-1)+x)) if x>2; else
    acosh(x) = log1p(t+sqrt(2\&.0*t+t*t)); where t=x-1
.fi
.PP
.PP
.PP
.nf
Special cases
    acosh(x) is NaN if x<1
    acosh(NaN) is NaN
.fi
.PP
 
.PP
Definition at line 69 of file acosh\&.c\&.
.SS "double acot (double x)"

.PP
Inverse cotangent function\&. 
.PP
.nf

Method
    arccot(x) = arctan(1/x)
.fi
.PP
 
.PP
Definition at line 45 of file acot\&.c\&.
.SS "double acoth (double x)"

.PP
Inverse hyperbolic cotangent function\&. 
.PP
.nf

Method
                          x + 1
    acoth(x) = 0\&.5 * ln( ------- )
                          x - 1
    when x in [-1, 1]
    acoth(x) = NaN
.fi
.PP
 
.PP
Definition at line 49 of file acoth\&.c\&.
.SS "double acrd (double x)"

.PP
Inverse chord function\&. 
.PP
.nf

Method
    arccrd(x) = 2*arcsin(x/2)
.fi
.PP
 
.PP
Definition at line 45 of file acrd\&.c\&.
.SS "double acsc (double x)"

.PP
Inverse cosecant function\&. 
.PP
.nf

Method
    arccsc(x) = arcsin(1/x)
.fi
.PP
 
.PP
Definition at line 45 of file acsc\&.c\&.
.SS "double acsch (double x)"

.PP
Inverse hyperbolic cosecant function\&. 
.PP
.nf

Method
                    1+sqrt(1+x*x)
    acsch(x) = ln( --------------- )
                          x
    when x is 0
    acsch(x) = NaN
.fi
.PP
 
.PP
Definition at line 49 of file acsch\&.c\&.
.SS "double acvc (double x)"

.PP
Inverse versed cosine\&. 
.PP
.nf

Method
    acvc(x) = asin(1+x)
.fi
.PP
 
.PP
Definition at line 45 of file acvc\&.c\&.
.SS "double acvs (double x)"

.PP
Inverse coversed sine function\&. 
.PP
Definition at line 40 of file acvs\&.c\&.
.SS "double aexc (double x)"

.PP
Inverse excosecant function\&. 
.PP
.nf

Method
    aexcsc(x) = arccsc(x+1)
              = arcsin(1/(x+1))
.fi
.PP
 
.PP
Definition at line 46 of file aexc\&.c\&.
.SS "double aexs (double x)"

.PP
Inverse exsecant function\&. 
.PP
.nf

Method
    aexsec(x) = arcsec(x+1)
              = arccos(1/(x+1))
              = arctan(sqrt(x^2+2*X))
.fi
.PP
 
.PP
Definition at line 47 of file aexs\&.c\&.
.SS "double ahcc (double x)"

.PP
Inverse hacoversed cosine\&. 
.PP
Definition at line 40 of file ahcc\&.c\&.
.SS "double ahcv (double x)"

.PP
Inverse hacoversed sine\&. 
.PP
Definition at line 40 of file ahcv\&.c\&.
.SS "double ahv (double x)"

.PP
Inverse haversed sine\&. 
.PP
Definition at line 40 of file ahv\&.c\&.
.SS "double ahvc (double x)"

.PP
Inverse haversed cosine\&. 
.PP
Definition at line 40 of file ahvc\&.c\&.
.SS "double asec (double x)"

.PP
Inverse secant function\&. 
.PP
.nf

Method
    arcsec(x) = arccos(1/x)
.fi
.PP
 
.PP
Definition at line 45 of file asec\&.c\&.
.SS "double asech (double x)"

.PP
Inverse hyperbolic secant function\&. 
.PP
.nf

Method
                    1+sqrt(1-x*x)
    asech(x) = ln( --------------- )
                          x
    when x <= 0
    asech(x) = NaN
.fi
.PP
.PP
.PP
.nf
    when x > 1
    asech(x) = NaN
.fi
.PP
 
.PP
Definition at line 52 of file asech\&.c\&.
.SS "double asin (double x)"

.PP
Inverse sine function\&. 
.PP
.nf

Method
.fi
.PP
.PP
.PP
.nf
Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + \&.\&.\&.
we approximate asin(x) on [0,0\&.5] by
     asin(x) = x + x*x^2*R(x^2)
where
     R(x^2) is a rational approximation of (asin(x)-x)/x^3
and its remez error is bounded by
     |(asin(x)-x)/x^3 - R(x^2)| < 2^(-58\&.75)
.fi
.PP
.PP
.PP
.nf
For x in [0\&.5,1]
     asin(x) = pi/2-2*asin(sqrt((1-x)/2))
Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
then for x>0\&.98
     asin(x) = pi/2 - 2*(s+s*z*R(z))
             = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
.fi
.PP
.PP
.PP
.nf
For x<=0\&.98, let pio4_hi = pio2_hi/2, then
     f = hi part of s;
     c = sqrt(z) - f = (z-f*f)/(s+f)     \&.\&.\&.f+c=sqrt(z)
and
     asin(x) = pi/2 - 2*(s+s*z*R(z))
             = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
             = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
.fi
.PP
.PP
.PP
.nf
Special cases
    if x is NaN, return NaN
    if |x|>1, return NaN
.fi
.PP
 
.PP
Definition at line 100 of file asin\&.c\&.
.SS "double asinh (double x)"

.PP
Inverse hyperbolic sine function\&. 
.PP
.nf

Method
    Based on
    asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
.fi
.PP
.PP
.PP
.nf
    we have
    asinh(x) = x  if  1+x*x=1,
             = sign(x)*(log(x)+ln2)) for large |x|, else
             = sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|>2, else
             = sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))
.fi
.PP
 
.PP
Definition at line 68 of file asinh\&.c\&.
.SS "double atan (double x)"

.PP
Inverse tangent function\&. 
.PP
.nf

Method
    1\&. Reduce x to positive by atan(x) = -atan(-x)\&.
    2\&. According to the integer k=4t+0\&.25 chopped, t=x, the argument
       is further reduced to one of the following intervals and the
       arctangent of t is evaluated by the corresponding formula:
.fi
.PP
.PP
.PP
.nf
    [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+\&.\&.\&.(a10+t^2*a11)\&.\&.\&.)
    [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0\&.5)/(1+t/2) )
    [11/16\&.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
    [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1\&.5)/(1+1\&.5t) )
    [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
.fi
.PP
.PP
.PP
.nf
Constants
    The hexadecimal values are the intended ones for the following
    constants\&. The decimal values may be used, provided that the
    compiler will convert from decimal to binary accurately enough
    to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
Definition at line 103 of file atan\&.c\&.
.SS "double atan2 (double y, double x)"

.PP
Inverse tangent function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy,x\fP 
.RE
.PP
.PP
.nf

Method
    1\&. Reduce y to positive by atan2(y,x)=-atan2(-y,x)\&.
    2\&. Reduce x to positive by (if x and y are unexceptional):
       ARG (x+iy) = arctan(y/x)           \&.\&.\&. if x > 0,
       ARG (x+iy) = pi - arctan[y/(-x)]   \&.\&.\&. if x < 0,
.fi
.PP
.PP
.PP
.nf
Special cases
    ATAN2((anything), NaN ) is NaN;
    ATAN2(NAN , (anything) ) is NaN;
    ATAN2(+-0, +(anything but NaN)) is +-0  ;
    ATAN2(+-0, -(anything but NaN)) is +-pi ;
    ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
    ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
    ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
    ATAN2(+-INF,+INF ) is +-pi/4 ;
    ATAN2(+-INF,-INF ) is +-3pi/4;
    ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
.fi
.PP
.PP
.PP
.nf
Constants
    The hexadecimal values are the intended ones for the following
    constants\&. The decimal values may be used, provided that the
    compiler will convert from decimal to binary accurately enough
    to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
Definition at line 87 of file atan2\&.c\&.
.SS "double atanh (double x)"

.PP
Inverse hyperbolic tangent function\&. 
.PP
.nf

Method
.PP
.nf
1.Reduced x to positive by atanh(-x) = -atanh(x)
2.For x>=0.5
              1               2x                         x
  atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
              2             1 - x                      1 - x

  For x<0.5
  atanh(x) = 0.5*log1p(2x+2x*x/(1-x))
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases
    atanh(x) is NaN if |x| > 1
    atanh(NaN) is that NaN
    atanh(+-1) is +-INF
.fi
.PP
 
.PP
Definition at line 72 of file atanh\&.c\&.
.SS "double avcs (double x)"

.PP
Inverse versed sine\&. 
.PP
.nf

avcs(x) = acos(1+x)
.fi
.PP
 
.PP
Definition at line 44 of file avcs\&.c\&.
.SS "double aver (double x)"

.PP
Inverse versed sine function\&. 
.PP
Definition at line 40 of file aver\&.c\&.
.SS "double cbrt (double x)"

.PP
Cube root function\&. 
.PP
Definition at line 62 of file cbrt\&.c\&.
.SS "double ceil (double x)"

.PP
Ceiling function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
x rounded toward -inf to integral value
.RE
.PP
.PP
.nf

Method
    Bit twiddling
.fi
.PP
.PP
.PP
.nf
Exception
    Inexact flag raised if x not equal to ceil(x)\&.
.fi
.PP
 
.PP
Definition at line 63 of file ceil\&.c\&.
.SS "double copysign (double x, double y)"

.PP
Returns a value with the magnitude of x and with the sign bit of y\&. 
.PP
Definition at line 47 of file csign\&.c\&.
.SS "double cos (double x)"

.PP
Cosine function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Cosine function of x
.RE
.PP
.PP
.nf

Kernel function:
.PP
.nf
__kernel_sin        ... sine function on [-pi/4,pi/4]
__kernel_cos        ... cose function on [-pi/4,pi/4]
__ieee754_rem_pio2  ... argument reduction routine
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Method:
.PP
.nf
Let S,C and T denote the sin, cos and tan respectively on
[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
in [-pi/4 , +pi/4], and let n = k mod 4.

We have

     n        sin(x)      cos(x)        tan(x)
----------------------------------------------------------
     0          S           C             T
     1          C          -S           -1/T
     2         -S          -C             T
     3         -C           S           -1/T
----------------------------------------------------------
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
Let trig be any of sin, cos, or tan.
trig(+-INF)  is NaN
trig(NaN)    is that NaN
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Accuracy:
.PP
.nf
TRIG(x) returns trig(x) nearly rounded
.fi
.PP

.fi
.PP
 
.PP
Definition at line 87 of file cos\&.c\&.
.SS "double cosh (double x)"

.PP
Hyperbolic cosine function\&. Mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2 
.PP
.nf

Method
.PP
.nf
1. Replace x by |x| (cosh(x) = cosh(-x))
2.
                                              [ exp(x) - 1 ]^2
   0        <= x <= ln2/2  :  cosh(x) := 1 + -------------------
                                                2*exp(x)

                                         exp(x) +  1/exp(x)
   ln2/2    <= x <= 22     :  cosh(x) := -------------------
                                                 2
   22       <= x <= lnovft :  cosh(x) := exp(x)/2
   lnovft   <= x <= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
   ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
cosh(x) is |x| if x is +INF, -INF, or NaN
only cosh(0)=1 is exact for finite x
.fi
.PP

.fi
.PP
 
.PP
Definition at line 83 of file cosh\&.c\&.
.SS "double cot (double x)"

.PP
Cotangent function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP 
.RE
.PP
.PP
.nf

cot(x) = 1/tan(x)
       = cos(x)/sin(x)
       = sin(2*x)/(cos(2*x)-1)
.fi
.PP
 
.PP
Definition at line 47 of file cot\&.c\&.
.SS "double coth (double x)"

.PP
Hyperbolic cotangent function\&. 
.PP
.nf

coth(x) = cosh(x)/sinh(x)
.fi
.PP
 
.PP
Definition at line 44 of file coth\&.c\&.
.SS "double crd (double x)"

.PP
Chord function\&. 
.PP
.nf

crd(x) = 2*sin(x/2)
.fi
.PP
 
.PP
Definition at line 44 of file crd\&.c\&.
.SS "double csc (double x)"

.PP
Cosecant function\&. 
.PP
.nf

csc = sin(1/x)
    = -2*sin(x)/(cos(2*x) - 1)
.fi
.PP
 
.PP
Definition at line 45 of file csc\&.c\&.
.SS "double csch (double x)"

.PP
Hyperbolic cosecant function\&. 
.PP
.nf

csch(x) = 1/sinh(x)
.fi
.PP
 
.PP
Definition at line 44 of file csch\&.c\&.
.SS "double cvc (double x)"

.PP
Coversed cosine function\&. 
.PP
.nf

cvc(x) = 1+sin(x)
.fi
.PP
 
.PP
Definition at line 44 of file cvc\&.c\&.
.SS "double cvs (double x)"

.PP
Coversed sine function\&. 
.PP
.nf

cvs(x) = 1-sin(x)
.fi
.PP
 
.PP
Definition at line 44 of file cvs\&.c\&.
.SS "double exc (double x)"

.PP
Excosecant function\&. 
.PP
.nf

excsc(x) = csc(x)-1
         = (1-sin(x))/sin(x)
         = cvs(x)/sin(x)
         = cvs(x)*csc(x)
.fi
.PP
 
.PP
Definition at line 47 of file exc\&.c\&.
.SS "double exp (double x)"

.PP
Returns the exponential of x\&. 
.PP
.nf

Method
.PP
.nf
1. Argument reduction:
   Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.
   Given x, find r and integer k such that

           x = k*ln2 + r,  |r| <= 0.5*ln2.

   Here r will be represented as r = hi-lo for better
   accuracy.

2. Approximation of exp(r) by a special rational function on
   the interval [0,0.34658]:

   Write
       R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
   We use a special Remes algorithm on [0,0.34658] to generate
   a polynomial of degree 5 to approximate R. The maximum error
   of this polynomial approximation is bounded by 2**-59. In
   other words,
       R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
       (where z=r*r, and the values of P1 to P5 are listed below)
   and

       |                  5          |     -59
       | 2.0+P1*z+...+P5*z   -  R(z) | <= 2
       |                             |

   The computation of exp(r) thus becomes
                      2*r
       exp(r) = 1 + -------
                     R - r
                          r*R1(r)
              = 1 + r + ----------- (for better accuracy)
                         2 - R1(r)
   where
                2       4                     10
       R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).

3. Scale back to obtain exp(x):
   From step 1, we have
   exp(x) = 2^k * exp(r)
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
exp(INF) is INF, exp(NaN) is NaN;
exp(-INF) is 0, and
for finite argument, only exp(0)=1 is exact.
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Accuracy:
.PP
.nf
according to an error analysis, the error is always less than
1 ulp (unit in the last place).
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Misc\&. info:
.PP
.nf
For IEEE double
    if x >  7.09782712893383973096e+02 then exp(x) overflow
    if x < -7.45133219101941108420e+02 then exp(x) underflow
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Constants:
.fi
.PP
.PP
.PP
.nf
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
Definition at line 138 of file exp\&.c\&.
.SS "double expm1 (double x)"

.PP
Definition at line 153 of file expm1\&.c\&.
.SS "double exs (double x)"

.PP
Exsecant function\&. 
.PP
.nf

exsec(x) = sec(x)-1
         = (1-cos(x))/cos(x)
         = ver(x)/cos(x)
         = ver(x)*sec(x)
         = 2*sin(x/2)*sin(x/2)*sec(x)
.fi
.PP
 
.PP
Definition at line 48 of file exs\&.c\&.
.SS "double fabs (double x)"

.PP
Returns the absolute value of x\&. 
.PP
Definition at line 51 of file fabs\&.c\&.
.SS "double floor (double x)"

.PP
Floor function\&. 
.PP
\fBReturns:\fP
.RS 4
x rounded toward -inf to integral value
.RE
.PP
.PP
.nf

Method:
    Bit twiddling
.fi
.PP
.PP
.PP
.nf
Exception:
    Inexact flag raised if x not equal to floor(x)
.fi
.PP
 
.PP
Definition at line 62 of file floor\&.c\&.
.SS "double fmod (double x, double y)"

.PP
Return x mod y in exact arithmetic\&. Method: Shift and subtract 
.PP
Definition at line 58 of file fmod\&.c\&.
.SS "double hcc (double x)"

.PP
Hacoversed cosine function\&. 
.PP
.nf

hcc(x) = (1+sin(x))/2
.fi
.PP
 
.PP
Definition at line 44 of file hcc\&.c\&.
.SS "double hcv (double x)"

.PP
Hacoversed sine function\&. 
.PP
.nf

hcv(x) = (1-sin(x))/2
.fi
.PP
 
.PP
Definition at line 44 of file hcv\&.c\&.
.SS "double hv (double x)"

.PP
Haversed sine function\&. 
.PP
.nf

hv(x) = (1-cos(x))/2
.fi
.PP
 
.PP
Definition at line 44 of file hv\&.c\&.
.SS "double hvc (double x)"

.PP
Haversed cosine function\&. 
.PP
.nf

hvc(x) = (1+cos(x))/2
.fi
.PP
 
.PP
Definition at line 44 of file hvc\&.c\&.
.SS "double hypot (double x, double y)"

.PP
hypot 
.PP
.nf

Method
 If (assume round-to-nearest) z=x*x+y*y
 has error less than sqrt(2)/2 ulp, than
 sqrt(z) has error less than 1 ulp (exercise)\&.
.fi
.PP
.PP
.PP
.nf
 So, compute sqrt(x*x+y*y) with some care as
 follows to get the error below 1 ulp:
.fi
.PP
.PP
.PP
.nf
 Assume x>y>0;
 (if possible, set rounding to round-to-nearest)
 1\&. if x > 2y  use
    x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
 where x1 = x with lower 32 bits cleared, x2 = x-x1; else
 2\&. if x <= 2y use
    t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
 where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1,
 y1= y with lower 32 bits chopped, y2 = y-y1\&.
.fi
.PP
.PP
.PP
.nf
 NOTE: scaling may be necessary if some argument is too
       large or too tiny
.fi
.PP
.PP
.PP
.nf
Special cases:
 hypot(x,y) is INF if x or y is +INF or -INF; else
 hypot(x,y) is NAN if x or y is NAN\&.
.fi
.PP
.PP
.PP
.nf
Accuracy:
    hypot(x,y) returns sqrt(x^2+y^2) with error less
    than 1 ulps (units in the last place)
.fi
.PP
 
.PP
Definition at line 81 of file hypot\&.c\&.
.SS "double log (double x)"

.PP
Natural logarithm function (base e) 
.PP
.nf

Method
  1\&. Argument Reduction: find k and f such that
        x = 2^k * (1+f),
    where  sqrt(2)/2 < 1+f < sqrt(2) \&.
.fi
.PP
.PP
.PP
.nf
  2\&. Approximation of log(1+f)\&.
 Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
     = 2s + 2/3 s**3 + 2/5 s**5 + \&.\&.\&.\&.\&.,
         = 2s + s*R
     We use a special Remes algorithm on [0,0\&.1716] to generate
    a polynomial of degree 14 to approximate R The maximum error
 of this polynomial approximation is bounded by 2**-58\&.45\&. In
 other words,
            2      4      6      8      10      12      14
     R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
    (the values of Lg1 to Lg7 are listed in the program)
 and
     |      2          14          |     -58\&.45
     | Lg1*s +\&.\&.\&.+Lg7*s    -  R(z) | <= 2
     |                             |
 Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2\&.
 In order to guarantee error in log below 1ulp, we compute log
 by
    log(1+f) = f - s*(f - R)    (if f is not too large)
    log(1+f) = f - (hfsq - s*(hfsq+R))\&. (better accuracy)
.fi
.PP
.PP
.PP
.nf
 3\&. Finally,  log(x) = k*ln2 + log(1+f)\&.
            = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
    Here ln2 is split into two floating point number:
        ln2_hi + ln2_lo,
    where n*ln2_hi is always exact for |n| < 2000\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 log(x) is NaN with signal if x < 0 (including -INF) ;
 log(+INF) is +INF; log(0) is -INF with signal;
 log(NaN) is that NaN with no signal\&.
.fi
.PP
.PP
.PP
.nf
Accuracy:
 according to an error analysis, the error is always less than
 1 ulp (unit in the last place)\&.
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
Definition at line 109 of file log\&.c\&.
.SS "double log10 (double x)"

.PP
Base 10 logarithm function\&. 
.PP
.nf

Method:
.PP
.nf
Let log10_2hi = leading 40 bits of log10(2) and
    log10_2lo = log10(2) - log10_2hi,
    ivln10    = 1/log(10) rounded.
Then
    n = ilogb(x),
    if(n<0)  n = n+1;
    x = scalbn(x,-n);
    log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))

Note 1:
To guarantee log10(10**n)=n, where 10**n is normal, the rounding
mode must set to Round-to-Nearest.

Note 2:
[1/log(10)] rounded to 53 bits has error .198 ulps;
log10 is monotonic at all binary break points.
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
log10(x) is NaN with signal if x < 0;
log10(+INF) is +INF with no signal; log10(0) is -INF with signal;
log10(NaN) is that NaN with no signal;
log10(10**N) = N  for N=0,1,...,22.
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following constants\&.
The decimal values may be used, provided that the compiler will convert
from decimal to binary accurately enough to produce the hexadecimal values
shown\&.
.fi
.PP
 
.PP
Definition at line 93 of file log10\&.c\&.
.SS "double log1p (double x)"

.PP
Definition at line 122 of file log1p\&.c\&.
.SS "unsigned int log2i (unsigned int x)"

.SS "double log2p (double x, double y)"

.PP
Definition at line 32 of file log2p\&.c\&.
.SS "double pow (double x, double y)"

.PP
Expontation function\&. 
.PP
.nf

Method:  Let x =  2   * (1+f)
 1\&. Compute and return log2(x) in two pieces:
    log2(x) = w1 + w2,
    where w1 has 53-24 = 29 bit trailing zeros\&.
 2\&. Perform y*log2(x) = n+y' by simulating muti-precision
    arithmetic, where |y'|<=0\&.5\&.
 3\&. Return x**y = 2**n*exp(y'*log2)
.fi
.PP
.PP
.PP
.nf
Special cases:
 1\&.  (anything) ** 0  is 1
 2\&.  (anything) ** 1  is itself
 3\&.  (anything) ** NAN is NAN
 4\&.  NAN ** (anything except 0) is NAN
 5\&.  +-(|x| > 1) **  +INF is +INF
 6\&.  +-(|x| > 1) **  -INF is +0
 7\&.  +-(|x| < 1) **  +INF is +0
 8\&.  +-(|x| < 1) **  -INF is +INF
 9\&.  +-1         ** +-INF is NAN
 10\&. +0 ** (+anything except 0, NAN)               is +0
 11\&. -0 ** (+anything except 0, NAN, odd integer)  is +0
 12\&. +0 ** (-anything except 0, NAN)               is +INF
 13\&. -0 ** (-anything except 0, NAN, odd integer)  is +INF
 14\&. -0 ** (odd integer) = -( +0 ** (odd integer) )
 15\&. +INF ** (+anything except 0,NAN) is +INF
 16\&. +INF ** (-anything except 0,NAN) is +0
 17\&. -INF ** (anything)  = -0 ** (-anything)
 18\&. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
 19\&. (-anything except 0 and inf) ** (non-integer) is NAN
.fi
.PP
.PP
.PP
.nf
Accuracy:
 pow(x,y) returns x**y nearly rounded\&. In particular
        pow(integer,integer)
 always returns the correct integer provided it is
 representable\&.
.fi
.PP
.PP
.PP
.nf
Constants :
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
Definition at line 138 of file pow\&.c\&.
.SS "int rempio2 (double x, double * y)"

.PP
Definition at line 104 of file remp2\&.c\&.
.SS "double round (double x)"

.PP
Round function\&. 
.PP
Definition at line 40 of file round\&.c\&.
.SS "double scalbn (double x, int n)"

.SS "double sec (double x)"

.PP
Secant function\&. 
.PP
.nf

sec(x) = 1/cos(x)
       = 1/sqrt(cos(x)*cos(x))
.fi
.PP
 
.PP
Definition at line 45 of file sec\&.c\&.
.SS "double sech (double x)"

.PP
Hyperbolic secant function\&. 
.PP
.nf

sech(x) = 1/cosh(x)
.fi
.PP
 
.PP
Definition at line 44 of file sech\&.c\&.
.SS "double sin (double x)"

.PP
Sine function\&. 
.PP
\fBReturns:\fP
.RS 4
Sine function of x
.RE
.PP
.PP
.nf

Kernel function:
.PP
.nf
__kernel_sin        ... sine function on [-pi/4,pi/4]
__kernel_cos        ... cose function on [-pi/4,pi/4]
__ieee754_rem_pio2  ... argument reduction routine
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Method:
.PP
.nf
Let S,C and T denote the sin, cos and tan respectively on
[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
in [-pi/4 , +pi/4], and let n = k mod 4.

We have

     n        sin(x)      cos(x)        tan(x)
----------------------------------------------------------
     0          S           C             T
     1          C          -S           -1/T
     2         -S          -C             T
     3         -C           S           -1/T
----------------------------------------------------------
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
Let trig be any of sin, cos, or tan.
trig(+-INF)  is NaN
trig(NaN)    is that NaN
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Accuracy:
.PP
.nf
TRIG(x) returns trig(x) nearly rounded
.fi
.PP

.fi
.PP
 
.PP
Definition at line 86 of file sin\&.c\&.
.SS "double sinh (double x)"

.PP
Hyperbolic sine function\&. 
.PP
.nf

Method
mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
 1\&. Replace x by |x| (sinh(-x) = -sinh(x))\&.
 2\&.
                                        E + E/(E+1)
     0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)
                                2
.fi
.PP
.PP
.PP
.nf
     22       <= x <= lnovft :  sinh(x) := exp(x)/2
     lnovft   <= x <= ln2ovft:  sinh(x) := exp(x/2)/2 * exp(x/2)
     ln2ovft  <  x      :  sinh(x) := x*shuge (overflow)
.fi
.PP
.PP
.PP
.nf
Special cases
    sinh(x) is |x| if x is +INF, -INF, or NaN\&.
    only sinh(0)=0 is exact for finite x\&.
.fi
.PP
 
.PP
Definition at line 77 of file sinh\&.c\&.
.SS "double sqrt (double x)"

.PP
Square root function\&. 
.PP
\fBReturns:\fP
.RS 4
Correctly rounded sqrt
.RE
.PP
.PP
.nf

Method:
  Bit by bit method using integer arithmetic\&. (Slow, but portable)
  1\&. Normalization
     Scale x to y in [1,4) with even powers of 2:
     find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
     sqrt(x) = 2^k * sqrt(y)
  2\&. Bit by bit computation
     Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
          i                          0
                                    i+1         2
         s  = 2*q , and y  =  2   * ( y - q  )\&.     (1)
          i      i            i                 i
.fi
.PP
.PP
.PP
.nf
     To compute q    from q , one checks whether
        i+1       i
.PP
.nf
  -(i+1) 2
.fi
.PP

        (q + 2      ) <= y\&.         (2)
                  i
                              -(i+1)
 If (2) is false, then q   = q ; otherwise q   = q  + 2      \&.
               i+1   i             i+1   i
.fi
.PP
.PP
.PP
.nf
     With some algebric manipulation, it is not difficult to see
     that (2) is equivalent to
                            -(i+1)
        s  +  2       <= y          (3)
         i                i
.fi
.PP
.PP
.PP
.nf
     The advantage of (3) is that s  and y  can be computed by
                  i      i
     the following recurrence formula:
         if (3) is false
.fi
.PP
.PP
.PP
.nf
         s     =  s  ,  y    = y   ;            (4)
          i+1      i         i+1    i
.fi
.PP
.PP
.PP
.nf
         otherwise,
                        -i                     -(i+1)
         s    =  s  + 2  ,  y    = y  -  s  - 2         (5)
          i+1      i          i+1    i     i
.fi
.PP
.PP
.PP
.nf
     One may easily use induction to prove (4) and (5)\&.
     Note\&. Since the left hand side of (3) contain only i+2 bits,
         it does not necessary to do a full (53-bit) comparison
         in (3)\&.
  3\&. Final rounding
     After generating the 53 bits result, we compute one more bit\&.
     Together with the remainder, we can decide whether the
     result is exact, bigger than 1/2ulp, or less than 1/2ulp
     (it will never equal to 1/2ulp)\&.
     The rounding mode can be detected by checking whether
     huge + tiny is equal to huge, and whether huge - tiny is
     equal to huge for some floating point number 'huge' and 'tiny'\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
  sqrt(+-0) = +-0    \&.\&.\&. exact
  sqrt(inf) = inf
  sqrt(-ve) = NaN    \&.\&.\&. with invalid signal
  sqrt(NaN) = NaN    \&.\&.\&. with invalid signal for signaling NaN
.fi
.PP
 
.PP
Definition at line 119 of file sqrt\&.c\&.
.SS "double tan (double x)"

.PP
Tangent function\&. 
.PP
\fBReturns:\fP
.RS 4
Tangent function of x
.RE
.PP
.PP
.nf

Kernel function:
.PP
.nf
__kernel_sin        ... sine function on [-pi/4,pi/4]
__kernel_cos        ... cose function on [-pi/4,pi/4]
__ieee754_rem_pio2  ... argument reduction routine
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Method:
.PP
.nf
Let S,C and T denote the sin, cos and tan respectively on
[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
in [-pi/4 , +pi/4], and let n = k mod 4.

We have

     n        sin(x)      cos(x)        tan(x)
----------------------------------------------------------
     0          S           C             T
     1          C          -S           -1/T
     2         -S          -C             T
     3         -C           S           -1/T
----------------------------------------------------------
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Special cases:
.PP
.nf
Let trig be any of sin, cos, or tan.
trig(+-INF)  is NaN
trig(NaN)    is that NaN
.fi
.PP
.fi
.PP
.PP
.PP
.nf
Accuracy:
.PP
.nf
TRIG(x) returns trig(x) nearly rounded
.fi
.PP

.fi
.PP
 
.PP
Definition at line 87 of file tan\&.c\&.
.SS "double tanh (double x)"

.PP
Hyperbolic tangent function\&. 
.PP
\fBReturns:\fP
.RS 4
The Hyperbolic Tangent of x
.RE
.PP
.PP
.nf

Method
                                   x    -x
                                  e  - e
    0\&. tanh(x) is defined to be -----------
                                   x    -x
                                  e  + e
.fi
.PP
.PP
.PP
.nf
    1\&. reduce x to non-negative by tanh(-x) = -tanh(x)
.fi
.PP
.PP
.PP
.nf
    2\&.  0      <= x <= 2**-55 : tanh(x) = x*(one+x)
                                           -t
        2**-55 <  x <=  1     : tanh(x) = -----; t = expm1(-2x)
                                          t + 2
                                                  2
        1      <= x <=  22\&.0  : tanh(x) = 1-  ----- ; t=expm1(2x)
                                                t + 2
        22\&.0   <  x <= INF    : tanh(x) = 1
.fi
.PP
.PP
.PP
.nf
Special cases
    tanh(NaN) is NaN
    only tanh(0)=0 is exact for finite argument\&.
.fi
.PP
 
.PP
Definition at line 81 of file tanh\&.c\&.
.SS "double trunc (double x)"

.PP
Truncate function\&. 
.PP
.nf

when x > 0
trunc(0)   = floor(x)
.fi
.PP
.PP
.PP
.nf
when x < 0
trunc(x)   = ceil(x)
.fi
.PP
.PP
.PP
.nf
Special case
trunc(0)   = 0
trunc(NaN) = NaN
.fi
.PP
 
.PP
Definition at line 52 of file trunc\&.c\&.
.SS "double vcs (double x)"

.PP
Versed cosine function\&. 
.PP
.nf

vercos = 1+cos(x)
       = 2*cos(x/2)*cos(x/2)
.fi
.PP
 
.PP
Definition at line 45 of file vcs\&.c\&.
.SS "double ver (double x)"

.PP
Versed sine function\&. 
.PP
.nf

versin = 1-cos(x)
       = 2*sin(x/2)*sin(x/2)
.fi
.PP
 
.PP
Definition at line 45 of file ver\&.c\&.
.SH HOMEPAGE
https://amath.innolan.net/
.SH AUTHORS
.PP
The library is based on fdlib by Sun Microsystems\&. The original library can be downloaded at netlib\&.org:
.br
http://www.netlib.org/fdlibm/
.PP
or from mirror site hensa\&.ac\&.uk:
.br
http://www.hensa.ac.uk/
.SH COPYRIGHT
Copyright (C) 2014-2017 Carsten Sonne Larsen <cs@innolan.net>
.br
Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
.SH SEE ALSO
amath(1), amathc(3), amathi(3)