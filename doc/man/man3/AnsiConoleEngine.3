.TH "AnsiConoleEngine" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AnsiConoleEngine \- ANSI console controller\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <aengine\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAnsiConoleEngine\fP (const char *\fBprompt\fP, \fBCharValidator\fP *\fBvalidator\fP)"
.br
.ti -1c
.RI "\fB~AnsiConoleEngine\fP ()"
.br
.ti -1c
.RI "void \fBStartInput\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBInputDone\fP ()"
.br
.ti -1c
.RI "const char * \fBGetLine\fP ()"
.br
.ti -1c
.RI "void \fBSetPrompt\fP (const char *string)"
.br
.ti -1c
.RI "const char * \fBProcessChar\fP (const unsigned char character)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBCopyLine\fP ()"
.br
.ti -1c
.RI "void \fBShowLast\fP ()"
.br
.ti -1c
.RI "void \fBShowNext\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char * \fBprompt\fP"
.br
.ti -1c
.RI "char ** \fBlines\fP"
.br
.ti -1c
.RI "\fBCharBuffer\fP * \fBlinebuf\fP"
.br
.ti -1c
.RI "\fBCharValidator\fP * \fBvalidator\fP"
.br
.ti -1c
.RI "unsigned int \fBlen\fP"
.br
.ti -1c
.RI "char * \fBcursor\fP"
.br
.ti -1c
.RI "char * \fBendpos\fP"
.br
.ti -1c
.RI "int \fBcurline\fP"
.br
.ti -1c
.RI "int \fBshowline\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBlineswap\fP"
.br
.ti -1c
.RI "char * \fBeditline\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBescmode\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBcsimode\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBdelmode\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBlinedone\fP"
.br
.ti -1c
.RI "\fBCharBuffer\fP * \fBout\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const int \fBmaxLines\fP = 20"
.br
.ti -1c
.RI "static const int \fBlineSize\fP = 1024"
.br
.in -1c
.SH "Detailed Description"
.PP 
ANSI console controller\&. 

More info on the ANSI console is available at Wikipedia: http://en.wikipedia.org/wiki/ANSI_escape_code 
.PP
Definition at line 45 of file aengine\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AnsiConoleEngine::AnsiConoleEngine (const char * prompt, \fBCharValidator\fP * validator)"

.PP
Definition at line 32 of file aengine\&.cpp\&.
.PP
References AllocAndCopy(), CharBuffer::CharBuffer(), curline, editline, linebuf, lines, maxLines, out, prompt, and validator\&.
.PP
Referenced by StandardConsole::StandardConsole()\&.
.PP
.nf
33 {
34     this->validator = validator;
35     AllocAndCopy(&this->prompt, prompt);
36     linebuf = new CharBuffer();
37     out = new CharBuffer();
38 
39     lines = new char*[maxLines];
40 
41     for (int i = 0; i < maxLines; i++) {
42         lines[i] = NOMEM;
43     }
44 
45     editline = NOMEM;
46     curline = -1;
47 }
.fi
.SS "AnsiConoleEngine::~AnsiConoleEngine ()"

.PP
Definition at line 49 of file aengine\&.cpp\&.
.PP
References linebuf, lines, maxLines, out, and prompt\&.
.PP
.nf
50 {
51     for (int i = 0; i < maxLines; i++) {
52         if (lines[i] != NOMEM) {
53             delete [] lines[i];
54         }
55     }
56 
57     delete [] lines;
58     delete linebuf;
59     delete out;
60     delete prompt;
61 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void AnsiConoleEngine::CopyLine ()\fC [private]\fP"

.PP
Definition at line 216 of file aengine\&.cpp\&.
.PP
References AllocAndCopy(), curline, editline, CharBuffer::GetString(), linebuf, lines, and maxLines\&.
.PP
Referenced by ProcessChar()\&.
.PP
.nf
217 {
218     curline++;
219 
220     if (curline == maxLines) {
221         curline--;
222 
223         delete [] lines[0];
224         for (int i = 0; i < maxLines - 1; i++) {
225             lines[i] = lines[i + 1];
226         }
227     }
228 
229     AllocAndCopy(&(lines[curline]), linebuf->GetString());
230 
231     if (editline != NOMEM) {
232         delete [] editline;
233         editline = NOMEM;
234     }
235 }
.fi
.SS "const char * AnsiConoleEngine::GetLine ()"

.PP
Definition at line 320 of file aengine\&.cpp\&.
.PP
References CharBuffer::GetString(), and linebuf\&.
.PP
Referenced by StandardConsole::ReadLine()\&.
.PP
.nf
321 {
322     return linebuf->GetString();
323 }
.fi
.SS "\fBbool\fP AnsiConoleEngine::InputDone ()"

.PP
Definition at line 315 of file aengine\&.cpp\&.
.PP
References linedone\&.
.PP
Referenced by StandardConsole::ReadLine()\&.
.PP
.nf
316 {
317     return linedone;
318 }
.fi
.SS "const char * AnsiConoleEngine::ProcessChar (const unsigned char character)"

.PP
Definition at line 82 of file aengine\&.cpp\&.
.PP
References CharBuffer::Append(), CharBuffer::buf, CopyLine(), csimode, cursor, delmode, CharBuffer::Empty(), endpos, escmode, CharBuffer::GetString(), len, linebuf, linedone, out, CharBuffer::ptr, ShowLast(), ShowNext(), CharValidator::Validate(), and validator\&.
.PP
Referenced by StandardConsole::ReadLine()\&.
.PP
.nf
83 {
84     unsigned char ch = character;
85     out->Empty();
86 
87     /*
88     // -------------- DEUG ------------------
89     Number *d = new RealNumber((int)ch);
90     NumeralSystem *ns = new DecimalSystem(0);
91     const char *dtext = ns->GetText(d);
92     StrCopy(out->buf, dtext);
93     StrConcat(out->buf, SPACE);
94     delete ns;
95     delete d;
96     return out->buf;
97     // -------------- DEUG ------------------
98     */
99 
100     if (len == 0) {
101         // TODO: double buffer
102     }
103 
104     bool processed = false;
105 
106     if (ch == 0) {
107         processed = true;
108     } else if (ch == 27) {
109         escmode = true;
110         processed = true;
111     } else if (ch == 155 || (escmode && ch == 91)) {
112         csimode = true;
113         processed = true;
114     } else if (csimode) {
115         switch (ch) {
116         case 65: // Arrow up (27 91 65)
117             ShowLast();
118             break;
119         case 66: // Arrow down (27 91 66)
120             ShowNext();
121             break;
122         case 67: // Arrow right (27 91 67)
123             if (cursor != endpos) {
124                 cursor++;
125                 out->Append(CURSORFORWARD);
126             }
127             break;
128         case 68: // Arrow left (27 91 68)
129             if (cursor != linebuf->buf) {
130                 cursor--;
131                 out->Append(CURSORBACKWARD);
132             }
133             break;
134         case 51: // DEL         27 91 51 126
135             delmode = true;
136         default:
137             // F1          27 79 80
138             // F2          27 79 81
139             break;
140         }
141 
142         escmode = false;
143         csimode = false;
144         processed = true;
145     } else {
146         escmode = false;
147         csimode = false;
148     }
149 
150     // Delete one character to the right
151     if (delmode && ch == 126) {
152         if (cursor != endpos) {
153             char *i = cursor;
154             do {
155                 *i = *(i + 1);
156                 i++;
157             } while (i != endpos);
158 
159             len++;
160             out->Append(DELETE1CHAR);
161             endpos--;
162             linebuf->ptr = endpos;
163         }
164 
165         processed = true;
166         delmode = false;
167     }
168 
169     if (processed) {
170         return out->GetString();
171     }
172 
173     if (ch == 13 || ch == 10) {
174         out->Append(NEWLINE);
175         linebuf->ptr = endpos;
176         CopyLine();
177         linedone = true;
178     } else if (cursor != linebuf->buf && (ch == 8 || ch == 127)) {
179         // Deleting in middle of line
180         if (cursor != endpos) {
181             char *i = cursor - 1;
182             do {
183                 *i = *(i + 1);
184                 i++;
185             } while (i != endpos);
186 
187         }
188 
189         len++;
190         out->Append(CURSORBACKWARD);
191         out->Append(DELETE1CHAR);
192         cursor--;
193         endpos--;
194         linebuf->ptr = endpos;
195     } else if (validator->Validate(ch)) {
196         // Insert in middle of line
197         if (cursor != endpos) {
198             char *i = endpos;
199             do {
200                 *i = *(i - 1);
201                 i--;
202             } while (i != cursor);
203             out->Append(INSERT1CHAR);
204         }
205 
206         len--;
207         out->Append(ch);
208         *cursor++ = ch;
209         endpos++;
210         linebuf->ptr = endpos;
211     }
212 
213     return out->GetString();
214 }
.fi
.SS "void AnsiConoleEngine::SetPrompt (const char * string)"

.PP
Definition at line 325 of file aengine\&.cpp\&.
.PP
References AllocAndCopy(), and prompt\&.
.PP
Referenced by StandardConsole::SetPrompt()\&.
.PP
.nf
326 {
327     delete prompt;
328     AllocAndCopy(&prompt, string);
329 }
.fi
.SS "void AnsiConoleEngine::ShowLast ()\fC [private]\fP"

.PP
Definition at line 237 of file aengine\&.cpp\&.
.PP
References AllocAndCopy(), CharBuffer::Append(), CharBuffer::buf, curline, cursor, editline, CharBuffer::Empty(), endpos, CharBuffer::EnsureSize(), CharBuffer::GetString(), len, linebuf, lines, lineSize, lineswap, out, prompt, showline, and StrLen()\&.
.PP
Referenced by ProcessChar()\&.
.PP
.nf
238 {
239     if (curline == -1) {
240         return;
241     }
242 
243     if (!lineswap) {
244         AllocAndCopy(&editline, linebuf->GetString());
245         lineswap = true;
246         showline = curline + 1;
247     } else if (showline == curline + 1) {
248         delete editline;
249         AllocAndCopy(&editline, linebuf->GetString());
250     }
251 
252     showline--;
253     if (showline < 0) {
254         showline = 0;
255     }
256 
257     out->Empty();
258     out->EnsureSize(
259         StrLen(DELETELINE) +
260         StrLen(prompt) +
261         StrLen(lines[showline]) + 1);
262 
263     out->Append(DELETELINE);
264     out->Append(prompt);
265     out->Append(lines[showline]);
266 
267     linebuf->Empty();
268     linebuf->EnsureSize(StrLen(lines[showline]));
269     linebuf->Append(lines[showline]);
270 
271     unsigned int linelen = StrLen(linebuf->GetString());
272     cursor = linebuf->buf + linelen;
273     endpos = cursor;
274     len = lineSize - linelen;
275 }
.fi
.SS "void AnsiConoleEngine::ShowNext ()\fC [private]\fP"

.PP
Definition at line 277 of file aengine\&.cpp\&.
.PP
References CharBuffer::Append(), CharBuffer::buf, curline, cursor, editline, CharBuffer::Empty(), endpos, CharBuffer::EnsureGrowth(), CharBuffer::EnsureSize(), CharBuffer::GetString(), len, linebuf, lines, lineSize, lineswap, out, prompt, showline, and StrLen()\&.
.PP
Referenced by ProcessChar()\&.
.PP
.nf
278 {
279     if (!lineswap) {
280         return;
281     }
282 
283     showline++;
284     if (showline > curline + 1) {
285         showline = curline + 1;
286         return;
287     }
288 
289     out->Empty();
290     out->Append(DELETELINE);
291     out->Append(prompt);
292 
293     if (showline > curline) {
294         out->EnsureGrowth(StrLen(editline) + 1);
295         out->Append(editline);
296 
297         linebuf->Empty();
298         linebuf->EnsureSize(StrLen(editline));
299         linebuf->Append(editline);
300     } else {
301         out->EnsureGrowth(StrLen(lines[showline]) + 1);
302         out->Append(lines[showline]);
303 
304         linebuf->Empty();
305         linebuf->EnsureSize(StrLen(lines[showline]));
306         linebuf->Append(lines[showline]);
307     }
308 
309     unsigned int linelen = StrLen(linebuf->GetString());
310     cursor = linebuf->buf + linelen;
311     endpos = cursor;
312     len = lineSize - linelen;
313 }
.fi
.SS "void AnsiConoleEngine::StartInput ()"

.PP
Definition at line 63 of file aengine\&.cpp\&.
.PP
References CharBuffer::buf, CharBuffer::ClearAndAlloc(), csimode, cursor, delmode, endpos, escmode, len, linebuf, linedone, lineSize, and lineswap\&.
.PP
Referenced by StandardConsole::ReadLine()\&.
.PP
.nf
64 {
65     linebuf->ClearAndAlloc(lineSize + 1);
66     len = lineSize;
67     cursor = linebuf->buf;
68     endpos = cursor;
69     *endpos = '\0';
70 
71     lineswap = false;
72     escmode = false;
73     csimode = false;
74     delmode = false;
75     linedone = false;
76 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBbool\fP AnsiConoleEngine::csimode\fC [private]\fP"

.PP
Definition at line 78 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), and StartInput()\&.
.SS "int AnsiConoleEngine::curline\fC [private]\fP"

.PP
Definition at line 72 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), CopyLine(), ShowLast(), and ShowNext()\&.
.SS "char* AnsiConoleEngine::cursor\fC [private]\fP"

.PP
Definition at line 69 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), ShowLast(), ShowNext(), and StartInput()\&.
.SS "\fBbool\fP AnsiConoleEngine::delmode\fC [private]\fP"

.PP
Definition at line 79 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), and StartInput()\&.
.SS "char* AnsiConoleEngine::editline\fC [private]\fP"

.PP
Definition at line 75 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), CopyLine(), ShowLast(), and ShowNext()\&.
.SS "char* AnsiConoleEngine::endpos\fC [private]\fP"

.PP
Definition at line 70 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), ShowLast(), ShowNext(), and StartInput()\&.
.SS "\fBbool\fP AnsiConoleEngine::escmode\fC [private]\fP"

.PP
Definition at line 77 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), and StartInput()\&.
.SS "unsigned int AnsiConoleEngine::len\fC [private]\fP"

.PP
Definition at line 68 of file aengine\&.h\&.
.PP
Referenced by ProcessChar(), ShowLast(), ShowNext(), and StartInput()\&.
.SS "\fBCharBuffer\fP* AnsiConoleEngine::linebuf\fC [private]\fP"

.PP
Definition at line 66 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), CopyLine(), GetLine(), ProcessChar(), ShowLast(), ShowNext(), StartInput(), and ~AnsiConoleEngine()\&.
.SS "\fBbool\fP AnsiConoleEngine::linedone\fC [private]\fP"

.PP
Definition at line 80 of file aengine\&.h\&.
.PP
Referenced by InputDone(), ProcessChar(), and StartInput()\&.
.SS "char** AnsiConoleEngine::lines\fC [private]\fP"

.PP
Definition at line 65 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), CopyLine(), ShowLast(), ShowNext(), and ~AnsiConoleEngine()\&.
.SS "const int AnsiConoleEngine::lineSize = 1024\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 64 of file aengine\&.h\&.
.PP
Referenced by ShowLast(), ShowNext(), and StartInput()\&.
.SS "\fBbool\fP AnsiConoleEngine::lineswap\fC [private]\fP"

.PP
Definition at line 74 of file aengine\&.h\&.
.PP
Referenced by ShowLast(), ShowNext(), and StartInput()\&.
.SS "const int AnsiConoleEngine::maxLines = 20\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 63 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), CopyLine(), and ~AnsiConoleEngine()\&.
.SS "\fBCharBuffer\fP* AnsiConoleEngine::out\fC [private]\fP"

.PP
Definition at line 81 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), ProcessChar(), ShowLast(), ShowNext(), and ~AnsiConoleEngine()\&.
.SS "char* AnsiConoleEngine::prompt\fC [private]\fP"

.PP
Definition at line 61 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), SetPrompt(), ShowLast(), ShowNext(), and ~AnsiConoleEngine()\&.
.SS "int AnsiConoleEngine::showline\fC [private]\fP"

.PP
Definition at line 73 of file aengine\&.h\&.
.PP
Referenced by ShowLast(), and ShowNext()\&.
.SS "\fBCharValidator\fP* AnsiConoleEngine::validator\fC [private]\fP"

.PP
Definition at line 67 of file aengine\&.h\&.
.PP
Referenced by AnsiConoleEngine(), and ProcessChar()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
