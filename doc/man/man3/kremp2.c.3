.TH "lib/real/kremp2.c" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/kremp2.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'prim\&.h'\fP
.br
\fC#include 'math\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fB__kernel_rem_pio2\fP (double *x, double *y, int e0, int nx, int prec, const int *ipio2)"
.br
.RI "\fIKernel reduction function\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const int \fBinit_jk\fP [] = {2,3,4,6}"
.br
.ti -1c
.RI "static const double \fBPIo2\fP []"
.br
.ti -1c
.RI "static const double \fBzero\fP = 0\&.0"
.br
.ti -1c
.RI "static const double \fBone\fP = 1\&.0"
.br
.ti -1c
.RI "static const double \fBtwo24\fP = 1\&.67772160000000000000e+07"
.br
.ti -1c
.RI "static const double \fBtwon24\fP = 5\&.96046447753906250000e\-08"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int __kernel_rem_pio2 (double * x, double * y, int e0, int nx, int prec, const int * ipio2)"

.PP
Kernel reduction function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.4 
.RE
.PP
\fBDate:\fP
.RS 4
96/03/07
.RE
.PP
.PP
.nf

__kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
double x[],y[]; int e0,nx,prec; int ipio2[];
.fi
.PP
.PP
.PP
.nf
__kernel_rem_pio2 return the last three digits of N with
    y = x - N*pi/2
so that |y| < pi/2\&.
.fi
.PP
.PP
.PP
.nf
The method is to compute the integer (mod 8) and fraction parts of
(2/pi)*x without doing the full multiplication\&. In general we
skip the part of the product that are known to be a huge integer (
more accurately, = 0 mod 8 )\&. Thus the number of operations are
independent of the exponent of the input\&.
.fi
.PP
.PP
.PP
.nf
(2/pi) is represented by an array of 24-bit integers in ipio2[]\&.
.fi
.PP
.PP
.PP
.nf
Input parameters:
    x[] The input value (must be positive) is broken into nx
    pieces of 24-bit integers in double precision format\&.
    x[i] will be the i-th 24 bit of x\&. The scaled exponent
    of x[0] is given in input parameter e0 (i\&.e\&., x[0]*2^e0
    match x's up to 24 bits\&.
.fi
.PP
.PP
.PP
.nf
    Example of breaking a double positive z into x[0]+x[1]+x[2]:
        e0 = ilogb(z)-23
        z  = scalbn(z,-e0)
    for i = 0,1,2
        x[i] = floor(z)
        z    = (z-x[i])*2**24
.fi
.PP
.PP
.PP
.nf
 y[]    ouput result in an array of double precision numbers\&.
    The dimension of y[] is:
        24-bit  precision   1
        53-bit  precision   2
        64-bit  precision   2
        113-bit precision   3
    The actual value is the sum of them\&. Thus for 113-bit
    precison, one may have to do something like:
.fi
.PP
.PP
.PP
.nf
    long double t,w,r_head, r_tail;
    t = (long double)y[2] + (long double)y[1];
    w = (long double)y[0];
    r_head = t+w;
    r_tail = w - (r_head - t);
.fi
.PP
.PP
.PP
.nf
 e0 The exponent of x[0]
.fi
.PP
.PP
.PP
.nf
 nx dimension of x[]
.fi
.PP
.PP
.PP
.nf
    prec    an integer indicating the precision:
        0   24  bits (single)
        1   53  bits (double)
        2   64  bits (extended)
        3   113 bits (quad)
.fi
.PP
.PP
.PP
.nf
 ipio2[]
    integer array, contains the (24*i)-th to (24*i+23)-th
    bit of 2/pi after binary point\&. The corresponding
    floating value is
.fi
.PP
.PP
.PP
.nf
        ipio2[i] * 2^(-24(i+1))\&.
.fi
.PP
.PP
.PP
.nf
External function:
 double \fBscalbn()\fP, \fBfloor()\fP;
.fi
.PP
.PP
.PP
.nf
Here is the description of some local variables:
.fi
.PP
.PP
.PP
.nf
    jk  jk+1 is the initial number of terms of ipio2[] needed
    in the computation\&. The recommended value is 2,3,4,
    6 for single, double, extended,and quad\&.
.fi
.PP
.PP
.PP
.nf
    jz  local integer variable indicating the number of
    terms of ipio2[] used\&.
.fi
.PP
.PP
.PP
.nf
 jx nx - 1
.fi
.PP
.PP
.PP
.nf
 jv index for pointing to the suitable ipio2[] for the
    computation\&. In general, we want
        ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
    is an integer\&. Thus
        e0-3-24*jv >= 0 or (e0-3)/24 >= jv
    Hence jv = max(0,(e0-3)/24)\&.
.fi
.PP
.PP
.PP
.nf
 jp jp+1 is the number of terms in PIo2[] needed, jp = jk\&.
.fi
.PP
.PP
.PP
.nf
    q[] double array with integral value, representing the
    24-bits chunk of the product of x and 2/pi\&.
.fi
.PP
.PP
.PP
.nf
 q0 the corresponding exponent of q[0]\&. Note that the
    exponent for q[i] would be q0-24*i\&.
.fi
.PP
.PP
.PP
.nf
 PIo2[] double precision array, obtained by cutting pi/2
    into 24 bits chunks\&.
.fi
.PP
.PP
.PP
.nf
 f[]    ipio2[] in floating point
.fi
.PP
.PP
.PP
.nf
 iq[]   integer array by breaking up q[] in 24-bits chunk\&.
.fi
.PP
.PP
.PP
.nf
 fq[]   final product of x*(2/pi) in fq[0],\&.\&.,fq[jk]
.fi
.PP
.PP
.PP
.nf
 ih integer\&. If >0 it indicates q[] is >= 0\&.5, hence
    it also indicates the *sign* of the result\&.
.fi
.PP
.PP
.PP
.nf
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 190 of file kremp2\&.c\&.
.PP
References init_jk, one, PIo2, scalbn(), two24, twon24, and zero\&.
.PP
Referenced by rempio2()\&.
.PP
.nf
191 {
192     int jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
193     double z,fw,f[20],fq[20],q[20];
194 
195     /* initialize jk*/
196     jk = init_jk[prec];
197     jp = jk;
198 
199     /* determine jx,jv,q0, note that 3>q0 */
200     jx =  nx-1;
201     jv = (e0-3)/24;
202     if(jv<0) jv=0;
203     q0 =  e0-24*(jv+1);
204 
205     /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
206     j = jv-jx;
207     m = jx+jk;
208     for(i=0; i<=m; i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
209 
210     /* compute q[0],q[1],\&.\&.\&.q[jk] */
211     for (i=0; i<=jk; i++) {
212         for(j=0,fw=0\&.0; j<=jx; j++) fw += x[j]*f[jx+i-j];
213         q[i] = fw;
214     }
215 
216     jz = jk;
217 recompute:
218     /* distill q[] into iq[] reversingly */
219     for(i=0,j=jz,z=q[jz]; j>0; i++,j--) {
220         fw    =  (double)((int)(twon24* z));
221         iq[i] =  (int)(z-two24*fw);
222         z     =  q[j-1]+fw;
223     }
224 
225     /* compute n */
226     z  = scalbn(z,q0);      /* actual value of z */
227     z -= 8\&.0*floor(z*0\&.125);      /* trim off integer >= 8 */
228     n  = (int) z;
229     z -= (double)n;
230     ih = 0;
231     if(q0>0) {  /* need iq[jz-1] to determine n */
232         i  = (iq[jz-1]>>(24-q0));
233         n += i;
234         iq[jz-1] -= i<<(24-q0);
235         ih = iq[jz-1]>>(23-q0);
236     }
237     else if(q0==0) ih = iq[jz-1]>>23;
238     else if(z>=0\&.5) ih=2;
239 
240     if(ih>0) {  /* q > 0\&.5 */
241         n += 1;
242         carry = 0;
243         for(i=0; i<jz ; i++) {  /* compute 1-q */
244             j = iq[i];
245             if(carry==0) {
246                 if(j!=0) {
247                     carry = 1;
248                     iq[i] = 0x1000000- j;
249                 }
250             } else  iq[i] = 0xffffff - j;
251         }
252         if(q0>0) {      /* rare case: chance is 1 in 12 */
253             switch(q0) {
254             case 1:
255                 iq[jz-1] &= 0x7fffff;
256                 break;
257             case 2:
258                 iq[jz-1] &= 0x3fffff;
259                 break;
260             }
261         }
262         if(ih==2) {
263             z = one - z;
264             if(carry!=0) z -= scalbn(one,q0);
265         }
266     }
267 
268     /* check if recomputation is needed */
269     if(z==zero) {
270         j = 0;
271         for (i=jz-1; i>=jk; i--) j |= iq[i];
272         if(j==0) { /* need recomputation */
273             for(k=1; iq[jk-k]==0; k++); /* k = no\&. of terms needed */
274 
275             for(i=jz+1; i<=jz+k; i++) { /* add q[jz+1] to q[jz+k] */
276                 f[jx+i] = (double) ipio2[jv+i];
277                 for(j=0,fw=0\&.0; j<=jx; j++) fw += x[j]*f[jx+i-j];
278                 q[i] = fw;
279             }
280             jz += k;
281             goto recompute;
282         }
283     }
284 
285     /* chop off zero terms */
286     if(z==0\&.0) {
287         jz -= 1;
288         q0 -= 24;
289         while(iq[jz]==0) {
290             jz--;
291             q0-=24;
292         }
293     } else { /* break z into 24-bit if necessary */
294         z = scalbn(z,-q0);
295         if(z>=two24) {
296             fw = (double)((int)(twon24*z));
297             iq[jz] = (int)(z-two24*fw);
298             jz += 1;
299             q0 += 24;
300             iq[jz] = (int) fw;
301         } else iq[jz] = (int) z ;
302     }
303 
304     /* convert integer "bit" chunk to floating-point value */
305     fw = scalbn(one,q0);
306     for(i=jz; i>=0; i--) {
307         q[i] = fw*(double)iq[i];
308         fw*=twon24;
309     }
310 
311     /* compute PIo2[0,\&.\&.\&.,jp]*q[jz,\&.\&.\&.,0] */
312     for(i=jz; i>=0; i--) {
313         for(fw=0\&.0,k=0; k<=jp&&k<=jz-i; k++) fw += PIo2[k]*q[i+k];
314         fq[jz-i] = fw;
315     }
316 
317     /* compress fq[] into y[] */
318     switch(prec) {
319     case 0:
320         fw = 0\&.0;
321         for (i=jz; i>=0; i--) fw += fq[i];
322         y[0] = (ih==0)? fw: -fw;
323         break;
324     case 1:
325     case 2:
326         fw = 0\&.0;
327         for (i=jz; i>=0; i--) fw += fq[i];
328         y[0] = (ih==0)? fw: -fw;
329         fw = fq[0]-fw;
330         for (i=1; i<=jz; i++) fw += fq[i];
331         y[1] = (ih==0)? fw: -fw;
332         break;
333     case 3: /* painful */
334         for (i=jz; i>0; i--) {
335             fw      = fq[i-1]+fq[i];
336             fq[i]  += fq[i-1]-fw;
337             fq[i-1] = fw;
338         }
339         for (i=jz; i>1; i--) {
340             fw      = fq[i-1]+fq[i];
341             fq[i]  += fq[i-1]-fw;
342             fq[i-1] = fw;
343         }
344         for (fw=0\&.0,i=jz; i>=2; i--) fw += fq[i];
345         if(ih==0) {
346             y[0] =  fq[0];
347             y[1] =  fq[1];
348             y[2] =  fw;
349         } else {
350             y[0] = -fq[0];
351             y[1] = -fq[1];
352             y[2] = -fw;
353         }
354     }
355     return n&7;
356 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const int init_jk[] = {2,3,4,6}\fC [static]\fP"

.PP
Definition at line 54 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SS "const double one = 1\&.0\fC [static]\fP"

.PP
Definition at line 69 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SS "const double PIo2[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    1\&.57079625129699707031e+00, 
    7\&.54978941586159635335e-08, 
    5\&.39030252995776476554e-15, 
    3\&.28200341580791294123e-22, 
    1\&.27065575308067607349e-29, 
    1\&.22933308981111328932e-36, 
    2\&.73370053816464559624e-44, 
    2\&.16741683877804819444e-51, 
}
.fi
.PP
Definition at line 56 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SS "const double two24 = 1\&.67772160000000000000e+07\fC [static]\fP"

.PP
Definition at line 70 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SS "const double twon24 = 5\&.96046447753906250000e\-08\fC [static]\fP"

.PP
Definition at line 71 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SS "const double zero = 0\&.0\fC [static]\fP"

.PP
Definition at line 68 of file kremp2\&.c\&.
.PP
Referenced by __kernel_rem_pio2()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
