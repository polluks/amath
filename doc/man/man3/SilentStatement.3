.TH "SilentStatement" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SilentStatement \- Mutes the output of another statement\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <statements\&.h>\fP
.PP
Inherits \fBStatementNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSilentStatement\fP (\fBStatementNode\fP *\fBstatement\fP)"
.br
.ti -1c
.RI "\fB~SilentStatement\fP ()"
.br
.ti -1c
.RI "char * \fBExecute\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBGetNext\fP ()"
.br
.ti -1c
.RI "void \fBAttach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "void \fBDetach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "void \fBReplace\fP (\fBSyntaxNode\fP *n, \fBSyntaxNode\fP *x)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBStatementNode\fP * \fBstatement\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Mutes the output of another statement\&. 

Statement node which encapsulate another statement and mutes the output when executing the inner statement\&. 
.PP
Definition at line 136 of file statements\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SilentStatement::SilentStatement (\fBStatementNode\fP * statement)"

.PP
Definition at line 198 of file statements\&.cpp\&.
.PP
References statement\&.
.PP
Referenced by Parser::ParseEvaluation()\&.
.PP
.nf
198                                                          :
199     statement(statement) { }
.fi
.SS "SilentStatement::~SilentStatement ()"

.PP
Definition at line 201 of file statements\&.cpp\&.
.PP
References statement\&.
.PP
.nf
202 {
203     if (statement != NOMEM) {
204         delete statement;
205     }
206 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void SilentStatement::Attach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Reimplemented from \fBStatementNode\fP\&.
.PP
Definition at line 224 of file statements\&.cpp\&.
.PP
References SyntaxNode::SetParent(), and statement\&.
.PP
.nf
225 {
226     if (statement == NOMEM) {
227         statement = (StatementNode*)node;
228         node->SetParent(this);
229     }
230 }
.fi
.SS "void SilentStatement::Detach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Reimplemented from \fBStatementNode\fP\&.
.PP
Definition at line 232 of file statements\&.cpp\&.
.PP
References statement\&.
.PP
.nf
233 {
234     if (statement == node) {
235         statement = NOMEM;
236     }
237 }
.fi
.SS "char * SilentStatement::Execute ()\fC [virtual]\fP"

.PP
Implements \fBStatementNode\fP\&.
.PP
Definition at line 208 of file statements\&.cpp\&.
.PP
References StatementNode::Execute(), and statement\&.
.PP
.nf
209 {
210     statement->Execute();
211     return (char*)EMPTYSTRING;
212 }
.fi
.SS "\fBSyntaxNode\fP * SilentStatement::GetNext ()\fC [virtual]\fP"

.PP
Reimplemented from \fBStatementNode\fP\&.
.PP
Definition at line 214 of file statements\&.cpp\&.
.PP
References SyntaxNode::iterator, and statement\&.
.PP
.nf
215 {
216     if (iterator == NOMEM) {
217         iterator = statement;
218         return iterator;
219     }
220 
221     return NOMEM;
222 }
.fi
.SS "void SilentStatement::Replace (\fBSyntaxNode\fP * n, \fBSyntaxNode\fP * x)\fC [virtual]\fP"

.PP
Reimplemented from \fBStatementNode\fP\&.
.PP
Definition at line 239 of file statements\&.cpp\&.
.PP
References statement\&.
.PP
.nf
240 {
241     if (statement == n) {
242         delete statement;
243         statement = (StatementNode*)x;
244     }
245 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBStatementNode\fP* SilentStatement::statement\fC [private]\fP"

.PP
Definition at line 148 of file statements\&.h\&.
.PP
Referenced by Attach(), Detach(), Execute(), GetNext(), Replace(), SilentStatement(), and ~SilentStatement()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
