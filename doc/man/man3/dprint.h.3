.TH "lib/dprint.h" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/dprint.h \- Format defitions used in the Dragon4 library\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'dstandard\&.h'\fP
.br

.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBtPrintFloatFormat\fP { \fBPrintFloatFormat_Positional\fP, \fBPrintFloatFormat_Scientific\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBtU32\fP \fBPrintFloat32\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtF32\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.ti -1c
.RI "\fBtU32\fP \fBPrintFloat64\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtF64\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Format defitions used in the Dragon4 library\&. 


.PP
Definition in file \fBdprint\&.h\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBtPrintFloatFormat\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPrintFloatFormat_Positional \fP\fP
.TP
\fB\fIPrintFloatFormat_Scientific \fP\fP
.PP
Definition at line 70 of file dprint\&.h\&.
.PP
.nf
71 {
72     PrintFloatFormat_Positional,    // [-]ddddd\&.dddd
73     PrintFloatFormat_Scientific,    // [-]d\&.dddde[sign]ddd
74 };
.fi
.SH "Function Documentation"
.PP 
.SS "\fBtU32\fP PrintFloat32 (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtF32\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 465 of file dprint\&.cpp\&.
.PP
References FormatPositional(), FormatScientific(), tFloatUnion32::GetExponent(), tFloatUnion32::GetMantissa(), tFloatUnion32::IsNegative(), LogBase2(), tFloatUnion32::m_floatingPoint, PrintFloatFormat_Positional, PrintFloatFormat_Scientific, and PrintInfNan()\&.
.PP
.nf
475 {
476     if (bufferSize == 0)
477         return 0;
478 
479     if (bufferSize == 1)
480     {
481         pOutBuffer[0] = '\0';
482         return 1;
483     }
484 
485     // deconstruct the floating point value
486     tFloatUnion32 floatUnion;
487     floatUnion\&.m_floatingPoint = value;
488     tU32 floatExponent = floatUnion\&.GetExponent();
489     tU32 floatMantissa = floatUnion\&.GetMantissa();
490 
491     // output the sign
492     if (floatUnion\&.IsNegative())
493     {
494         pOutBuffer[0] = '-';
495         ++pOutBuffer;
496         --bufferSize;
497         RJ_ASSERT(bufferSize > 0);
498     }
499 
500     // if this is a special value
501     if (floatExponent == 0xFF)
502     {
503         return PrintInfNan(pOutBuffer, bufferSize, floatMantissa, 6);
504     }
505     // else this is a number
506     else
507     {
508         // factor the value into its parts
509         tU32 mantissa;
510         tS32 exponent;
511         tU32 mantissaHighBitIdx;
512         tB hasUnequalMargins;
513         if (floatExponent != 0)
514         {
515             // normalized
516             // The floating point equation is:
517             //  value = (1 + mantissa/2^23) * 2 ^ (exponent-127)
518             // We convert the integer equation by factoring a 2^23 out of the exponent
519             //  value = (1 + mantissa/2^23) * 2^23 * 2 ^ (exponent-127-23)
520             //  value = (2^23 + mantissa) * 2 ^ (exponent-127-23)
521             // Because of the implied 1 in front of the mantissa we have 24 bits of precision\&.
522             //   m = (2^23 + mantissa)
523             //   e = (exponent-127-23)
524             mantissa            = (1UL << 23) | floatMantissa;
525             exponent            = floatExponent - 127 - 23;
526             mantissaHighBitIdx  = 23;
527             hasUnequalMargins   = (floatExponent != 1) && (floatMantissa == 0);
528         }
529         else
530         {
531             // denormalized
532             // The floating point equation is:
533             //  value = (mantissa/2^23) * 2 ^ (1-127)
534             // We convert the integer equation by factoring a 2^23 out of the exponent
535             //  value = (mantissa/2^23) * 2^23 * 2 ^ (1-127-23)
536             //  value = mantissa * 2 ^ (1-127-23)
537             // We have up to 23 bits of precision\&.
538             //   m = (mantissa)
539             //   e = (1-127-23)
540             mantissa           = floatMantissa;
541             exponent           = 1 - 127 - 23;
542             mantissaHighBitIdx = LogBase2(mantissa);
543             hasUnequalMargins   = false;
544         }
545 
546         // format the value
547         switch (format)
548         {
549         case PrintFloatFormat_Positional:
550             return FormatPositional(    pOutBuffer,
551                                         bufferSize,
552                                         mantissa,
553                                         exponent,
554                                         mantissaHighBitIdx,
555                                         hasUnequalMargins,
556                                         precision,
557                                         decimalPoint );
558 
559         case PrintFloatFormat_Scientific:
560             return FormatScientific(    pOutBuffer,
561                                         bufferSize,
562                                         mantissa,
563                                         exponent,
564                                         mantissaHighBitIdx,
565                                         hasUnequalMargins,
566                                         precision,
567                                         decimalPoint );
568 
569         default:
570             pOutBuffer[0] = '\0';
571             return 0;
572         }
573     }
574 }
.fi
.SS "\fBtU32\fP PrintFloat64 (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtF64\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 582 of file dprint\&.cpp\&.
.PP
References FormatPositional(), FormatScientific(), tFloatUnion64::GetExponent(), tFloatUnion64::GetMantissa(), tFloatUnion64::IsNegative(), LogBase2(), tFloatUnion64::m_floatingPoint, PrintFloatFormat_Positional, PrintFloatFormat_Scientific, and PrintInfNan()\&.
.PP
Referenced by DecimalSystem::GetRealText()\&.
.PP
.nf
592 {
593     if (bufferSize == 0)
594         return 0;
595 
596     if (bufferSize == 1)
597     {
598         pOutBuffer[0] = '\0';
599         return 1;
600     }
601 
602     // deconstruct the floating point value
603     tFloatUnion64 floatUnion;
604     floatUnion\&.m_floatingPoint = value;
605     tU32 floatExponent = floatUnion\&.GetExponent();
606     tU64 floatMantissa = floatUnion\&.GetMantissa();
607 
608     // output the sign
609     if (floatUnion\&.IsNegative())
610     {
611         pOutBuffer[0] = '-';
612         ++pOutBuffer;
613         --bufferSize;
614         RJ_ASSERT(bufferSize > 0);
615     }
616 
617     // if this is a special value
618     if (floatExponent == 0x7FF)
619     {
620         return PrintInfNan(pOutBuffer, bufferSize, floatMantissa, 13);
621     }
622     // else this is a number
623     else
624     {
625         // factor the value into its parts
626         tU64 mantissa;
627         tS32 exponent;
628         tU32 mantissaHighBitIdx;
629         tB hasUnequalMargins;
630 
631         if (floatExponent != 0)
632         {
633             // normal
634             // The floating point equation is:
635             //  value = (1 + mantissa/2^52) * 2 ^ (exponent-1023)
636             // We convert the integer equation by factoring a 2^52 out of the exponent
637             //  value = (1 + mantissa/2^52) * 2^52 * 2 ^ (exponent-1023-52)
638             //  value = (2^52 + mantissa) * 2 ^ (exponent-1023-52)
639             // Because of the implied 1 in front of the mantissa we have 53 bits of precision\&.
640             //   m = (2^52 + mantissa)
641             //   e = (exponent-1023+1-53)
642             mantissa            = (1ull << 52) | floatMantissa;
643             exponent            = floatExponent - 1023 - 52;
644             mantissaHighBitIdx  = 52;
645             hasUnequalMargins   = (floatExponent != 1) && (floatMantissa == 0);
646         }
647         else
648         {
649             // subnormal
650             // The floating point equation is:
651             //  value = (mantissa/2^52) * 2 ^ (1-1023)
652             // We convert the integer equation by factoring a 2^52 out of the exponent
653             //  value = (mantissa/2^52) * 2^52 * 2 ^ (1-1023-52)
654             //  value = mantissa * 2 ^ (1-1023-52)
655             // We have up to 52 bits of precision\&.
656             //   m = (mantissa)
657             //   e = (1-1023-52)
658             mantissa            = floatMantissa;
659             exponent            = 1 - 1023 - 52;
660             mantissaHighBitIdx  = LogBase2(mantissa);
661             hasUnequalMargins   = false;
662         }
663 
664         // format the value
665         switch (format)
666         {
667         case PrintFloatFormat_Positional:
668             return FormatPositional(    pOutBuffer,
669                                         bufferSize,
670                                         mantissa,
671                                         exponent,
672                                         mantissaHighBitIdx,
673                                         hasUnequalMargins,
674                                         precision,
675                                         decimalPoint );
676 
677         case PrintFloatFormat_Scientific:
678             return FormatScientific(    pOutBuffer,
679                                         bufferSize,
680                                         mantissa,
681                                         exponent,
682                                         mantissaHighBitIdx,
683                                         hasUnequalMargins,
684                                         precision,
685                                         decimalPoint );
686 
687         default:
688             pOutBuffer[0] = '\0';
689             return 0;
690         }
691     }
692 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
