.TH "UnaryNode" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
UnaryNode \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <operators\&.h>\fP
.PP
Inherits \fBExpressionNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBUnaryNode\fP (\fBExpressionNode\fP *\fBexpression\fP)"
.br
.ti -1c
.RI "\fB~UnaryNode\fP ()"
.br
.ti -1c
.RI "\fBReductionType\fP \fBGetReductionType\fP ()"
.br
.ti -1c
.RI "int \fBGetPrecedence\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBGetNext\fP ()"
.br
.ti -1c
.RI "char * \fBGetText\fP ()"
.br
.ti -1c
.RI "\fBNumber\fP * \fBEvaluate\fP ()"
.br
.ti -1c
.RI "void \fBAttach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "void \fBDetach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "void \fBReplace\fP (\fBSyntaxNode\fP *n, \fBSyntaxNode\fP *x)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "char * \fBGetNodeText\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBExpressionNode\fP * \fBexpression\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 39 of file operators\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "UnaryNode::UnaryNode (\fBExpressionNode\fP * expression)"

.PP
Definition at line 36 of file operators\&.cpp\&.
.PP
References expression, and ExpressionNode::ExpressionNode()\&.
.PP
Referenced by Parser::ParseUnary()\&.
.PP
.nf
36                                                :
37     ExpressionNode(), expression(expression) { }
.fi
.SS "UnaryNode::~UnaryNode ()"

.PP
Definition at line 39 of file operators\&.cpp\&.
.PP
References expression\&.
.PP
.nf
40 {
41     if (expression != NOMEM) {
42         delete expression;
43     }
44 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void UnaryNode::Attach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Definition at line 98 of file operators\&.cpp\&.
.PP
References expression, and SyntaxNode::SetParent()\&.
.PP
.nf
99 {
100     if (expression == NOMEM) {
101         expression = (ExpressionNode*)node;
102         node->SetParent(this);
103     }
104 }
.fi
.SS "void UnaryNode::Detach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Definition at line 106 of file operators\&.cpp\&.
.PP
References expression\&.
.PP
.nf
107 {
108     if (expression == node) {
109         expression = NOMEM;
110     }
111 }
.fi
.SS "\fBNumber\fP * UnaryNode::Evaluate ()\fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 82 of file operators\&.cpp\&.
.PP
References ExpressionNode::Evaluate(), expression, ExpressionNode::result, and Number::Unary()\&.
.PP
.nf
83 {
84     result = expression->Evaluate()->Unary();
85     return result;
86 }
.fi
.SS "\fBSyntaxNode\fP * UnaryNode::GetNext ()\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Definition at line 88 of file operators\&.cpp\&.
.PP
References expression, and SyntaxNode::iterator\&.
.PP
.nf
89 {
90     if (iterator == NOMEM) {
91         iterator = expression;
92         return iterator;
93     }
94 
95     return NOMEM;
96 }
.fi
.SS "char * UnaryNode::GetNodeText ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 56 of file operators\&.cpp\&.
.PP
Referenced by GetText()\&.
.PP
.nf
57 {
58     return (char*)"-";
59 }
.fi
.SS "int UnaryNode::GetPrecedence ()\fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 51 of file operators\&.cpp\&.
.PP
Referenced by GetText()\&.
.PP
.nf
52 {
53     return 7;
54 }
.fi
.SS "\fBReductionType\fP UnaryNode::GetReductionType ()\fC [virtual]\fP"

.PP
Reimplemented from \fBSyntaxNode\fP\&.
.PP
Definition at line 46 of file operators\&.cpp\&.
.PP
References unaryreduc\&.
.PP
.nf
47 {
48     return unaryreduc;
49 }
.fi
.SS "char * UnaryNode::GetText ()\fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 61 of file operators\&.cpp\&.
.PP
References CharBuffer::Append(), CharBuffer::Empty(), CharBuffer::EnsureSize(), expression, GetNodeText(), GetPrecedence(), ExpressionNode::GetPrecedence(), CharBuffer::GetString(), ExpressionNode::GetText(), SyntaxNode::output, and StrLen()\&.
.PP
.nf
62 {
63     const char *expText = expression->GetText();
64     const char *nodeText = GetNodeText();
65 
66     output->Empty();
67     output->EnsureSize(StrLen(expText) + StrLen(nodeText) + 2 + 1);
68 
69     if (expression->GetPrecedence() != 0 && expression->GetPrecedence() != 5 && expression->GetPrecedence() <= GetPrecedence()) {
70         output->Append(nodeText);
71         output->Append("(");
72         output->Append(expText);
73         output->Append(")");
74     } else {
75         output->Append(nodeText);
76         output->Append(expText);
77     }
78 
79     return output->GetString();
80 }
.fi
.SS "void UnaryNode::Replace (\fBSyntaxNode\fP * n, \fBSyntaxNode\fP * x)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Definition at line 113 of file operators\&.cpp\&.
.PP
References expression\&.
.PP
.nf
114 {
115     if (expression == n) {
116         delete expression;
117         expression = (ExpressionNode*)x;
118     }
119 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBExpressionNode\fP* UnaryNode::expression\fC [private]\fP"

.PP
Definition at line 57 of file operators\&.h\&.
.PP
Referenced by Attach(), Detach(), Evaluate(), GetNext(), GetText(), Replace(), UnaryNode(), and ~UnaryNode()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
