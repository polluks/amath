.TH "lib/clib/memcpy.c" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib/memcpy.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'clib\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTLOOP\fP(s)   if (t) \fBTLOOP1\fP(s)"
.br
.ti -1c
.RI "#define \fBTLOOP1\fP(s)   do { s; } while (\-\-t)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint32_t \fBword\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBMemCopy\fP (void *destination, const void *source, unsigned int length)"
.br
.RI "\fICopy a block of memory, handling overlap\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define TLOOP(s)   if (t) \fBTLOOP1\fP(s)"
Macros: loop-t-times; and loop-t-times, t>0 
.PP
Definition at line 65 of file memcpy\&.c\&.
.SS "#define TLOOP1(s)   do { s; } while (\-\-t)"

.PP
Definition at line 66 of file memcpy\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef uint32_t \fBword\fP"
sizeof(word) MUST BE A POWER OF TWO SO THAT wmask BELOW IS ALL ONES 
.PP
Definition at line 58 of file memcpy\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void MemCopy (void * destination, const void * source, unsigned int length)"

.PP
Copy a block of memory, handling overlap\&. 
.PP
Definition at line 71 of file memcpy\&.c\&.
.PP
Referenced by CharBuffer::EnsureSize(), FormatPositional(), FormatScientific(), Lexer::GetDigitValue(), Lexer::GetLitteral(), Lexer::GetQuotedIdent(), PrintInfNan(), and Language::UntagText()\&.
.PP
.nf
72 {
73     char *dst = (char*) destination;
74     const char *src = (const char*) source;
75     unsigned int t;
76 
77     if (length == 0 || dst == src) // nothing to do
78         return;
79 
80     if ((unsigned long)dst < (unsigned long)src) {
81         // Copy forward
82         t = (unsigned long)src; // only need low bits
83         if ((t | (unsigned long)dst) & wmask) {
84 
85             // Try to align operands\&.  This cannot be done unless the low bits match\&.
86             if ((t ^ (unsigned long)dst) & wmask || length < wsize)
87                 t = length;
88             else
89                 t = wsize - (t & wmask);
90             length -= t;
91 
92             TLOOP1(*dst++ = *src++);
93         }
94 
95         // Copy whole words, then mop up any trailing bytes\&.
96         t = length / wsize;
97         TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
98 
99         t = length & wmask;
100         TLOOP(*dst++ = *src++);
101 
102     } else {
103         // Copy backwards\&.  Otherwise essentially the same\&.
104         // Alignment works as before, except that it takes
105         // (t&wmask) bytes to align, not wsize-(t&wmask)\&.
106         src += length;
107         dst += length;
108         t = (unsigned long)src;
109         if ((t | (unsigned long)dst) & wmask) {
110 
111             if ((t ^ (unsigned long)dst) & wmask || length <= wsize)
112                 t = length;
113             else
114                 t &= wmask;
115             length -= t;
116 
117             TLOOP1(*--dst = *--src);
118         }
119 
120         t = length / wsize;
121         TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
122 
123         t = length & wmask;
124         TLOOP(*--dst = *--src);
125     }
126 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
