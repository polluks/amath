.TH "lib/clib/memcpy.c" 3 "Sat Jan 21 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib/memcpy.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'clib\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTLOOP\fP(s)   if (t) \fBTLOOP1\fP(s)"
.br
.ti -1c
.RI "#define \fBTLOOP1\fP(s)   do { s; } while (\-\-t)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBword\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBMemCopy\fP (void *destination, const void *source, unsigned int length)"
.br
.RI "\fICopy a block of memory, handling overlap\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define TLOOP(s)   if (t) \fBTLOOP1\fP(s)"
Macros: loop-t-times; and loop-t-times, t>0 
.PP
Definition at line 50 of file memcpy\&.c\&.
.SS "#define TLOOP1(s)   do { s; } while (\-\-t)"

.PP
Definition at line 51 of file memcpy\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBword\fP"
sizeof(word) MUST BE A POWER OF TWO SO THAT wmask BELOW IS ALL ONES 
.PP
Definition at line 44 of file memcpy\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void MemCopy (void * destination, const void * source, unsigned int length)"

.PP
Copy a block of memory, handling overlap\&. Original file can be found at: https://svnweb.freebsd.org/base/release/9.0.0/lib/libc/string/bcopy.c?revision=229286 
.PP
Definition at line 60 of file memcpy\&.c\&.
.PP
Referenced by CharBuffer::EnsureSize(), FormatPositional(), FormatScientific(), Lexer::GetDigitValue(), Lexer::GetLitteral(), Lexer::GetQuotedIdent(), PrintInfNan(), and Language::UntagText()\&.
.PP
.nf
61 {
62     char *dst = (char*) destination;
63     const char *src = (const char*) source;
64     unsigned int t;
65 
66     if (length == 0 || dst == src) // nothing to do
67         return;
68 
69     if ((unsigned long)dst < (unsigned long)src) {
70         // Copy forward
71         t = (unsigned long)src; // only need low bits
72         if ((t | (unsigned long)dst) & wmask) {
73 
74             // Try to align operands\&.  This cannot be done unless the low bits match\&.
75             if ((t ^ (unsigned long)dst) & wmask || length < wsize)
76                 t = length;
77             else
78                 t = wsize - (t & wmask);
79             length -= t;
80 
81             TLOOP1(*dst++ = *src++);
82         }
83 
84         // Copy whole words, then mop up any trailing bytes\&.
85         t = length / wsize;
86         TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
87 
88         t = length & wmask;
89         TLOOP(*dst++ = *src++);
90 
91     } else {
92         // Copy backwards\&.  Otherwise essentially the same\&.
93         // Alignment works as before, except that it takes
94         // (t&wmask) bytes to align, not wsize-(t&wmask)\&.
95         src += length;
96         dst += length;
97         t = (unsigned long)src;
98         if ((t | (unsigned long)dst) & wmask) {
99 
100             if ((t ^ (unsigned long)dst) & wmask || length <= wsize)
101                 t = length;
102             else
103                 t &= wmask;
104             length -= t;
105 
106             TLOOP1(*--dst = *--src);
107         }
108 
109         t = length / wsize;
110         TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
111 
112         t = length & wmask;
113         TLOOP(*--dst = *--src);
114     }
115 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
