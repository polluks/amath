.TH "lib/real/kstandard.c" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/kstandard.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'fdlibm\&.h'\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBWRITE2\fP(u,  v)   fputs(u, stderr)"
.br
.ti -1c
.RI "#define \fBHUGE_VAL\fP   inf"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fB__kernel_standard\fP (double x, double y, int type)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static double \fBzero\fP = 0\&.0"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define HUGE_VAL   inf"

.SS "#define WRITE2(u, v)   fputs(u, stderr)"

.PP
Definition at line 51 of file kstandard\&.c\&.
.SH "Function Documentation"
.PP 
.SS "double __kernel_standard (double x, double y, int type)"

.PP
Definition at line 111 of file kstandard\&.c\&.
.PP
.nf
115 {
116     struct exception exc;
117 #ifndef HUGE_VAL    /* this is the only routine that uses HUGE_VAL */
118 #define HUGE_VAL inf
119     double inf = 0\&.0;
120 
121     __HI(inf) = 0x7ff00000; /* set inf to infinite */
122 #endif
123 
124 #ifdef _USE_WRITE
125     (void) fflush(stdout);
126 #endif
127     exc\&.arg1 = x;
128     exc\&.arg2 = y;
129     switch(type) {
130     case 1:
131         /* acos(|x|>1) */
132         exc\&.type = DOMAIN;
133         exc\&.name = "acos";
134         exc\&.retval = zero;
135         if (_LIB_VERSION == _POSIX_)
136             errno = EDOM;
137         else if (!matherr(&exc)) {
138             if(_LIB_VERSION == _SVID_) {
139                 (void) WRITE2("acos: DOMAIN error\n", 19);
140             }
141             errno = EDOM;
142         }
143         break;
144     case 2:
145         /* asin(|x|>1) */
146         exc\&.type = DOMAIN;
147         exc\&.name = "asin";
148         exc\&.retval = zero;
149         if(_LIB_VERSION == _POSIX_)
150             errno = EDOM;
151         else if (!matherr(&exc)) {
152             if(_LIB_VERSION == _SVID_) {
153                 (void) WRITE2("asin: DOMAIN error\n", 19);
154             }
155             errno = EDOM;
156         }
157         break;
158     case 3:
159         /* atan2(+-0,+-0) */
160         exc\&.arg1 = y;
161         exc\&.arg2 = x;
162         exc\&.type = DOMAIN;
163         exc\&.name = "atan2";
164         exc\&.retval = zero;
165         if(_LIB_VERSION == _POSIX_)
166             errno = EDOM;
167         else if (!matherr(&exc)) {
168             if(_LIB_VERSION == _SVID_) {
169                 (void) WRITE2("atan2: DOMAIN error\n", 20);
170             }
171             errno = EDOM;
172         }
173         break;
174     case 4:
175         /* hypot(finite,finite) overflow */
176         exc\&.type = OVERFLOW;
177         exc\&.name = "hypot";
178         if (_LIB_VERSION == _SVID_)
179             exc\&.retval = HUGE;
180         else
181             exc\&.retval = HUGE_VAL;
182         if (_LIB_VERSION == _POSIX_)
183             errno = ERANGE;
184         else if (!matherr(&exc)) {
185             errno = ERANGE;
186         }
187         break;
188     case 5:
189         /* cosh(finite) overflow */
190         exc\&.type = OVERFLOW;
191         exc\&.name = "cosh";
192         if (_LIB_VERSION == _SVID_)
193             exc\&.retval = HUGE;
194         else
195             exc\&.retval = HUGE_VAL;
196         if (_LIB_VERSION == _POSIX_)
197             errno = ERANGE;
198         else if (!matherr(&exc)) {
199             errno = ERANGE;
200         }
201         break;
202     case 6:
203         /* exp(finite) overflow */
204         exc\&.type = OVERFLOW;
205         exc\&.name = "exp";
206         if (_LIB_VERSION == _SVID_)
207             exc\&.retval = HUGE;
208         else
209             exc\&.retval = HUGE_VAL;
210         if (_LIB_VERSION == _POSIX_)
211             errno = ERANGE;
212         else if (!matherr(&exc)) {
213             errno = ERANGE;
214         }
215         break;
216     case 7:
217         /* exp(finite) underflow */
218         exc\&.type = UNDERFLOW;
219         exc\&.name = "exp";
220         exc\&.retval = zero;
221         if (_LIB_VERSION == _POSIX_)
222             errno = ERANGE;
223         else if (!matherr(&exc)) {
224             errno = ERANGE;
225         }
226         break;
227     case 8:
228         /* y0(0) = -inf */
229         exc\&.type = DOMAIN;   /* should be SING for IEEE */
230         exc\&.name = "y0";
231         if (_LIB_VERSION == _SVID_)
232             exc\&.retval = -HUGE;
233         else
234             exc\&.retval = -HUGE_VAL;
235         if (_LIB_VERSION == _POSIX_)
236             errno = EDOM;
237         else if (!matherr(&exc)) {
238             if (_LIB_VERSION == _SVID_) {
239                 (void) WRITE2("y0: DOMAIN error\n", 17);
240             }
241             errno = EDOM;
242         }
243         break;
244     case 9:
245         /* y0(x<0) = NaN */
246         exc\&.type = DOMAIN;
247         exc\&.name = "y0";
248         if (_LIB_VERSION == _SVID_)
249             exc\&.retval = -HUGE;
250         else
251             exc\&.retval = -HUGE_VAL;
252         if (_LIB_VERSION == _POSIX_)
253             errno = EDOM;
254         else if (!matherr(&exc)) {
255             if (_LIB_VERSION == _SVID_) {
256                 (void) WRITE2("y0: DOMAIN error\n", 17);
257             }
258             errno = EDOM;
259         }
260         break;
261     case 10:
262         /* y1(0) = -inf */
263         exc\&.type = DOMAIN;   /* should be SING for IEEE */
264         exc\&.name = "y1";
265         if (_LIB_VERSION == _SVID_)
266             exc\&.retval = -HUGE;
267         else
268             exc\&.retval = -HUGE_VAL;
269         if (_LIB_VERSION == _POSIX_)
270             errno = EDOM;
271         else if (!matherr(&exc)) {
272             if (_LIB_VERSION == _SVID_) {
273                 (void) WRITE2("y1: DOMAIN error\n", 17);
274             }
275             errno = EDOM;
276         }
277         break;
278     case 11:
279         /* y1(x<0) = NaN */
280         exc\&.type = DOMAIN;
281         exc\&.name = "y1";
282         if (_LIB_VERSION == _SVID_)
283             exc\&.retval = -HUGE;
284         else
285             exc\&.retval = -HUGE_VAL;
286         if (_LIB_VERSION == _POSIX_)
287             errno = EDOM;
288         else if (!matherr(&exc)) {
289             if (_LIB_VERSION == _SVID_) {
290                 (void) WRITE2("y1: DOMAIN error\n", 17);
291             }
292             errno = EDOM;
293         }
294         break;
295     case 12:
296         /* yn(n,0) = -inf */
297         exc\&.type = DOMAIN;   /* should be SING for IEEE */
298         exc\&.name = "yn";
299         if (_LIB_VERSION == _SVID_)
300             exc\&.retval = -HUGE;
301         else
302             exc\&.retval = -HUGE_VAL;
303         if (_LIB_VERSION == _POSIX_)
304             errno = EDOM;
305         else if (!matherr(&exc)) {
306             if (_LIB_VERSION == _SVID_) {
307                 (void) WRITE2("yn: DOMAIN error\n", 17);
308             }
309             errno = EDOM;
310         }
311         break;
312     case 13:
313         /* yn(x<0) = NaN */
314         exc\&.type = DOMAIN;
315         exc\&.name = "yn";
316         if (_LIB_VERSION == _SVID_)
317             exc\&.retval = -HUGE;
318         else
319             exc\&.retval = -HUGE_VAL;
320         if (_LIB_VERSION == _POSIX_)
321             errno = EDOM;
322         else if (!matherr(&exc)) {
323             if (_LIB_VERSION == _SVID_) {
324                 (void) WRITE2("yn: DOMAIN error\n", 17);
325             }
326             errno = EDOM;
327         }
328         break;
329     case 14:
330         /* lgamma(finite) overflow */
331         exc\&.type = OVERFLOW;
332         exc\&.name = "lgamma";
333         if (_LIB_VERSION == _SVID_)
334             exc\&.retval = HUGE;
335         else
336             exc\&.retval = HUGE_VAL;
337         if (_LIB_VERSION == _POSIX_)
338             errno = ERANGE;
339         else if (!matherr(&exc)) {
340             errno = ERANGE;
341         }
342         break;
343     case 15:
344         /* lgamma(-integer) or lgamma(0) */
345         exc\&.type = SING;
346         exc\&.name = "lgamma";
347         if (_LIB_VERSION == _SVID_)
348             exc\&.retval = HUGE;
349         else
350             exc\&.retval = HUGE_VAL;
351         if (_LIB_VERSION == _POSIX_)
352             errno = EDOM;
353         else if (!matherr(&exc)) {
354             if (_LIB_VERSION == _SVID_) {
355                 (void) WRITE2("lgamma: SING error\n", 19);
356             }
357             errno = EDOM;
358         }
359         break;
360     case 16:
361         /* log(0) */
362         exc\&.type = SING;
363         exc\&.name = "log";
364         if (_LIB_VERSION == _SVID_)
365             exc\&.retval = -HUGE;
366         else
367             exc\&.retval = -HUGE_VAL;
368         if (_LIB_VERSION == _POSIX_)
369             errno = ERANGE;
370         else if (!matherr(&exc)) {
371             if (_LIB_VERSION == _SVID_) {
372                 (void) WRITE2("log: SING error\n", 16);
373             }
374             errno = EDOM;
375         }
376         break;
377     case 17:
378         /* log(x<0) */
379         exc\&.type = DOMAIN;
380         exc\&.name = "log";
381         if (_LIB_VERSION == _SVID_)
382             exc\&.retval = -HUGE;
383         else
384             exc\&.retval = -HUGE_VAL;
385         if (_LIB_VERSION == _POSIX_)
386             errno = EDOM;
387         else if (!matherr(&exc)) {
388             if (_LIB_VERSION == _SVID_) {
389                 (void) WRITE2("log: DOMAIN error\n", 18);
390             }
391             errno = EDOM;
392         }
393         break;
394     case 18:
395         /* log10(0) */
396         exc\&.type = SING;
397         exc\&.name = "log10";
398         if (_LIB_VERSION == _SVID_)
399             exc\&.retval = -HUGE;
400         else
401             exc\&.retval = -HUGE_VAL;
402         if (_LIB_VERSION == _POSIX_)
403             errno = ERANGE;
404         else if (!matherr(&exc)) {
405             if (_LIB_VERSION == _SVID_) {
406                 (void) WRITE2("log10: SING error\n", 18);
407             }
408             errno = EDOM;
409         }
410         break;
411     case 19:
412         /* log10(x<0) */
413         exc\&.type = DOMAIN;
414         exc\&.name = "log10";
415         if (_LIB_VERSION == _SVID_)
416             exc\&.retval = -HUGE;
417         else
418             exc\&.retval = -HUGE_VAL;
419         if (_LIB_VERSION == _POSIX_)
420             errno = EDOM;
421         else if (!matherr(&exc)) {
422             if (_LIB_VERSION == _SVID_) {
423                 (void) WRITE2("log10: DOMAIN error\n", 20);
424             }
425             errno = EDOM;
426         }
427         break;
428     case 20:
429         /* pow(0\&.0,0\&.0) */
430         /* error only if _LIB_VERSION == _SVID_ */
431         exc\&.type = DOMAIN;
432         exc\&.name = "pow";
433         exc\&.retval = zero;
434         if (_LIB_VERSION != _SVID_) exc\&.retval = 1\&.0;
435         else if (!matherr(&exc)) {
436             (void) WRITE2("pow(0,0): DOMAIN error\n", 23);
437             errno = EDOM;
438         }
439         break;
440     case 21:
441         /* pow(x,y) overflow */
442         exc\&.type = OVERFLOW;
443         exc\&.name = "pow";
444         if (_LIB_VERSION == _SVID_) {
445             exc\&.retval = HUGE;
446             y *= 0\&.5;
447             if(x<zero&&rint(y)!=y) exc\&.retval = -HUGE;
448         } else {
449             exc\&.retval = HUGE_VAL;
450             y *= 0\&.5;
451             if(x<zero&&rint(y)!=y) exc\&.retval = -HUGE_VAL;
452         }
453         if (_LIB_VERSION == _POSIX_)
454             errno = ERANGE;
455         else if (!matherr(&exc)) {
456             errno = ERANGE;
457         }
458         break;
459     case 22:
460         /* pow(x,y) underflow */
461         exc\&.type = UNDERFLOW;
462         exc\&.name = "pow";
463         exc\&.retval =  zero;
464         if (_LIB_VERSION == _POSIX_)
465             errno = ERANGE;
466         else if (!matherr(&exc)) {
467             errno = ERANGE;
468         }
469         break;
470     case 23:
471         /* 0**neg */
472         exc\&.type = DOMAIN;
473         exc\&.name = "pow";
474         if (_LIB_VERSION == _SVID_)
475             exc\&.retval = zero;
476         else
477             exc\&.retval = -HUGE_VAL;
478         if (_LIB_VERSION == _POSIX_)
479             errno = EDOM;
480         else if (!matherr(&exc)) {
481             if (_LIB_VERSION == _SVID_) {
482                 (void) WRITE2("pow(0,neg): DOMAIN error\n", 25);
483             }
484             errno = EDOM;
485         }
486         break;
487     case 24:
488         /* neg**non-integral */
489         exc\&.type = DOMAIN;
490         exc\&.name = "pow";
491         if (_LIB_VERSION == _SVID_)
492             exc\&.retval = zero;
493         else
494             exc\&.retval = zero/zero;  /* X/Open allow NaN */
495         if (_LIB_VERSION == _POSIX_)
496             errno = EDOM;
497         else if (!matherr(&exc)) {
498             if (_LIB_VERSION == _SVID_) {
499                 (void) WRITE2("neg**non-integral: DOMAIN error\n", 32);
500             }
501             errno = EDOM;
502         }
503         break;
504     case 25:
505         /* sinh(finite) overflow */
506         exc\&.type = OVERFLOW;
507         exc\&.name = "sinh";
508         if (_LIB_VERSION == _SVID_)
509             exc\&.retval = ( (x>zero) ? HUGE : -HUGE);
510         else
511             exc\&.retval = ( (x>zero) ? HUGE_VAL : -HUGE_VAL);
512         if (_LIB_VERSION == _POSIX_)
513             errno = ERANGE;
514         else if (!matherr(&exc)) {
515             errno = ERANGE;
516         }
517         break;
518     case 26:
519         /* sqrt(x<0) */
520         exc\&.type = DOMAIN;
521         exc\&.name = "sqrt";
522         if (_LIB_VERSION == _SVID_)
523             exc\&.retval = zero;
524         else
525             exc\&.retval = zero/zero;
526         if (_LIB_VERSION == _POSIX_)
527             errno = EDOM;
528         else if (!matherr(&exc)) {
529             if (_LIB_VERSION == _SVID_) {
530                 (void) WRITE2("sqrt: DOMAIN error\n", 19);
531             }
532             errno = EDOM;
533         }
534         break;
535     case 27:
536         /* fmod(x,0) */
537         exc\&.type = DOMAIN;
538         exc\&.name = "fmod";
539         if (_LIB_VERSION == _SVID_)
540             exc\&.retval = x;
541         else
542             exc\&.retval = zero/zero;
543         if (_LIB_VERSION == _POSIX_)
544             errno = EDOM;
545         else if (!matherr(&exc)) {
546             if (_LIB_VERSION == _SVID_) {
547                 (void) WRITE2("fmod:  DOMAIN error\n", 20);
548             }
549             errno = EDOM;
550         }
551         break;
552     case 28:
553         /* remainder(x,0) */
554         exc\&.type = DOMAIN;
555         exc\&.name = "remainder";
556         exc\&.retval = zero/zero;
557         if (_LIB_VERSION == _POSIX_)
558             errno = EDOM;
559         else if (!matherr(&exc)) {
560             if (_LIB_VERSION == _SVID_) {
561                 (void) WRITE2("remainder: DOMAIN error\n", 24);
562             }
563             errno = EDOM;
564         }
565         break;
566     case 29:
567         /* acosh(x<1) */
568         exc\&.type = DOMAIN;
569         exc\&.name = "acosh";
570         exc\&.retval = zero/zero;
571         if (_LIB_VERSION == _POSIX_)
572             errno = EDOM;
573         else if (!matherr(&exc)) {
574             if (_LIB_VERSION == _SVID_) {
575                 (void) WRITE2("acosh: DOMAIN error\n", 20);
576             }
577             errno = EDOM;
578         }
579         break;
580     case 30:
581         /* atanh(|x|>1) */
582         exc\&.type = DOMAIN;
583         exc\&.name = "atanh";
584         exc\&.retval = zero/zero;
585         if (_LIB_VERSION == _POSIX_)
586             errno = EDOM;
587         else if (!matherr(&exc)) {
588             if (_LIB_VERSION == _SVID_) {
589                 (void) WRITE2("atanh: DOMAIN error\n", 20);
590             }
591             errno = EDOM;
592         }
593         break;
594     case 31:
595         /* atanh(|x|=1) */
596         exc\&.type = SING;
597         exc\&.name = "atanh";
598         exc\&.retval = x/zero; /* sign(x)*inf */
599         if (_LIB_VERSION == _POSIX_)
600             errno = EDOM;
601         else if (!matherr(&exc)) {
602             if (_LIB_VERSION == _SVID_) {
603                 (void) WRITE2("atanh: SING error\n", 18);
604             }
605             errno = EDOM;
606         }
607         break;
608     case 32:
609         /* scalb overflow; SVID also returns +-HUGE_VAL */
610         exc\&.type = OVERFLOW;
611         exc\&.name = "scalb";
612         exc\&.retval = x > zero ? HUGE_VAL : -HUGE_VAL;
613         if (_LIB_VERSION == _POSIX_)
614             errno = ERANGE;
615         else if (!matherr(&exc)) {
616             errno = ERANGE;
617         }
618         break;
619     case 33:
620         /* scalb underflow */
621         exc\&.type = UNDERFLOW;
622         exc\&.name = "scalb";
623         exc\&.retval = copysign(zero,x);
624         if (_LIB_VERSION == _POSIX_)
625             errno = ERANGE;
626         else if (!matherr(&exc)) {
627             errno = ERANGE;
628         }
629         break;
630     case 34:
631         /* j0(|x|>X_TLOSS) */
632         exc\&.type = TLOSS;
633         exc\&.name = "j0";
634         exc\&.retval = zero;
635         if (_LIB_VERSION == _POSIX_)
636             errno = ERANGE;
637         else if (!matherr(&exc)) {
638             if (_LIB_VERSION == _SVID_) {
639                 (void) WRITE2(exc\&.name, 2);
640                 (void) WRITE2(": TLOSS error\n", 14);
641             }
642             errno = ERANGE;
643         }
644         break;
645     case 35:
646         /* y0(x>X_TLOSS) */
647         exc\&.type = TLOSS;
648         exc\&.name = "y0";
649         exc\&.retval = zero;
650         if (_LIB_VERSION == _POSIX_)
651             errno = ERANGE;
652         else if (!matherr(&exc)) {
653             if (_LIB_VERSION == _SVID_) {
654                 (void) WRITE2(exc\&.name, 2);
655                 (void) WRITE2(": TLOSS error\n", 14);
656             }
657             errno = ERANGE;
658         }
659         break;
660     case 36:
661         /* j1(|x|>X_TLOSS) */
662         exc\&.type = TLOSS;
663         exc\&.name = "j1";
664         exc\&.retval = zero;
665         if (_LIB_VERSION == _POSIX_)
666             errno = ERANGE;
667         else if (!matherr(&exc)) {
668             if (_LIB_VERSION == _SVID_) {
669                 (void) WRITE2(exc\&.name, 2);
670                 (void) WRITE2(": TLOSS error\n", 14);
671             }
672             errno = ERANGE;
673         }
674         break;
675     case 37:
676         /* y1(x>X_TLOSS) */
677         exc\&.type = TLOSS;
678         exc\&.name = "y1";
679         exc\&.retval = zero;
680         if (_LIB_VERSION == _POSIX_)
681             errno = ERANGE;
682         else if (!matherr(&exc)) {
683             if (_LIB_VERSION == _SVID_) {
684                 (void) WRITE2(exc\&.name, 2);
685                 (void) WRITE2(": TLOSS error\n", 14);
686             }
687             errno = ERANGE;
688         }
689         break;
690     case 38:
691         /* jn(|x|>X_TLOSS) */
692         exc\&.type = TLOSS;
693         exc\&.name = "jn";
694         exc\&.retval = zero;
695         if (_LIB_VERSION == _POSIX_)
696             errno = ERANGE;
697         else if (!matherr(&exc)) {
698             if (_LIB_VERSION == _SVID_) {
699                 (void) WRITE2(exc\&.name, 2);
700                 (void) WRITE2(": TLOSS error\n", 14);
701             }
702             errno = ERANGE;
703         }
704         break;
705     case 39:
706         /* yn(x>X_TLOSS) */
707         exc\&.type = TLOSS;
708         exc\&.name = "yn";
709         exc\&.retval = zero;
710         if (_LIB_VERSION == _POSIX_)
711             errno = ERANGE;
712         else if (!matherr(&exc)) {
713             if (_LIB_VERSION == _SVID_) {
714                 (void) WRITE2(exc\&.name, 2);
715                 (void) WRITE2(": TLOSS error\n", 14);
716             }
717             errno = ERANGE;
718         }
719         break;
720     case 40:
721         /* gamma(finite) overflow */
722         exc\&.type = OVERFLOW;
723         exc\&.name = "gamma";
724         if (_LIB_VERSION == _SVID_)
725             exc\&.retval = HUGE;
726         else
727             exc\&.retval = HUGE_VAL;
728         if (_LIB_VERSION == _POSIX_)
729             errno = ERANGE;
730         else if (!matherr(&exc)) {
731             errno = ERANGE;
732         }
733         break;
734     case 41:
735         /* gamma(-integer) or gamma(0) */
736         exc\&.type = SING;
737         exc\&.name = "gamma";
738         if (_LIB_VERSION == _SVID_)
739             exc\&.retval = HUGE;
740         else
741             exc\&.retval = HUGE_VAL;
742         if (_LIB_VERSION == _POSIX_)
743             errno = EDOM;
744         else if (!matherr(&exc)) {
745             if (_LIB_VERSION == _SVID_) {
746                 (void) WRITE2("gamma: SING error\n", 18);
747             }
748             errno = EDOM;
749         }
750         break;
751     case 42:
752         /* pow(NaN,0\&.0) */
753         /* error only if _LIB_VERSION == _SVID_ & _XOPEN_ */
754         exc\&.type = DOMAIN;
755         exc\&.name = "pow";
756         exc\&.retval = x;
757         if (_LIB_VERSION == _IEEE_ ||
758                 _LIB_VERSION == _POSIX_) exc\&.retval = 1\&.0;
759         else if (!matherr(&exc)) {
760             errno = EDOM;
761         }
762         break;
763     }
764     return exc\&.retval;
765 }
.fi
.SH "Variable Documentation"
.PP 
.SS "double zero = 0\&.0\fC [static]\fP"

.PP
Definition at line 58 of file kstandard\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
