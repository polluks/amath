.TH "Parser" 3 "Thu Jan 19 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Parser \- Encapsulates a recursive descent parser\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <parser\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBParser\fP (const char *input)"
.br
.ti -1c
.RI "\fB~Parser\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParse\fP ()"
.br
.RI "\fIParses the input into a syntax tree\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseDefault\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBTryParseStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseEvaluation\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseExpression\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseAddSubstract\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseFactor\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParsePower\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseUnary\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseAtomic\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseIdent\fP ()"
.br
.ti -1c
.RI "\fBExpressionNode\fP * \fBParseNumber\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseFunctionDef\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseHelpStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseDeleteStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseListStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseFileStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseNumeralStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseDigistStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParseDrawStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParsePromptStatement\fP ()"
.br
.ti -1c
.RI "\fBSyntaxNode\fP * \fBParsePrefsStatement\fP ()"
.br
.ti -1c
.RI "void \fBGetToken\fP ()"
.br
.ti -1c
.RI "void \fBPutToken\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBExpect\fP (\fBSymbol\fP symbol)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBLexer\fP * \fBlexer\fP"
.br
.ti -1c
.RI "\fBToken\fP * \fBtoken\fP"
.br
.ti -1c
.RI "int \fBsyntaxError\fP"
.br
.ti -1c
.RI "\fBErrorNode\fP * \fBerrorNode\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Encapsulates a recursive descent parser\&. 

More info on recursive descent parsers is available at Wikipedia: http://en.wikipedia.org/wiki/Recursive_descent_parser 
.PP
Definition at line 49 of file parser\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Parser::Parser (const char * input)"

.PP
Definition at line 39 of file parser\&.cpp\&.
.PP
References Lexer::Lexer(), and lexer\&.
.PP
Referenced by Evaluator::Evaluate(), LoadStatement::Execute(), ExecuteStatement::Execute(), and PreferencesBase::SetPrefs()\&.
.PP
.nf
40 {
41     lexer = new Lexer(input);
42 }
.fi
.SS "Parser::~Parser ()"

.PP
Definition at line 44 of file parser\&.cpp\&.
.PP
References lexer\&.
.PP
.nf
45 {
46     delete lexer;
47 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBbool\fP Parser::Expect (\fBSymbol\fP symbol)\fC [private]\fP"

.PP
Definition at line 411 of file parser\&.cpp\&.
.PP
References Token::GetPos(), GetToken(), Token::symbol, syntaxError, and token\&.
.PP
Referenced by ParseAtomic(), ParseDefault(), ParseDeleteStatement(), ParseDrawStatement(), ParseFileStatement(), ParseFunctionDef(), and ParseIdent()\&.
.PP
.nf
412 {
413     GetToken();
414     if (token->symbol != symbol) {
415         syntaxError = token->GetPos();
416         return false;
417     } else {
418         return true;
419     }
420 }
.fi
.SS "void Parser::GetToken ()\fC [private]\fP"

.PP
Definition at line 401 of file parser\&.cpp\&.
.PP
References Lexer::GetFirstToken(), Token::GetNextToken(), lexer, and token\&.
.PP
Referenced by Expect(), Parse(), ParseAddSubstract(), ParseAtomic(), ParseDeleteStatement(), ParseDigistStatement(), ParseFactor(), ParseHelpStatement(), ParseIdent(), ParseListStatement(), ParseNumber(), ParseNumeralStatement(), ParsePower(), ParsePrefsStatement(), ParsePromptStatement(), ParseStatement(), ParseUnary(), and TryParseStatement()\&.
.PP
.nf
402 {
403     token = (token == NOMEM ? lexer->GetFirstToken() : token->GetNextToken());
404 }
.fi
.SS "\fBSyntaxNode\fP * Parser::Parse ()"

.PP
Parses the input into a syntax tree\&. 
.PP
\fBReturns:\fP
.RS 4
SyntaxNode* representing a pointer to the top node of the tree\&. Notice: The caller is responsible for releasing memory\&. 
.RE
.PP

.PP
Definition at line 49 of file parser\&.cpp\&.
.PP
References StatementBlockNode::Add(), EmptyStatement::EmptyStatement(), ErrorNode::ErrorNode(), Lexer::GetInput(), Token::GetPos(), GetToken(), lexer, PutToken(), StatementBlockNode::StatementBlockNode(), Token::symbol, symdelimiter, symend, token, Lexer::Tokenize(), and TryParseStatement()\&.
.PP
Referenced by Evaluator::Evaluate(), LoadStatement::Execute(), ExecuteStatement::Execute(), and PreferencesBase::SetPrefs()\&.
.PP
.nf
50 {
51     lexer->Tokenize();
52     token = NOMEM;
53 
54     StatementBlockNode *block = NOMEM;
55     SyntaxNode *result;
56     Token *current;
57 
58     do {
59         result = TryParseStatement();
60 
61         GetToken();
62         if (token->symbol == symdelimiter || (token->symbol == symend && block != NOMEM)) {
63             if (block == NOMEM) {
64                 block = new StatementBlockNode();
65             }
66 
67             if (result != NOMEM) {
68                 block->Add(result);
69             }
70 
71             while (token->symbol == symdelimiter) {
72                 GetToken();
73             }
74         } else if (token->symbol != symend) {
75             if (result != NOMEM) {
76                 delete result;
77             }
78 
79             result = new ErrorNode(lexer->GetInput(), token->GetPos());
80             if (block != NOMEM) {
81                 block->Add(result);
82             }
83 
84             GetToken();
85         }
86 
87         current = token;
88         PutToken();
89     } while (current->symbol != symend);
90 
91     return block != NOMEM ? block :
92            result != NOMEM ? result : new EmptyStatement();;
93 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseAddSubstract ()\fC [private]\fP"

.PP
Definition at line 237 of file parser\&.cpp\&.
.PP
References AdditionNode::AdditionNode(), GetToken(), ParseFactor(), PutToken(), SubtractionNode::SubtractionNode(), Token::symbol, symminus, symplus, and token\&.
.PP
Referenced by ParseExpression()\&.
.PP
.nf
238 {
239     ExpressionNode* node = ParseFactor ();
240 
241     GetToken();
242     while (token->symbol == symplus || token->symbol == symminus) {
243         if (token->symbol == symplus) {
244             node = new AdditionNode (node, ParseFactor ());
245         } else if (token->symbol == symminus) {
246             node = new SubtractionNode (node, ParseFactor ());
247         }
248 
249         GetToken();
250     }
251 
252     PutToken();
253     return node;
254 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseAtomic ()\fC [private]\fP"

.PP
Definition at line 304 of file parser\&.cpp\&.
.PP
References AbsoluteNode::AbsoluteNode(), ComplexiNode::ComplexiNode(), EulersNumberNode::EulersNumberNode(), Expect(), Token::GetPos(), GetToken(), InsVariableNode::InsVariableNode(), NumericValueNode::NumericValueNode(), ParseExpression(), ParseIdent(), ParseNumber(), PiNode::PiNode(), symabsolute, Token::symbol, syme, symi, symident, symins, symlparen, symnumber, sympi, symrparen, syntaxError, and token\&.
.PP
Referenced by ParseUnary()\&.
.PP
.nf
305 {
306     ExpressionNode* node;
307 
308     GetToken();
309     if (token->symbol == symlparen) {
310         node = ParseExpression();
311         Expect(symrparen);
312     } else if (token->symbol == symabsolute) {
313         node = new AbsoluteNode(ParseExpression());
314         Expect(symabsolute);
315     } else if (token->symbol == symident) {
316         node = ParseIdent();
317     } else if (token->symbol == sympi) {
318         node = new PiNode();
319     } else if (token->symbol == syme) {
320         node = new EulersNumberNode();
321     } else if (token->symbol == symi) {
322         node = new ComplexiNode();
323     } else if (token->symbol == symins) {
324         node = new InsVariableNode();
325     } else if (token->symbol == symnumber) {
326         node = ParseNumber();
327     } else {
328         node = new NumericValueNode();
329         syntaxError = token->GetPos();
330     }
331 
332     return node;
333 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseDefault ()\fC [private]\fP"

.PP
Definition at line 194 of file parser\&.cpp\&.
.PP
References errorNode, Expect(), ParseEvaluation(), ParseFunctionDef(), symassign, symident, symlparen, symrparen, syntaxError, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
195 {
196     Token *temp = token;
197 
198     // Peek tokens
199     bool funcdef = Expect(symident);
200     funcdef = funcdef && Expect(symlparen);
201     funcdef = funcdef && Expect(symident);
202     funcdef = funcdef && Expect(symrparen);
203     funcdef = funcdef && Expect(symassign);
204 
205     // Restart parsing
206     syntaxError = -1;
207     errorNode = NOMEM;
208     token = temp;
209 
210     if (funcdef) {
211         return ParseFunctionDef();
212     } else {
213         return ParseEvaluation();
214     }
215 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseDeleteStatement ()\fC [private]\fP"

.PP
Definition at line 470 of file parser\&.cpp\&.
.PP
References DeleteStatement::DeleteStatement(), Expect(), Token::GetPos(), Token::GetText(), GetToken(), PutToken(), Token::symbol, symfunction, symident, symlparen, symrparen, symvariable, syntaxError, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
471 {
472     GetToken();
473     if (token->symbol == symvariable || token->symbol == symfunction) {
474         return new DeleteStatement(token->symbol);
475     } else if (token->symbol != symident) {
476         syntaxError = token->GetPos();
477         return NOMEM;
478     }
479 
480     Token *identToken = token;
481 
482     GetToken();
483     if (token->symbol == symlparen) {
484         Expect(symident);
485         Token *parameter = token;
486         Expect(symrparen);
487         return new DeleteStatement(identToken->GetText(), parameter->GetText());
488     } else {
489         PutToken();
490         return new DeleteStatement(token->GetText());
491     }
492 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseDigistStatement ()\fC [private]\fP"

.PP
Definition at line 588 of file parser\&.cpp\&.
.PP
References DecimalSystem::DecimalSystem(), DigitsStatement::DigitsStatement(), errorNode, ErrorNode::ErrorNode(), Lexer::GetInput(), Number::GetIntegerValue(), Token::GetPos(), Token::GetText(), GetToken(), lexer, NumeralSystem::Parse(), PutToken(), Token::symbol, symdelimiter, symend, symnumber, syntaxError, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
589 {
590     GetToken();
591     if (token->symbol == symdelimiter || token->symbol == symend) {
592         PutToken();
593         return new DigitsStatement();
594     } else if (token->symbol != symnumber) {
595         syntaxError = token->GetPos();
596         return NOMEM;
597     }
598 
599     NumeralSystem *nsys = new DecimalSystem(0);
600     Number *number = nsys->Parse(token->GetText());
601     int digits = number->GetIntegerValue();
602     delete number;
603     delete nsys;
604 
605     if (digits < 0 || digits > 15) {
606         errorNode = new ErrorNode(
607             lexer->GetInput(),
608             HELPPDIGITS,
609             token->GetText(),
610             token->GetPos());
611 
612         return NOMEM;
613     }
614 
615     return new DigitsStatement(digits);
616 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseDrawStatement ()\fC [private]\fP"

.PP
Definition at line 640 of file parser\&.cpp\&.
.PP
References DrawStatement::DrawStatement(), Expect(), Token::GetText(), PlotStatement::PlotStatement(), Token::symbol, symident, symlparen, symplot, symrparen, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
641 {
642     Token *statement = token;
643 
644     Expect(symident);
645     Token *identToken = token;
646     Expect(symlparen);
647     Expect(symident);
648     Token *paramToken = token;
649     Expect(symrparen);
650 
651     if (statement->symbol == symplot) {
652         return new PlotStatement(identToken->GetText(), paramToken->GetText());
653     } else {
654         return new DrawStatement(identToken->GetText(), paramToken->GetText());
655     }
656 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseEvaluation ()\fC [private]\fP"

.PP
Definition at line 217 of file parser\&.cpp\&.
.PP
References EvalStatement::EvalStatement(), ExpressionNode::IsSilent(), ParseExpression(), and SilentStatement::SilentStatement()\&.
.PP
Referenced by ParseDefault()\&.
.PP
.nf
218 {
219     ExpressionNode *exp = ParseExpression();
220     if (exp == NOMEM) {
221         return NOMEM;
222     }
223 
224     StatementNode *sta = new EvalStatement(exp);
225     if (exp->IsSilent()) {
226         sta = new SilentStatement(sta);
227     }
228 
229     return sta;
230 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseExpression ()\fC [private]\fP"

.PP
Definition at line 232 of file parser\&.cpp\&.
.PP
References ParseAddSubstract()\&.
.PP
Referenced by ParseAtomic(), ParseEvaluation(), ParseFunctionDef(), ParseIdent(), and ParseStatement()\&.
.PP
.nf
233 {
234     return ParseAddSubstract();
235 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseFactor ()\fC [private]\fP"

.PP
Definition at line 256 of file parser\&.cpp\&.
.PP
References DivisionNode::DivisionNode(), GetToken(), MultiplicationNode::MultiplicationNode(), ParsePower(), PutToken(), Token::symbol, symslash, symtimes, and token\&.
.PP
Referenced by ParseAddSubstract()\&.
.PP
.nf
257 {
258     ExpressionNode* node = ParsePower ();
259 
260     GetToken();
261     while (token->symbol == symtimes || token->symbol == symslash) {
262         if (token->symbol == symtimes) {
263             node = new MultiplicationNode (node, ParsePower ());
264         } else if (token->symbol == symslash) {
265             node = new DivisionNode (node, ParsePower ());
266         }
267 
268         GetToken();
269     }
270 
271     PutToken();
272     return node;
273 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseFileStatement ()\fC [private]\fP"

.PP
Definition at line 508 of file parser\&.cpp\&.
.PP
References ErrorNode::ErrorNode(), ExecuteStatement::ExecuteStatement(), Expect(), Lexer::GetInput(), Token::GetPos(), Token::GetText(), lexer, LoadStatement::LoadStatement(), SaveStatement::SaveStatement(), ShowStatement::ShowStatement(), Token::symbol, symexecute, symload, symqident, symsave, symshow, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
509 {
510     Token *statement = token;
511 
512     Expect(symqident);
513     Token *identToken = token;
514 
515     if (statement->symbol == symload) {
516         return new LoadStatement(identToken->GetText());
517     } else if (statement->symbol == symsave) {
518         return new SaveStatement(identToken->GetText());
519     } else if (statement->symbol == symexecute) {
520         return new ExecuteStatement(identToken->GetText());
521     } else if (statement->symbol == symshow) {
522         return new ShowStatement(identToken->GetText());
523     } else {
524         return new ErrorNode(
525                    lexer->GetInput(),
526                    HELPUERROR, EMPTYSTRING,
527                    statement->GetPos());
528     }
529 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseFunctionDef ()\fC [private]\fP"

.PP
Definition at line 426 of file parser\&.cpp\&.
.PP
References UserFunction::CreateVariable(), errorNode, ErrorNode::ErrorNode(), Expect(), FunctionDefinitionNode::FunctionDefinitionNode(), Program::Functions, FunctionList::GetFunctionDef(), Lexer::GetInput(), Token::GetPos(), Token::GetText(), VariableList::InsertTemporaryVariable(), FunctionList::IsSystemFunction(), lexer, ParseExpression(), VariableList::RemoveTemporaryVariable(), UserFunction::SetExpression(), symassign, symident, symlparen, symrparen, token, and Program::Variables\&.
.PP
Referenced by ParseDefault(), and ParseStatement()\&.
.PP
.nf
427 {
428     Expect(symident);
429     Token* funcToken = token;
430     Expect(symlparen);
431     Expect(symident);
432     Token* funcVariable = token;
433     Expect(symrparen);
434     Expect(symassign);
435 
436     if (Program->Functions->IsSystemFunction(funcToken->GetText())) {
437         errorNode = new ErrorNode(
438             lexer->GetInput(),
439             HELPFUNRDEF,
440             funcToken->GetText(),
441             funcToken->GetPos());
442 
443         return NOMEM;
444     }
445 
446     UserFunction* function = Program->Functions->GetFunctionDef(funcToken->GetText());
447     Variable* variable = function->CreateVariable(funcVariable->GetText());
448     Program->Variables->InsertTemporaryVariable(variable);
449     function->SetExpression(ParseExpression());
450     Program->Variables->RemoveTemporaryVariable();
451 
452     // TODO: Move logic to FunctionDefinitionNode
453     return new FunctionDefinitionNode();
454 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseHelpStatement ()\fC [private]\fP"

.PP
Definition at line 456 of file parser\&.cpp\&.
.PP
References Token::GetText(), GetToken(), HelpStatement::HelpStatement(), PutToken(), Token::symbol, symdelimiter, symend, symident, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
457 {
458     GetToken();
459 
460     if (token->symbol == symdelimiter || token->symbol == symend) {
461         PutToken();
462         return new HelpStatement();
463     } else if (token->symbol == symident) {
464         return new HelpStatement(token->GetText());
465     } else {
466         return new HelpStatement(token->symbol);
467     }
468 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseIdent ()\fC [private]\fP"

.PP
Definition at line 335 of file parser\&.cpp\&.
.PP
References AssignmentNode::AssignmentNode(), VariableList::CreateVariable(), errorNode, ErrorNode::ErrorNode(), Expect(), Program::Functions, FunctionList::GetFunctionCall(), Lexer::GetInput(), Token::GetPos(), Token::GetText(), GetToken(), VariableList::GetVariable(), lexer, NumericValueNode::NumericValueNode(), ParseExpression(), PutToken(), symassign, Token::symbol, symlparen, symrparen, token, VariableNode::VariableNode(), and Program::Variables\&.
.PP
Referenced by ParseAtomic()\&.
.PP
.nf
336 {
337     ExpressionNode *node;
338     Token *identToken = token;
339 
340     GetToken();
341     if (token->symbol == symlparen) {
342         ExpressionNode* parameter = ParseExpression();
343         Expect(symrparen);
344         node = Program->Functions->GetFunctionCall(identToken->GetText(), parameter);
345 
346         if (node == NOMEM) {
347             errorNode = new ErrorNode(
348                 lexer->GetInput(),
349                 HELPFUNNDEF,
350                 identToken->GetText(),
351                 identToken->GetPos());
352 
353             delete parameter;
354             node = new NumericValueNode();
355         }
356     } else if (token->symbol == symassign) {
357         Variable* var = Program->Variables->CreateVariable(identToken->GetText());
358         node = new AssignmentNode(new VariableNode(var), ParseExpression());
359     } else {
360         PutToken();
361         Variable* var = Program->Variables->GetVariable(token->GetText());
362 
363         if (var == NOMEM) {
364             errorNode = new ErrorNode(
365                 lexer->GetInput(),
366                 HELPVARNDEF,
367                 identToken->GetText(),
368                 identToken->GetPos());
369 
370             node = new NumericValueNode();
371         } else {
372             node = new VariableNode(var);
373         }
374     }
375 
376     return node;
377 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseListStatement ()\fC [private]\fP"

.PP
Definition at line 494 of file parser\&.cpp\&.
.PP
References Token::GetPos(), Token::GetText(), GetToken(), ListStatement::ListStatement(), PutToken(), Token::symbol, symdelimiter, symend, symqident, syntaxError, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
495 {
496     GetToken();
497     if (token->symbol == symqident)
498         return new ListStatement(token->GetText());
499     else if (token->symbol == symend || symdelimiter) {
500         PutToken();
501         return new ListStatement();
502     } else {
503         syntaxError = token->GetPos();
504         return NOMEM;
505     }
506 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseNumber ()\fC [private]\fP"

.PP
Definition at line 379 of file parser\&.cpp\&.
.PP
References ComplexNumber::ComplexNumber(), Number::GetRealValue(), Token::GetText(), GetToken(), Program::Input, NumericValueNode::NumericValueNode(), NumeralSystem::Parse(), PutToken(), Token::symbol, symi, and token\&.
.PP
Referenced by ParseAtomic()\&.
.PP
.nf
380 {
381     const char *a = token->GetText();
382     Number *number = NOMEM;
383 
384     GetToken();
385     if (token->symbol == symi) {
386         Number *imag = Program->Input->Parse(a);
387         number = new ComplexNumber(0\&.0, imag->GetRealValue());
388         delete imag;
389     } else {
390         PutToken();
391         number = Program->Input->Parse(a);
392     }
393 
394     return new NumericValueNode (number);
395 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseNumeralStatement ()\fC [private]\fP"

.PP
Definition at line 531 of file parser\&.cpp\&.
.PP
References DecimalSystem::DecimalSystem(), errorNode, ErrorNode::ErrorNode(), Lexer::GetInput(), Number::GetIntegerValue(), Token::GetPos(), Token::GetText(), GetToken(), InputStatement::InputStatement(), lexer, OutputStatement::OutputStatement(), NumeralSystem::Parse(), PutToken(), symbin, Token::symbol, symdec, symdelimiter, symend, symhex, syminput, symnumber, symoct, syntaxError, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
532 {
533     Token *statement = token;
534     unsigned int base;
535 
536     GetToken();
537     switch (token->symbol) {
538     case symend:
539     case symdelimiter:
540         PutToken();
541         return (statement->symbol == syminput) ?
542                (SyntaxNode*)new InputStatement() :
543                (SyntaxNode*)new OutputStatement();
544     case symbin:
545         base = 2;
546         break;
547     case symoct:
548         base = 8;
549         break;
550     case symdec:
551         base = 10;
552         break;
553     case symhex:
554         base = 16;
555         break;
556     default:
557         base = 0;
558     }
559 
560     if (base == 0 && token->symbol != symnumber) {
561         syntaxError = token->GetPos();
562         return NOMEM;
563     }
564 
565     if (base == 0) {
566         NumeralSystem *nsys = new DecimalSystem(0);
567         Number *number = nsys->Parse(token->GetText());
568         base = number->GetIntegerValue();
569         delete number;
570         delete nsys;
571 
572         if (base < 2 || base > 32) {
573             errorNode = new ErrorNode(
574                 lexer->GetInput(),
575                 HELPPNUMERA,
576                 token->GetText(),
577                 token->GetPos());
578 
579             return NOMEM;
580         }
581     }
582 
583     return (statement->symbol == syminput) ?
584            (SyntaxNode*)new InputStatement(base) :
585            (SyntaxNode*)new OutputStatement(base);
586 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParsePower ()\fC [private]\fP"

.PP
Definition at line 275 of file parser\&.cpp\&.
.PP
References GetToken(), ParseUnary(), PowerNode::PowerNode(), PutToken(), Token::symbol, sympower, and token\&.
.PP
Referenced by ParseFactor()\&.
.PP
.nf
276 {
277     ExpressionNode* node = ParseUnary ();
278 
279     GetToken();
280     while (token->symbol == sympower) {
281         node = new PowerNode (node, ParseUnary ());
282         GetToken ();
283     }
284 
285     PutToken();
286     return node;
287 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParsePrefsStatement ()\fC [private]\fP"

.PP
Definition at line 629 of file parser\&.cpp\&.
.PP
References GetToken(), PrefsStatement::PrefsStatement(), PutToken(), Token::symbol, symload, symsave, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
630 {
631     GetToken();
632     if (token->symbol == symload || token->symbol == symsave) {
633         return new PrefsStatement(token->symbol);
634     }
635 
636     PutToken();
637     return new PrefsStatement();;
638 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParsePromptStatement ()\fC [private]\fP"

.PP
Definition at line 618 of file parser\&.cpp\&.
.PP
References Token::GetText(), GetToken(), PromptStatement::PromptStatement(), PutToken(), Token::symbol, symqident, and token\&.
.PP
Referenced by ParseStatement()\&.
.PP
.nf
619 {
620     GetToken();
621     if (token->symbol == symqident) {
622         return new PromptStatement(token->GetText());
623     }
624 
625     PutToken();
626     return NOMEM;
627 }
.fi
.SS "\fBSyntaxNode\fP * Parser::ParseStatement ()\fC [private]\fP"

.PP
Definition at line 124 of file parser\&.cpp\&.
.PP
References ClearStatement::ClearStatement(), EvalStatement::EvalStatement(), ExitStatement::ExitStatement(), GetToken(), ListFunctionsStatement::ListFunctionsStatement(), ListVariablesStatement::ListVariablesStatement(), MemoryStatement::MemoryStatement(), ParseDefault(), ParseDeleteStatement(), ParseDigistStatement(), ParseDrawStatement(), ParseExpression(), ParseFileStatement(), ParseFunctionDef(), ParseHelpStatement(), ParseListStatement(), ParseNumeralStatement(), ParsePrefsStatement(), ParsePromptStatement(), PutToken(), Token::symbol, symclear, symdef, symdelete, symdigits, symdraw, symeval, symexecute, symexit, symfunction, symhelp, syminput, symlist, symload, symmem, symoutput, symplot, symprefs, symprompt, symsave, symshow, symvariable, symversion, token, and VersionStatement::VersionStatement()\&.
.PP
Referenced by TryParseStatement()\&.
.PP
.nf
125 {
126     SyntaxNode* res = NOMEM;
127 
128     GetToken();
129     switch (token->symbol) {
130     case symhelp:
131         res = ParseHelpStatement();
132         break;
133     case symdelete:
134         res = ParseDeleteStatement();
135         break;
136     case symdef:
137         res = ParseFunctionDef();
138         break;
139     case symlist:
140         res = ParseListStatement();
141         break;
142     case symshow:
143     case symload:
144     case symsave:
145     case symexecute:
146         res = ParseFileStatement();
147         break;
148     case syminput:
149     case symoutput:
150         res = ParseNumeralStatement();
151         break;
152     case symprompt:
153         res = ParsePromptStatement();
154         break;
155     case symprefs:
156         res = ParsePrefsStatement();
157         break;
158     case symdigits:
159         res = ParseDigistStatement();
160         break;
161     case symdraw:
162     case symplot:
163         res = ParseDrawStatement();
164         break;
165     case symversion:
166         res = new VersionStatement();
167         break;
168     case  symexit:
169         res = new ExitStatement();
170         break;
171     case symclear:
172         res =  new ClearStatement();
173         break;
174     case symmem:
175         res = new MemoryStatement();
176         break;
177     case  symvariable:
178         res = new ListVariablesStatement();
179         break;
180     case symfunction:
181         res = new ListFunctionsStatement();
182         break;
183     case symeval:
184         res = new EvalStatement(ParseExpression());
185         break;
186     default:
187         PutToken();
188         res = ParseDefault();
189     }
190 
191     return res;
192 }
.fi
.SS "\fBExpressionNode\fP * Parser::ParseUnary ()\fC [private]\fP"

.PP
Definition at line 289 of file parser\&.cpp\&.
.PP
References GetToken(), ParseAtomic(), PutToken(), Token::symbol, symminus, token, and UnaryNode::UnaryNode()\&.
.PP
Referenced by ParsePower()\&.
.PP
.nf
290 {
291     ExpressionNode* node;
292 
293     GetToken();
294     if (token->symbol == symminus) {
295         node = new UnaryNode(ParseAtomic ());
296     } else {
297         PutToken();
298         node = ParseAtomic();
299     }
300 
301     return node;
302 }
.fi
.SS "void Parser::PutToken ()\fC [private]\fP"

.PP
Definition at line 406 of file parser\&.cpp\&.
.PP
References Token::GetLastToken(), and token\&.
.PP
Referenced by Parse(), ParseAddSubstract(), ParseDeleteStatement(), ParseDigistStatement(), ParseFactor(), ParseHelpStatement(), ParseIdent(), ParseListStatement(), ParseNumber(), ParseNumeralStatement(), ParsePower(), ParsePrefsStatement(), ParsePromptStatement(), ParseStatement(), ParseUnary(), and TryParseStatement()\&.
.PP
.nf
407 {
408     token = token->GetLastToken();
409 }
.fi
.SS "\fBSyntaxNode\fP * Parser::TryParseStatement ()\fC [private]\fP"

.PP
Definition at line 95 of file parser\&.cpp\&.
.PP
References errorNode, ErrorNode::ErrorNode(), Lexer::GetInput(), GetToken(), lexer, ParseStatement(), PutToken(), Token::symbol, symdelimiter, symend, syntaxError, and token\&.
.PP
Referenced by Parse()\&.
.PP
.nf
96 {
97     GetToken();
98     if(token->symbol == symend || token->symbol == symdelimiter) {
99         PutToken();
100         return NOMEM;
101     }
102     PutToken();
103 
104     errorNode = NOMEM;
105     syntaxError = -1;
106     SyntaxNode *result = ParseStatement();
107 
108     if (errorNode == NOMEM && syntaxError != -1) {
109         errorNode = new ErrorNode(lexer->GetInput(), syntaxError);
110     }
111 
112     if (errorNode != NOMEM) {
113         delete result;
114         result = errorNode;
115     }
116 
117     return result;
118 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBErrorNode\fP* Parser::errorNode\fC [private]\fP"

.PP
Definition at line 68 of file parser\&.h\&.
.PP
Referenced by ParseDefault(), ParseDigistStatement(), ParseFunctionDef(), ParseIdent(), ParseNumeralStatement(), and TryParseStatement()\&.
.SS "\fBLexer\fP* Parser::lexer\fC [private]\fP"

.PP
Definition at line 64 of file parser\&.h\&.
.PP
Referenced by GetToken(), Parse(), ParseDigistStatement(), ParseFileStatement(), ParseFunctionDef(), ParseIdent(), ParseNumeralStatement(), Parser(), TryParseStatement(), and ~Parser()\&.
.SS "int Parser::syntaxError\fC [private]\fP"

.PP
Definition at line 67 of file parser\&.h\&.
.PP
Referenced by Expect(), ParseAtomic(), ParseDefault(), ParseDeleteStatement(), ParseDigistStatement(), ParseListStatement(), ParseNumeralStatement(), and TryParseStatement()\&.
.SS "\fBToken\fP* Parser::token\fC [private]\fP"

.PP
Definition at line 65 of file parser\&.h\&.
.PP
Referenced by Expect(), GetToken(), Parse(), ParseAddSubstract(), ParseAtomic(), ParseDefault(), ParseDeleteStatement(), ParseDigistStatement(), ParseDrawStatement(), ParseFactor(), ParseFileStatement(), ParseFunctionDef(), ParseHelpStatement(), ParseIdent(), ParseListStatement(), ParseNumber(), ParseNumeralStatement(), ParsePower(), ParsePrefsStatement(), ParsePromptStatement(), ParseStatement(), ParseUnary(), PutToken(), and TryParseStatement()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
