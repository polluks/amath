.TH "lib/real/log.c" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/log.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'prim\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlog\fP (double x)"
.br
.RI "\fINatural logarithm function (base e)\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const double \fBln2_hi\fP = 6\&.93147180369123816490e\-01"
.br
.ti -1c
.RI "static const double \fBln2_lo\fP = 1\&.90821492927058770002e\-10"
.br
.ti -1c
.RI "static const double \fBtwo54\fP = 1\&.80143985094819840000e+16"
.br
.ti -1c
.RI "static const double \fBLg1\fP = 6\&.666666666666735130e\-01"
.br
.ti -1c
.RI "static const double \fBLg2\fP = 3\&.999999999940941908e\-01"
.br
.ti -1c
.RI "static const double \fBLg3\fP = 2\&.857142874366239149e\-01"
.br
.ti -1c
.RI "static const double \fBLg4\fP = 2\&.222219843214978396e\-01"
.br
.ti -1c
.RI "static const double \fBLg5\fP = 1\&.818357216161805012e\-01"
.br
.ti -1c
.RI "static const double \fBLg6\fP = 1\&.531383769920937332e\-01"
.br
.ti -1c
.RI "static const double \fBLg7\fP = 1\&.479819860511658591e\-01"
.br
.ti -1c
.RI "static double \fBzero\fP = 0\&.0"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "double log (double x)"

.PP
Natural logarithm function (base e)\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.4 
.RE
.PP
\fBDate:\fP
.RS 4
96/03/07
.RE
.PP
.PP
.nf

Method :
  1\&. Argument Reduction: find k and f such that
        x = 2^k * (1+f),
    where  sqrt(2)/2 < 1+f < sqrt(2) \&.
.fi
.PP
.PP
.PP
.nf
  2\&. Approximation of log(1+f)\&.
 Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
     = 2s + 2/3 s**3 + 2/5 s**5 + \&.\&.\&.\&.\&.,
         = 2s + s*R
     We use a special Remes algorithm on [0,0\&.1716] to generate
    a polynomial of degree 14 to approximate R The maximum error
 of this polynomial approximation is bounded by 2**-58\&.45\&. In
 other words,
            2      4      6      8      10      12      14
     R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
    (the values of Lg1 to Lg7 are listed in the program)
 and
     |      2          14          |     -58\&.45
     | Lg1*s +\&.\&.\&.+Lg7*s    -  R(z) | <= 2
     |                             |
 Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2\&.
 In order to guarantee error in log below 1ulp, we compute log
 by
    log(1+f) = f - s*(f - R)    (if f is not too large)
    log(1+f) = f - (hfsq - s*(hfsq+R))\&. (better accuracy)
.fi
.PP
.PP
.PP
.nf
 3\&. Finally,  log(x) = k*ln2 + log(1+f)\&.
            = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
    Here ln2 is split into two floating point number:
        ln2_hi + ln2_lo,
    where n*ln2_hi is always exact for |n| < 2000\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 log(x) is NaN with signal if x < 0 (including -INF) ;
 log(+INF) is +INF; log(0) is -INF with signal;
 log(NaN) is that NaN with no signal\&.
.fi
.PP
.PP
.PP
.nf
Accuracy:
 according to an error analysis, the error is always less than
 1 ulp (unit in the last place)\&.
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 118 of file log\&.c\&.
.PP
References Lg1, Lg2, Lg3, Lg4, Lg5, Lg6, Lg7, ln2_hi, ln2_lo, two54, and zero\&.
.PP
.nf
119 {
120     double hfsq,f,s,z,R,w,t1,t2,dk;
121     sword k,hx,i,j;
122     uword lx;
123 
124     EXTRACT_WORDS(hx,lx,x);
125 
126     k=0;
127     if (hx < 0x00100000) {          /* x < 2**-1022  */
128         if (((hx&0x7fffffff)|lx)==0)
129             return -two54/zero;     /* log(+-0)=-inf */
130         if (hx<0) return (x-x)/zero;    /* log(-#) = NaN */
131         k -= 54;
132         x *= two54; /* subnormal number, scale up x */
133         GET_HIGH_WORD(hx,x);        /* high word of x */
134     }
135     if (hx >= 0x7ff00000) return x+x;
136     k += (hx>>20)-1023;
137     hx &= 0x000fffff;
138     i = (hx+0x95f64)&0x100000;
139     SET_HIGH_WORD(x,hx|(i^0x3ff00000)); /* normalize x or x/2 */
140     k += (i>>20);
141     f = x-1\&.0;
142     if((0x000fffff&(2+hx))<3) { /* |f| < 2**-20 */
143         if(f==zero) {
144             if(k==0)
145                 return zero;
146             else {
147                 dk=(double)k;
148                 return dk*ln2_hi+dk*ln2_lo;
149             }
150         }
151         R = f*f*(0\&.5-0\&.33333333333333333*f);
152         if(k==0) return f-R;
153         else {
154             dk=(double)k;
155             return dk*ln2_hi-((R-dk*ln2_lo)-f);
156         }
157     }
158     s = f/(2\&.0+f);
159     dk = (double)k;
160     z = s*s;
161     i = hx-0x6147a;
162     w = z*z;
163     j = 0x6b851-hx;
164     t1= w*(Lg2+w*(Lg4+w*Lg6));
165     t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
166     i |= j;
167     R = t2+t1;
168     if(i>0) {
169         hfsq=0\&.5*f*f;
170         if(k==0) return f-(hfsq-s*(hfsq+R));
171         else
172             return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
173     } else {
174         if(k==0) return f-s*(f-R);
175         else
176             return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
177     }
178 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const double Lg1 = 6\&.666666666666735130e\-01\fC [static]\fP"

.PP
Definition at line 49 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg2 = 3\&.999999999940941908e\-01\fC [static]\fP"

.PP
Definition at line 50 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg3 = 2\&.857142874366239149e\-01\fC [static]\fP"

.PP
Definition at line 51 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg4 = 2\&.222219843214978396e\-01\fC [static]\fP"

.PP
Definition at line 52 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg5 = 1\&.818357216161805012e\-01\fC [static]\fP"

.PP
Definition at line 53 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg6 = 1\&.531383769920937332e\-01\fC [static]\fP"

.PP
Definition at line 54 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double Lg7 = 1\&.479819860511658591e\-01\fC [static]\fP"

.PP
Definition at line 55 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double ln2_hi = 6\&.93147180369123816490e\-01\fC [static]\fP"

.PP
Definition at line 46 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double ln2_lo = 1\&.90821492927058770002e\-10\fC [static]\fP"

.PP
Definition at line 47 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "const double two54 = 1\&.80143985094819840000e+16\fC [static]\fP"

.PP
Definition at line 48 of file log\&.c\&.
.PP
Referenced by log()\&.
.SS "double zero = 0\&.0\fC [static]\fP"

.PP
Definition at line 57 of file log\&.c\&.
.PP
Referenced by log()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
