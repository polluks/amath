.TH "PositionalNumeralSystem" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
PositionalNumeralSystem \- Base class for all numeral systems with a positional notation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ntext\&.h>\fP
.PP
Inherits \fBNumeralSystem\fP\&.
.PP
Inherited by \fBDecimalSystem\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPositionalNumeralSystem\fP (unsigned int \fBbase\fP, unsigned int \fBdigits\fP, const char \fBfractionpoint\fP)"
.br
.ti -1c
.RI "\fB~PositionalNumeralSystem\fP ()"
.br
.ti -1c
.RI "virtual const char * \fBGetName\fP ()"
.br
.ti -1c
.RI "virtual const char * \fBGetPrefix\fP ()"
.br
.ti -1c
.RI "virtual unsigned int \fBGetDigits\fP ()"
.br
.ti -1c
.RI "virtual void \fBSetDigits\fP (unsigned int \fBdigits\fP)"
.br
.ti -1c
.RI "virtual const char \fBGetFractionPoint\fP ()"
.br
.ti -1c
.RI "virtual void \fBSetFractionPoint\fP (const char \fBfractionpoint\fP)"
.br
.ti -1c
.RI "virtual const char * \fBGetText\fP (\fBNumber\fP *number)"
.br
.ti -1c
.RI "virtual \fBNumber\fP * \fBParse\fP (const char *text, unsigned int *length, char **end)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "double \fBbase\fP"
.br
.ti -1c
.RI "unsigned int \fBdigits\fP"
.br
.ti -1c
.RI "char \fBfractionpoint\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "const char * \fBGetText\fP (double number)"
.br
.ti -1c
.RI "void \fBIntegerToBuffer\fP (double value, unsigned int \fBdigits\fP, int *outdigits)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Base class for all numeral systems with a positional notation\&. 

More info on positional notation is available at Wikipedia: http://en.wikipedia.org/wiki/Positional_notation 
.PP
Definition at line 74 of file ntext\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PositionalNumeralSystem::PositionalNumeralSystem (unsigned int base, unsigned int digits, const char fractionpoint)"

.PP
Definition at line 58 of file ntext\&.cpp\&.
.PP
References base, digits, and fractionpoint\&.
.PP
Referenced by DecimalSystem::DecimalSystem(), Program::NewPositionalInput(), and Program::NewPositionalOutput()\&.
.PP
.nf
61                               :
62     base(base * 1\&.0), digits(digits) {
63     this->fractionpoint = fractionpoint;
64 }
.fi
.SS "PositionalNumeralSystem::~PositionalNumeralSystem ()"

.PP
Definition at line 66 of file ntext\&.cpp\&.
.PP
.nf
67 { }
.fi
.SH "Member Function Documentation"
.PP 
.SS "unsigned int PositionalNumeralSystem::GetDigits ()\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 107 of file ntext\&.cpp\&.
.PP
References digits\&.
.PP
.nf
108 {
109     return digits;
110 }
.fi
.SS "const char PositionalNumeralSystem::GetFractionPoint ()\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 117 of file ntext\&.cpp\&.
.PP
References fractionpoint\&.
.PP
.nf
118 {
119     return (const char)this->fractionpoint;
120 }
.fi
.SS "const char * PositionalNumeralSystem::GetName ()\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 69 of file ntext\&.cpp\&.
.PP
References CharBuffer::Append(), base, NumeralSystem::buf, DecimalSystem::DecimalSystem(), CharBuffer::Empty(), CharBuffer::EnsureSize(), CharBuffer::GetString(), NumeralSystem::GetText(), RealNumber::RealNumber(), and StrLen()\&.
.PP
.nf
70 {
71     switch ((int)base) {
72     case 2:
73         return "binary";
74         break;
75     case 8:
76         return "octal";
77         break;
78     case 10:
79         return "decimal";
80         break;
81     case 16:
82         return "hexadecimal";
83         break;
84     }
85 
86     const char *text = "base ";
87     Number *n = new RealNumber(base);
88     NumeralSystem *ns = new DecimalSystem(2);
89     const char *numtext = ns->GetText(n);
90 
91     buf->EnsureSize(StrLen(text) + StrLen(numtext) + 1);
92     buf->Empty();
93     buf->Append(text);
94     buf->Append(numtext);
95 
96     delete ns;
97     delete n;
98     return buf->GetString();
99 }
.fi
.SS "const char * PositionalNumeralSystem::GetPrefix ()\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 101 of file ntext\&.cpp\&.
.PP
.nf
102 {
103     // TODO: Implement
104     return "";
105 }
.fi
.SS "const char * PositionalNumeralSystem::GetText (\fBNumber\fP * number)\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Reimplemented in \fBDecimalSystem\fP\&.
.PP
Definition at line 127 of file ntext\&.cpp\&.
.PP
References CharBuffer::Append(), NumeralSystem::buf, CharBuffer::CharBuffer(), cimag(), CharBuffer::Copy(), creal(), CharBuffer::Empty(), ComplexNumber::GetComplexValue(), Number::GetRealValue(), CharBuffer::GetString(), GetText(), nsysreal, and Number::system\&.
.PP
.nf
128 {
129     if (number->system == nsysreal) {
130         return GetText(number->GetRealValue());
131     }
132 
133     complex w = ((ComplexNumber*)number)->GetComplexValue();
134     double a = creal(w);
135     double b = cimag(w);
136 
137     if (a == 0\&.0 && b == 0\&.0) {
138         buf->Empty();
139         buf->Append('0');
140         return buf->GetString();
141     }
142 
143     CharBuffer *val = new CharBuffer(512);
144     val->Empty();
145 
146     if (a != 0\&.0) {
147         const char *real = GetText(a);
148         val->Append(real);
149     }
150 
151     const char *imag = GetText(b);
152     if (a != 0\&.0 && b > 0\&.0) {
153         val->Append('+');
154     }
155 
156     if (b != 0\&.0) {
157         val->Append(imag);
158         val->Append('i');
159     }
160 
161     buf->Copy(val);
162     delete val;
163 
164     return buf->GetString();
165 }
.fi
.SS "const char * PositionalNumeralSystem::GetText (double number)\fC [private]\fP"

.PP
Definition at line 167 of file ntext\&.cpp\&.
.PP
References CharBuffer::Append(), base, NumeralSystem::buf, digits, CharBuffer::Empty(), finite(), fractionpoint, CharBuffer::GetString(), IntegerToBuffer(), CharBuffer::Is(), isnan(), pow(), CharBuffer::RemoveTrailing(), round(), and trunc()\&.
.PP
Referenced by GetText()\&.
.PP
.nf
168 {
169     if (!finite(number)) {
170         return "Inf";
171     } else if (isnan(number)) {
172         return "NaN";
173     } else if (number == 0\&.0) {
174         return "0";
175     }
176 
177     buf->Empty();
178 
179     double dnumber = number;
180     if (dnumber < 0\&.0) {
181         buf->Append('-');
182         dnumber = -dnumber;
183     }
184 
185     double expborder = log2p(base, dnumber);
186     int exponent = 0;
187 
188     // Find exponent
189     if (expborder > 6\&.0 || expborder < -5\&.0) {
190         double dexp = trunc(log2p(base, dnumber));
191 
192         // Adjust to keep one digits before dot\&.
193         if (dexp < 0\&.0) {
194             dexp -= 1\&.0;
195         }
196 
197         dnumber = dnumber * pow(base, -dexp);
198         exponent = (int)dexp;
199     }
200 
201     int digitout;
202     int intdigits;
203 
204     // NOTICE: 1\&.5\&.3 Scaled trunc
205     int intvalue = (int)(trunc(dnumber * base) / base);
206     IntegerToBuffer(intvalue, digits, &intdigits);
207 
208     int fragdigits = digits - intdigits;
209     if (fragdigits > 0) {
210         buf->Append('\&.');
211 
212         // TODO: Fix fraction error (try 1\&.5439)
213         double fraction = fabs(round((dnumber - round(dnumber)) * pow(base, fragdigits)));
214 
215         // NOTICE: 1\&.5\&.3 Changed from trunc to round
216         double actualdigits = round(log2p(base, fraction));
217         int padding = fragdigits - (finite(actualdigits) == 1 ? (int)actualdigits : 0) - 1;
218 
219         // Pad zeros if needed
220         while (padding-- > 0) {
221             buf->Append('0');
222         }
223 
224         // NOTICE: 1\&.5\&.3 Scaled trunc
225         intvalue = (int)(trunc(fraction * base) / base);
226         IntegerToBuffer(intvalue, digits - intdigits, &digitout);
227 
228         // Remove trailing zeros
229         while (buf->RemoveTrailing('0'))
230             ;
231 
232         buf->RemoveTrailing(fractionpoint);
233     }
234 
235     // Add exponent
236     if (exponent != 0) {
237         buf->Append('e');
238         buf->Append(exponent > 0 ? '+' : '-');
239         IntegerToBuffer(abs(exponent), 3, &digitout);
240     }
241 
242     // Make sure no rounding error is returned
243     if (buf->Is("-0")) {
244         buf->Empty();
245         buf->Append('0');
246     }
247 
248     return buf->GetString();
249 }
.fi
.SS "void PositionalNumeralSystem::IntegerToBuffer (double value, unsigned int digits, int * outdigits)\fC [private]\fP"

.PP
Definition at line 251 of file ntext\&.cpp\&.
.PP
References CharBuffer::Append(), base, NumeralSystem::buf, and trunc()\&.
.PP
Referenced by GetText()\&.
.PP
.nf
252 {
253     static const char *alphaNumerics = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
254     unsigned int count = 0;
255     char *chars = new char[128]; // TODO: Find correct size
256     char *start = chars;
257 
258     do {
259         count++;
260         unsigned int intremainder = (unsigned int) trunc(fmod(value, base));
261         *chars++ = alphaNumerics[intremainder];
262         value /= base;
263     } while (value >= 1\&.0);
264 
265     unsigned int n = count;
266     unsigned int q = digits;
267     chars--;
268 
269     while (n-- != 0 && q-- != 0) {
270         buf->Append(*chars--);
271     }
272 
273     n++;
274     while (n-- != 0) {
275         buf->Append('0');
276     }
277 
278     *outdigits = count;
279     delete [] start;
280 }
.fi
.SS "\fBNumber\fP * PositionalNumeralSystem::Parse (const char * text, unsigned int * length, char ** end)\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 282 of file ntext\&.cpp\&.
.PP
References base, fractionpoint, pow(), and RealNumber::RealNumber()\&.
.PP
.nf
283 {
284     unsigned int intbase = (unsigned int)base;
285     char maxNumeric = (intbase > 10 ? 10 : intbase) + '0' - 1;
286     char maxAlpha = intbase > 10 ? intbase + 'A' - 11 : 0;
287 
288     unsigned int pos = 0;
289     double integer = 0;
290     double addition;
291 
292     while (*text != '\0' && ((*text >= '0' && *text <= maxNumeric) || (maxAlpha != 0 && *text >= 'A' && *text <= maxAlpha))) {
293         addition = ((*text >= '0' && *text <= maxNumeric) ? (*text - '0') : (*text - 'A' + 10)) * 1\&.0;
294         integer = integer * base + addition;
295         text++;
296         pos++;
297     }
298 
299     // Digits not found
300     if (pos == 0) {
301         *length = 0;
302         *end = (char*)text;
303         return new RealNumber();
304     }
305 
306     double fraction = 0\&.0;
307     double divisor = 1\&.0;
308     if (*text == fractionpoint) {
309         text++;
310         pos++;
311 
312         while (*text != '\0' && ((*text >= '0' && *text <= maxNumeric) || (maxAlpha != '\0' && *text >= 'A' && *text <= maxAlpha))) {
313             addition = ((*text >= '0' && *text <= maxNumeric) ? (*text - '0') : (*text - 'A' + 10));
314             fraction = fraction * base + addition;
315             divisor *= base;
316             text++;
317             pos++;
318         }
319     }
320 
321     double exp = 0;
322     if (*text == 'e' || *text == 'E') {
323         text++;
324         pos++;
325 
326         double sign = *text == '+' ? 1\&.0 : *text == '-' ? -1\&.0 : 0\&.0;
327 
328         if (sign != 0\&.0) {
329             text++;
330             pos++;
331 
332             while (*text != '\0' && ((*text >= '0' && *text <= maxNumeric) || (maxAlpha != 0 && *text >= 'A' && *text <= maxAlpha))) {
333                 addition = ((*text >= '0' && *text <= maxNumeric) ? (*text - '0') : (*text - 'A' + 10)) * 1\&.0;
334                 exp = exp * base + addition;
335                 text++;
336                 pos++;
337             }
338 
339             exp *= sign;
340         } else {
341             text--;
342             pos--;
343         }
344     }
345 
346     *length = pos;
347     *end = (char*)text;
348     double dnumber = (integer + (fraction / divisor)) * pow(base, exp);
349 
350     return new RealNumber(dnumber);
351 }
.fi
.SS "void PositionalNumeralSystem::SetDigits (unsigned int digits)\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 112 of file ntext\&.cpp\&.
.PP
References digits\&.
.PP
.nf
113 {
114     this->digits = digits;
115 }
.fi
.SS "void PositionalNumeralSystem::SetFractionPoint (const char fractionpoint)\fC [virtual]\fP"

.PP
Implements \fBNumeralSystem\fP\&.
.PP
Definition at line 122 of file ntext\&.cpp\&.
.PP
References fractionpoint\&.
.PP
.nf
123 {
124     this->fractionpoint = fractionpoint;
125 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "double PositionalNumeralSystem::base\fC [protected]\fP"

.PP
Definition at line 89 of file ntext\&.h\&.
.PP
Referenced by GetName(), GetText(), IntegerToBuffer(), Parse(), and PositionalNumeralSystem()\&.
.SS "unsigned int PositionalNumeralSystem::digits\fC [protected]\fP"

.PP
Definition at line 90 of file ntext\&.h\&.
.PP
Referenced by GetDigits(), DecimalSystem::GetRealText(), GetText(), PositionalNumeralSystem(), and SetDigits()\&.
.SS "char PositionalNumeralSystem::fractionpoint\fC [protected]\fP"

.PP
Definition at line 91 of file ntext\&.h\&.
.PP
Referenced by GetFractionPoint(), DecimalSystem::GetRealText(), GetText(), Parse(), PositionalNumeralSystem(), and SetFractionPoint()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
