.TH "lib/clib.h" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib.h \- C functions for manipulating strings and memory\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'platform\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBtexttag\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBStrLen\fP (const char *string)"
.br
.RI "\fIGet the length of a null terminated string\&. \fP"
.ti -1c
.RI "\fBbool\fP \fBStrIsEqual\fP (const char *s1, const char *s2)"
.br
.RI "\fICompare two null terminated strings to each other\&. \fP"
.ti -1c
.RI "void \fBMemSet\fP (void *destination, int c0, unsigned int length)"
.br
.ti -1c
.RI "void \fBMemCopy\fP (void *destination, const void *source, unsigned int length)"
.br
.RI "\fICopy a block of memory, handling overlap\&. \fP"
.ti -1c
.RI "unsigned int \fBAllocAndCopy\fP (char **destination, const char *source)"
.br
.RI "\fIAllocate memory and copy a string into the array\&. \fP"
.ti -1c
.RI "void \fBUntag\fP (char *destination, const char *source, \fBtexttag\fP tags[], unsigned int tagcount)"
.br
.in -1c
.SH "Detailed Description"
.PP 
C functions for manipulating strings and memory\&. 


.PP
Definition in file \fBclib\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "unsigned int AllocAndCopy (char ** destination, const char * source)"

.PP
Allocate memory and copy a string into the array\&. 
.PP
Definition at line 34 of file alloccpy\&.c\&.
.PP
Referenced by AnsiConoleEngine::AnsiConoleEngine(), CharBuffer::ClearAndCopy(), ConsoleBase::ConsoleBase(), AnsiConoleEngine::CopyLine(), DeleteStatement::DeleteStatement(), DrawStatement::DrawStatement(), ErrorNode::ErrorNode(), ExecuteStatement::ExecuteStatement(), HelpStatement::HelpStatement(), Lexer::Lexer(), ListStatement::ListStatement(), StandardLanguage::LoadCatalog(), LoadStatement::LoadStatement(), PlotStatement::PlotStatement(), PromptStatement::PromptStatement(), SaveStatement::SaveStatement(), PreferencesBase::SetDefaults(), PreferencesBase::SetPrompt(), ConsoleBase::SetPrompt(), AnsiConoleEngine::SetPrompt(), AnsiConoleEngine::ShowLast(), ShowStatement::ShowStatement(), Token::Token(), UserFunction::UserFunction(), and Variable::Variable()\&.
.PP
.nf
35 {
36     char *i, *s, *d;
37     unsigned int n, size;
38 
39     if (source == NOMEM) {
40         *destination = NOMEM;
41         return 0;
42     }
43 
44     i = (char*)source;
45     s = (char*)source;
46     while (*i)
47         i++;
48 
49     n = i - s + 1;
50     size = n;
51     *destination = AllocMemSafe(size);
52     d = *destination;
53 
54     while (n--)
55         *d++ = *s++;
56 
57     return size;
58 }
.fi
.SS "void MemCopy (void * destination, const void * source, unsigned int length)"

.PP
Copy a block of memory, handling overlap\&. Original file can be found at: https://svnweb.freebsd.org/base/release/9.0.0/lib/libc/string/bcopy.c?revision=229286 
.PP
Definition at line 60 of file memcpy\&.c\&.
.PP
Referenced by CharBuffer::EnsureSize(), FormatPositional(), FormatScientific(), Lexer::GetDigitValue(), Lexer::GetLitteral(), Lexer::GetQuotedIdent(), PrintInfNan(), and Language::UntagText()\&.
.PP
.nf
61 {
62     char *dst = (char*) destination;
63     const char *src = (const char*) source;
64     unsigned int t;
65 
66     if (length == 0 || dst == src) // nothing to do
67         return;
68 
69     if ((unsigned long)dst < (unsigned long)src) {
70         // Copy forward
71         t = (unsigned long)src; // only need low bits
72         if ((t | (unsigned long)dst) & wmask) {
73 
74             // Try to align operands\&.  This cannot be done unless the low bits match\&.
75             if ((t ^ (unsigned long)dst) & wmask || length < wsize)
76                 t = length;
77             else
78                 t = wsize - (t & wmask);
79             length -= t;
80 
81             TLOOP1(*dst++ = *src++);
82         }
83 
84         // Copy whole words, then mop up any trailing bytes\&.
85         t = length / wsize;
86         TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
87 
88         t = length & wmask;
89         TLOOP(*dst++ = *src++);
90 
91     } else {
92         // Copy backwards\&.  Otherwise essentially the same\&.
93         // Alignment works as before, except that it takes
94         // (t&wmask) bytes to align, not wsize-(t&wmask)\&.
95         src += length;
96         dst += length;
97         t = (unsigned long)src;
98         if ((t | (unsigned long)dst) & wmask) {
99 
100             if ((t ^ (unsigned long)dst) & wmask || length <= wsize)
101                 t = length;
102             else
103                 t &= wmask;
104             length -= t;
105 
106             TLOOP1(*--dst = *--src);
107         }
108 
109         t = length / wsize;
110         TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
111 
112         t = length & wmask;
113         TLOOP(*--dst = *--src);
114     }
115 }
.fi
.SS "void MemSet (void * destination, int c0, unsigned int length)"

.PP
Definition at line 42 of file memset\&.c\&.
.PP
.nf
43 {
44     unsigned char *dst = (unsigned char*) dst0;
45     unsigned int  t;
46     unsigned int  c;
47 
48     /*
49      * If not enough words, just fill bytes\&.  A length >= 2 words
50      * guarantees that at least one of them is `complete' after
51      * any necessary alignment\&.  For instance:
52      *
53      *  |-----------|-----------|-----------|
54      *  |00|01|02|03|04|05|06|07|08|09|0A|00|
55      *            ^---------------------^
56      *       dst         dst+length-1
57      *
58      * but we use a minimum of 3 here since the overhead of the code
59      * to do word writes is substantial\&.
60      */
61     if (length < 3 * wsize) {
62         while (length != 0) {
63             *dst++ = c0;
64             --length;
65         }
66     }
67 
68     if ((c = (unsigned char)c0) != 0) { /* Fill the word\&. */
69         c = (c << 8) | c;   /* u_int is 16 bits\&. */
70 #if UINT_MAX > 0xffff
71         c = (c << 16) | c;  /* u_int is 32 bits\&. */
72 #endif
73 #if UINT_MAX > 0xffffffff
74         c = (c << 32) | c;  /* u_int is 64 bits\&. */
75 #endif
76     }
77 
78     /* Align destination by filling in bytes\&. */
79     if ((t = (long)dst & wmask) != 0) {
80         t = wsize - t;
81         length -= t;
82         do {
83             *dst++ = c0;
84         } while (--t != 0);
85     }
86 
87     /* Fill words\&.  Length was >= 2*words so we know t >= 1 here\&. */
88     t = length / wsize;
89     do {
90         *(unsigned int*)dst = c;
91         dst += wsize;
92     } while (--t != 0);
93 
94     /* Mop up trailing bytes, if any\&. */
95     t = length & wmask;
96     if (t != 0)
97         do {
98             *dst++ = c0;
99         } while (--t != 0);
100 }
.fi
.SS "\fBbool\fP StrIsEqual (const char * s1, const char * s2)"

.PP
Compare two null terminated strings to each other\&. 
.PP
Definition at line 48 of file strcmp\&.c\&.
.PP
Referenced by VariableList::CreateVariable(), FunctionList::Delete(), Language::FindAlias(), FunctionList::GetFunctionCall(), FunctionList::GetFunctionDef(), Language::GetHelpText(), FunctionList::GetSystemFunction(), VariableList::GetVariable(), CharBuffer::Is(), StandardFilesystem::ListDirectory(), CharBuffer::RemoveTrailing(), StandardLanguage::StrIsEqualLoc(), and PosixLanguage::StrIsEqualLoc()\&.
.PP
.nf
49 {
50     int r;
51 
52     while (*s1 == *s2++)
53         if (*s1++ == '\0')
54             return true;
55 
56     r = (*(const unsigned char *)s1 - *(const unsigned char *)(s2 - 1));
57 
58     return r == 0;
59 }
.fi
.SS "int StrLen (const char * string)"

.PP
Get the length of a null terminated string\&. 
.PP
Definition at line 31 of file strlen\&.c\&.
.PP
Referenced by ErrorNode::ErrorNode(), VersionStatement::Execute(), MemoryStatement::Execute(), ErrorNode::Execute(), EvalStatement::Execute(), StatementBlockNode::Execute(), DeleteStatement::Execute(), InputStatement::Execute(), OutputStatement::Execute(), DigitsStatement::Execute(), SaveStatement::Execute(), PreferencesBase::GetDescription(), PositionalNumeralSystem::GetName(), UnaryNode::GetText(), FunctionNode::GetText(), AbsoluteNode::GetText(), NumericOperator::GetText(), StandardProgram::Initialize(), VariableList::ListContent(), FunctionList::ListContent(), StandardFilesystem::ListDirectory(), CharBuffer::RemoveTrailing(), StandardConsole::Run(), AnsiConoleEngine::ShowLast(), AnsiConoleEngine::ShowNext(), Language::UntagText(), and StandardConsole::WriteString()\&.
.PP
.nf
32 {
33     char *i = (char*)string;
34     char *s = i;
35     while (*i)
36         i++;
37     return i - s;
38 }
.fi
.SS "void Untag (char * destination, const char * source, \fBtexttag\fP tags[], unsigned int tagcount)"

.PP
Definition at line 29 of file untag\&.c\&.
.PP
References texttag::tag, and texttag::text\&.
.PP
Referenced by Language::UntagText()\&.
.PP
.nf
30 {
31     const char *pos, *tmp, *tag;
32     char *dest;
33     int unsigned i, j, found;
34 
35     pos = source;
36     dest = destination;
37 
38     while (*pos != '\0') {
39         if (*pos != '#') {
40             (*dest++ = *pos++);
41         } else {
42             // Try to replace tag
43             found = 0;
44             for (i = 0; i < tagcount; i++) {
45                 tag = tags[i]\&.tag;
46                 tmp = pos;
47                 j = 0;
48                 while (*tmp != '\0' && *tag != '\0' && *tmp == *tag) {
49                     tmp++;
50                     tag++;
51                     j++;
52                 }
53 
54                 if (j > 1 && *(--tag) == '#') {
55                     // Tag found\&. Now replace\&.
56                     tag = tags[i]\&.text;
57                     while ((*dest++ = *tag++));
58                     dest--;
59                     pos = tmp;
60                     found = 1;
61                     break;
62                 }
63             }
64 
65             if(!found) {
66                 (*dest++ = *pos++);
67             }
68         }
69     }
70     *dest = '\0';
71 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
