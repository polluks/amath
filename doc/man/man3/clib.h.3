.TH "lib/clib.h" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib.h \- C functions for manipulating strings and memory\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'platform\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBtexttag\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBStrLen\fP (const char *string)"
.br
.RI "\fIGet the length of a null terminated string\&. \fP"
.ti -1c
.RI "\fBbool\fP \fBStrIsEqual\fP (const char *s1, const char *s2)"
.br
.RI "\fICompare two null terminated strings to each other\&. \fP"
.ti -1c
.RI "void \fBMemSet\fP (void *destination, int c0, unsigned int length)"
.br
.RI "\fIFill block of memory with a constant value\&. \fP"
.ti -1c
.RI "void \fBMemCopy\fP (void *destination, const void *source, unsigned int length)"
.br
.RI "\fICopy a block of memory, handling overlap\&. \fP"
.ti -1c
.RI "unsigned int \fBAllocAndCopy\fP (char **destination, const char *source)"
.br
.RI "\fIAllocate memory and copy a string into the array\&. \fP"
.ti -1c
.RI "void \fBUntag\fP (char *destination, const char *source, \fBtexttag\fP tags[], unsigned int tagcount)"
.br
.in -1c
.SH "Detailed Description"
.PP 
C functions for manipulating strings and memory\&. 


.PP
Definition in file \fBclib\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "unsigned int AllocAndCopy (char ** destination, const char * source)"

.PP
Allocate memory and copy a string into the array\&. 
.PP
Definition at line 34 of file alloccpy\&.c\&.
.PP
Referenced by AnsiConoleEngine::AnsiConoleEngine(), CharBuffer::ClearAndCopy(), ConsoleBase::ConsoleBase(), AnsiConoleEngine::CopyLine(), DeleteStatement::DeleteStatement(), DrawStatement::DrawStatement(), ErrorNode::ErrorNode(), ExecuteStatement::ExecuteStatement(), HelpStatement::HelpStatement(), Lexer::Lexer(), ListStatement::ListStatement(), StandardLanguage::LoadCatalog(), LoadStatement::LoadStatement(), PlotStatement::PlotStatement(), PromptStatement::PromptStatement(), SaveStatement::SaveStatement(), PreferencesBase::SetDefaults(), PreferencesBase::SetPrompt(), ConsoleBase::SetPrompt(), AnsiConoleEngine::SetPrompt(), AnsiConoleEngine::ShowLast(), ShowStatement::ShowStatement(), Token::Token(), UserFunction::UserFunction(), and Variable::Variable()\&.
.PP
.nf
35 {
36     char *i, *s, *d;
37     unsigned int n, size;
38 
39     if (source == NOMEM) {
40         *destination = NOMEM;
41         return 0;
42     }
43 
44     i = (char*)source;
45     s = (char*)source;
46     while (*i)
47         i++;
48 
49     n = i - s + 1;
50     size = n;
51     *destination = AllocMemSafe(size);
52     d = *destination;
53 
54     while (n--)
55         *d++ = *s++;
56 
57     return size;
58 }
.fi
.SS "void MemCopy (void * destination, const void * source, unsigned int length)"

.PP
Copy a block of memory, handling overlap\&. 
.PP
Definition at line 71 of file memcpy\&.c\&.
.PP
Referenced by CharBuffer::EnsureSize(), FormatPositional(), FormatScientific(), Lexer::GetDigitValue(), Lexer::GetLitteral(), Lexer::GetQuotedIdent(), PrintInfNan(), and Language::UntagText()\&.
.PP
.nf
72 {
73     char *dst = (char*) destination;
74     const char *src = (const char*) source;
75     unsigned int t;
76 
77     if (length == 0 || dst == src) // nothing to do
78         return;
79 
80     if ((unsigned long)dst < (unsigned long)src) {
81         // Copy forward
82         t = (unsigned long)src; // only need low bits
83         if ((t | (unsigned long)dst) & wmask) {
84 
85             // Try to align operands\&.  This cannot be done unless the low bits match\&.
86             if ((t ^ (unsigned long)dst) & wmask || length < wsize)
87                 t = length;
88             else
89                 t = wsize - (t & wmask);
90             length -= t;
91 
92             TLOOP1(*dst++ = *src++);
93         }
94 
95         // Copy whole words, then mop up any trailing bytes\&.
96         t = length / wsize;
97         TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
98 
99         t = length & wmask;
100         TLOOP(*dst++ = *src++);
101 
102     } else {
103         // Copy backwards\&.  Otherwise essentially the same\&.
104         // Alignment works as before, except that it takes
105         // (t&wmask) bytes to align, not wsize-(t&wmask)\&.
106         src += length;
107         dst += length;
108         t = (unsigned long)src;
109         if ((t | (unsigned long)dst) & wmask) {
110 
111             if ((t ^ (unsigned long)dst) & wmask || length <= wsize)
112                 t = length;
113             else
114                 t &= wmask;
115             length -= t;
116 
117             TLOOP1(*--dst = *--src);
118         }
119 
120         t = length / wsize;
121         TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
122 
123         t = length & wmask;
124         TLOOP(*--dst = *--src);
125     }
126 }
.fi
.SS "void MemSet (void * destination, int c0, unsigned int length)"

.PP
Fill block of memory with a constant value\&. 
.PP
Definition at line 53 of file memset\&.c\&.
.PP
.nf
54 {
55     unsigned char *dst = (unsigned char*) dst0;
56     unsigned int  t;
57     unsigned int  c;
58 
59     /*
60      * If not enough words, just fill bytes\&.  A length >= 2 words
61      * guarantees that at least one of them is `complete' after
62      * any necessary alignment\&.  For instance:
63      *
64      *  |-----------|-----------|-----------|
65      *  |00|01|02|03|04|05|06|07|08|09|0A|00|
66      *            ^---------------------^
67      *       dst         dst+length-1
68      *
69      * but we use a minimum of 3 here since the overhead of the code
70      * to do word writes is substantial\&.
71      */
72     if (length < 3 * wsize) {
73         while (length != 0) {
74             *dst++ = c0;
75             --length;
76         }
77     }
78 
79     if ((c = (unsigned char)c0) != 0) { /* Fill the word\&. */
80         c = (c << 8) | c;   /* u_int is 16 bits\&. */
81 #if UINT_MAX > 0xffff
82         c = (c << 16) | c;  /* u_int is 32 bits\&. */
83 #endif
84 #if UINT_MAX > 0xffffffff
85         c = (c << 32) | c;  /* u_int is 64 bits\&. */
86 #endif
87     }
88 
89     /* Align destination by filling in bytes\&. */
90     if ((t = (long)dst & wmask) != 0) {
91         t = wsize - t;
92         length -= t;
93         do {
94             *dst++ = c0;
95         } while (--t != 0);
96     }
97 
98     /* Fill words\&.  Length was >= 2*words so we know t >= 1 here\&. */
99     t = length / wsize;
100     do {
101         *(unsigned int*)dst = c;
102         dst += wsize;
103     } while (--t != 0);
104 
105     /* Mop up trailing bytes, if any\&. */
106     t = length & wmask;
107     if (t != 0)
108         do {
109             *dst++ = c0;
110         } while (--t != 0);
111 }
.fi
.SS "\fBbool\fP StrIsEqual (const char * s1, const char * s2)"

.PP
Compare two null terminated strings to each other\&. 
.PP
Definition at line 49 of file strcmp\&.c\&.
.PP
Referenced by VariableList::CreateVariable(), FunctionList::Delete(), Language::FindAlias(), FunctionList::GetFunctionCall(), FunctionList::GetFunctionDef(), Language::GetHelpText(), FunctionList::GetSystemFunction(), VariableList::GetVariable(), CharBuffer::Is(), StandardFilesystem::ListDirectory(), CharBuffer::RemoveTrailing(), StandardLanguage::StrIsEqualLoc(), and PosixLanguage::StrIsEqualLoc()\&.
.PP
.nf
50 {
51     int r;
52 
53     while (*s1 == *s2++)
54         if (*s1++ == '\0')
55             return true;
56 
57     r = (*(const unsigned char *)s1 - *(const unsigned char *)(s2 - 1));
58 
59     return r == 0;
60 }
.fi
.SS "int StrLen (const char * string)"

.PP
Get the length of a null terminated string\&. 
.PP
Definition at line 31 of file strlen\&.c\&.
.PP
Referenced by ErrorNode::ErrorNode(), VersionStatement::Execute(), MemoryStatement::Execute(), ErrorNode::Execute(), EvalStatement::Execute(), StatementBlockNode::Execute(), DeleteStatement::Execute(), InputStatement::Execute(), OutputStatement::Execute(), DigitsStatement::Execute(), SaveStatement::Execute(), PreferencesBase::GetDescription(), PositionalNumeralSystem::GetName(), UnaryNode::GetText(), FunctionNode::GetText(), AbsoluteNode::GetText(), NumericOperator::GetText(), StandardProgram::Initialize(), VariableList::ListContent(), FunctionList::ListContent(), StandardFilesystem::ListDirectory(), CharBuffer::RemoveTrailing(), StandardConsole::Run(), AnsiConoleEngine::ShowLast(), AnsiConoleEngine::ShowNext(), Language::UntagText(), and StandardConsole::WriteString()\&.
.PP
.nf
32 {
33     char *i = (char*)string;
34     char *s = i;
35     while (*i)
36         i++;
37     return i - s;
38 }
.fi
.SS "void Untag (char * destination, const char * source, \fBtexttag\fP tags[], unsigned int tagcount)"

.PP
Definition at line 29 of file untag\&.c\&.
.PP
References texttag::tag, and texttag::text\&.
.PP
Referenced by Language::UntagText()\&.
.PP
.nf
30 {
31     const char *pos, *tmp, *tag;
32     char *dest;
33     int unsigned i, j, found;
34 
35     pos = source;
36     dest = destination;
37 
38     while (*pos != '\0') {
39         if (*pos != '#') {
40             (*dest++ = *pos++);
41         } else {
42             // Try to replace tag
43             found = 0;
44             for (i = 0; i < tagcount; i++) {
45                 tag = tags[i]\&.tag;
46                 tmp = pos;
47                 j = 0;
48                 while (*tmp != '\0' && *tag != '\0' && *tmp == *tag) {
49                     tmp++;
50                     tag++;
51                     j++;
52                 }
53 
54                 if (j > 1 && *(--tag) == '#') {
55                     // Tag found\&. Now replace\&.
56                     tag = tags[i]\&.text;
57                     while ((*dest++ = *tag++));
58                     dest--;
59                     pos = tmp;
60                     found = 1;
61                     break;
62                 }
63             }
64 
65             if(!found) {
66                 (*dest++ = *pos++);
67             }
68         }
69     }
70     *dest = '\0';
71 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
