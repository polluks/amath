.TH "lib/real/remp2.c" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/remp2.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'prim\&.h'\fP
.br
\fC#include 'math\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBrempio2\fP (double x, double *y)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const int \fBtwo_over_pi\fP []"
.br
.ti -1c
.RI "static const int \fBnpio2_hw\fP []"
.br
.ti -1c
.RI "static const double \fBzero\fP = 0\&.00000000000000000000e+00"
.br
.ti -1c
.RI "static const double \fBhalf\fP = 5\&.00000000000000000000e\-01"
.br
.ti -1c
.RI "static const double \fBtwo24\fP = 1\&.67772160000000000000e+07"
.br
.ti -1c
.RI "static const double \fBinvpio2\fP = 6\&.36619772367581382433e\-01"
.br
.ti -1c
.RI "static const double \fBpio2_1\fP = 1\&.57079632673412561417e+00"
.br
.ti -1c
.RI "static const double \fBpio2_1t\fP = 6\&.07710050650619224932e\-11"
.br
.ti -1c
.RI "static const double \fBpio2_2\fP = 6\&.07710050630396597660e\-11"
.br
.ti -1c
.RI "static const double \fBpio2_2t\fP = 2\&.02226624879595063154e\-21"
.br
.ti -1c
.RI "static const double \fBpio2_3\fP = 2\&.02226624871116645580e\-21"
.br
.ti -1c
.RI "static const double \fBpio2_3t\fP = 8\&.47842766036889956997e\-32"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int rempio2 (double x, double * y)"

.PP
Definition at line 103 of file remp2\&.c\&.
.PP
References __kernel_rem_pio2(), half, invpio2, npio2_hw, pio2_1, pio2_1t, pio2_2, pio2_2t, pio2_3, pio2_3t, two24, two_over_pi, and zero\&.
.PP
Referenced by cos(), sin(), and tan()\&.
.PP
.nf
104 {
105     double z = 0\&.,w,t,r,fn;
106     double tx[3];
107     sword i,j,n,ix,hx;
108     int e0,nx;
109     uword low;
110 
111     GET_HIGH_WORD(hx,x);        /* high word of x */
112     ix = hx&0x7fffffff;
113     if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
114     {
115         y[0] = x;
116         y[1] = 0;
117         return 0;
118     }
119     if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
120         if(hx>0) {
121             z = x - pio2_1;
122             if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
123                 y[0] = z - pio2_1t;
124                 y[1] = (z-y[0])-pio2_1t;
125             } else {        /* near pi/2, use 33+33+53 bit pi */
126                 z -= pio2_2;
127                 y[0] = z - pio2_2t;
128                 y[1] = (z-y[0])-pio2_2t;
129             }
130             return 1;
131         } else {    /* negative x */
132             z = x + pio2_1;
133             if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
134                 y[0] = z + pio2_1t;
135                 y[1] = (z-y[0])+pio2_1t;
136             } else {        /* near pi/2, use 33+33+53 bit pi */
137                 z += pio2_2;
138                 y[0] = z + pio2_2t;
139                 y[1] = (z-y[0])+pio2_2t;
140             }
141             return -1;
142         }
143     }
144     if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
145         t  = fabs(x);
146         n  = (sword) (t*invpio2+half);
147         fn = (double)n;
148         r  = t-fn*pio2_1;
149         w  = fn*pio2_1t;    /* 1st round good to 85 bit */
150         if(n<32&&ix!=npio2_hw[n-1]) {
151             y[0] = r-w; /* quick check no cancellation */
152         } else {
153             uword high;
154 
155             j  = ix>>20;
156             y[0] = r-w;
157             GET_HIGH_WORD(high, y[0]);
158             i = j-((high>>20)&0x7ff);
159             if(i>16) {  /* 2nd iteration needed, good to 118 */
160                 t  = r;
161                 w  = fn*pio2_2;
162                 r  = t-w;
163                 w  = fn*pio2_2t-((t-r)-w);
164                 y[0] = r-w;
165                 GET_HIGH_WORD(high,y[0]);
166                 i = j-((high>>20)&0x7ff);
167                 if(i>49)  { /* 3rd iteration need, 151 bits acc */
168                     t  = r; /* will cover all possible cases */
169                     w  = fn*pio2_3;
170                     r  = t-w;
171                     w  = fn*pio2_3t-((t-r)-w);
172                     y[0] = r-w;
173                 }
174             }
175         }
176         y[1] = (r-y[0])-w;
177         if(hx<0)    {
178             y[0] = -y[0];
179             y[1] = -y[1];
180             return -n;
181         }
182         else     return n;
183     }
184     /*
185      * all other (large) arguments
186      */
187     if(ix>=0x7ff00000) {        /* x is inf or NaN */
188         y[0]=y[1]=x-x;
189         return 0;
190     }
191     /* set z = scalbn(|x|,ilogb(x)-23) */
192     GET_LOW_WORD(low,x);
193     SET_LOW_WORD(z,low);
194     e0  = (sword)(ix>>20)-1046; /* e0 = ilogb(z)-23; */
195     SET_HIGH_WORD(z,ix - (e0<<20));
196     for(i=0; i<2; i++) {
197         tx[i] = (double)((sword)(z));
198         z     = (z-tx[i])*two24;
199     }
200     tx[2] = z;
201     nx = 3;
202     while(tx[nx-1]==zero) nx--; /* skip zero term */
203     n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
204     if(hx<0) {
205         y[0] = -y[0];
206         y[1] = -y[1];
207         return -n;
208     }
209     return n;
210 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const double half = 5\&.00000000000000000000e\-01\fC [static]\fP"

.PP
Definition at line 93 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double invpio2 = 6\&.36619772367581382433e\-01\fC [static]\fP"

.PP
Definition at line 95 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const int npio2_hw[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,
    0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,
    0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,
    0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,
    0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,
    0x404858EB, 0x404921FB,
}
.fi
.PP
Definition at line 72 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_1 = 1\&.57079632673412561417e+00\fC [static]\fP"

.PP
Definition at line 96 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_1t = 6\&.07710050650619224932e\-11\fC [static]\fP"

.PP
Definition at line 97 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_2 = 6\&.07710050630396597660e\-11\fC [static]\fP"

.PP
Definition at line 98 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_2t = 2\&.02226624879595063154e\-21\fC [static]\fP"

.PP
Definition at line 99 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_3 = 2\&.02226624871116645580e\-21\fC [static]\fP"

.PP
Definition at line 100 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double pio2_3t = 8\&.47842766036889956997e\-32\fC [static]\fP"

.PP
Definition at line 101 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double two24 = 1\&.67772160000000000000e+07\fC [static]\fP"

.PP
Definition at line 94 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const int two_over_pi[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,
    0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,
    0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,
    0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,
    0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,
    0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,
    0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,
    0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,
    0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,
    0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,
    0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,
}
.fi
.PP
Definition at line 58 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SS "const double zero = 0\&.00000000000000000000e+00\fC [static]\fP"

.PP
Definition at line 92 of file remp2\&.c\&.
.PP
Referenced by rempio2()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
