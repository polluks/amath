.TH "lib/real/prim.h" 3 "Sat Jan 21 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/prim.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "union \fBieee_float_shape_type\fP"
.br
.RI "\fIA union which permits us to convert between a float and a 32 bit int\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBHUGE\fP   1\&.7976931348623157e+308"
.br
.ti -1c
.RI "#define \fBEXTRACT_WORDS\fP(ix0,  ix1,  d)"
.br
.RI "\fIGet two 32 bit ints from a double\&. \fP"
.ti -1c
.RI "#define \fBGET_HIGH_WORD\fP(i,  d)"
.br
.RI "\fIGet the more significant 32 bit int from a double\&. \fP"
.ti -1c
.RI "#define \fBGET_LOW_WORD\fP(i,  d)"
.br
.RI "\fIGet the less significant 32 bit int from a double\&. \fP"
.ti -1c
.RI "#define \fBINSERT_WORDS\fP(d,  ix0,  ix1)"
.br
.RI "\fISet a double from two 32 bit ints\&. \fP"
.ti -1c
.RI "#define \fBSET_HIGH_WORD\fP(d,  v)"
.br
.RI "\fISet the more significant 32 bits of a double from an int\&. \fP"
.ti -1c
.RI "#define \fBSET_LOW_WORD\fP(d,  v)"
.br
.RI "\fISet the less significant 32 bits of a double from an int\&. \fP"
.ti -1c
.RI "#define \fBGET_FLOAT_WORD\fP(i,  d)"
.br
.RI "\fIGet a 32 bit int from a float\&. \fP"
.ti -1c
.RI "#define \fBSET_FLOAT_WORD\fP(d,  i)"
.br
.RI "\fISet a float from a 32 bit int\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned int \fBuword\fP"
.br
.RI "\fI32 bit unsigned integer\&. \fP"
.ti -1c
.RI "typedef signed int \fBsword\fP"
.br
.RI "\fI32 bit signed integer\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fB__kernel_cos\fP (double x, double y)"
.br
.RI "\fIKernel cos function\&. \fP"
.ti -1c
.RI "double \fB__kernel_sin\fP (double x, double y, int iy)"
.br
.RI "\fIKernel sin function\&. \fP"
.ti -1c
.RI "double \fB__kernel_tan\fP (double x, double y, int iy)"
.br
.RI "\fIKernel tan function\&. \fP"
.ti -1c
.RI "int \fB__kernel_rem_pio2\fP (double *x, double *y, int e0, int nx, int prec, const int *ipio2)"
.br
.RI "\fIKernel reduction function\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define EXTRACT_WORDS(ix0, ix1, d)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type ew_u;   \
    ew_u\&.value = (d);              \
    (ix0) = ew_u\&.parts\&.msw;        \
    (ix1) = ew_u\&.parts\&.lsw;        \
  } while (0)
.fi
.PP
Get two 32 bit ints from a double\&. 
.PP
Definition at line 153 of file prim\&.h\&.
.SS "#define GET_FLOAT_WORD(i, d)"
\fBValue:\fP
.PP
.nf
do {                               \
  ieee_float_shape_type gf_u;      \
  gf_u\&.value = (d);                \
  (i) = gf_u\&.word;                 \
} while (0)
.fi
.PP
Get a 32 bit int from a float\&. 
.PP
Definition at line 237 of file prim\&.h\&.
.SS "#define GET_HIGH_WORD(i, d)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type gh_u;   \
    gh_u\&.value = (d);              \
    (i) = gh_u\&.parts\&.msw;          \
  } while (0)
.fi
.PP
Get the more significant 32 bit int from a double\&. 
.PP
Definition at line 165 of file prim\&.h\&.
.SS "#define GET_LOW_WORD(i, d)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type gl_u;   \
    gl_u\&.value = (d);              \
    (i) = gl_u\&.parts\&.lsw;          \
  } while (0)
.fi
.PP
Get the less significant 32 bit int from a double\&. 
.PP
Definition at line 176 of file prim\&.h\&.
.SS "#define HUGE   1\&.7976931348623157e+308"

.PP
Definition at line 52 of file prim\&.h\&.
.SS "#define INSERT_WORDS(d, ix0, ix1)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type iw_u;   \
    iw_u\&.parts\&.msw = (ix0);        \
    iw_u\&.parts\&.lsw = (ix1);        \
    (d) = iw_u\&.value;              \
  } while (0)
.fi
.PP
Set a double from two 32 bit ints\&. 
.PP
Definition at line 187 of file prim\&.h\&.
.SS "#define SET_FLOAT_WORD(d, i)"
\fBValue:\fP
.PP
.nf
do {                               \
  ieee_float_shape_type sf_u;      \
  sf_u\&.word = (i);                 \
  (d) = sf_u\&.value;                \
} while (0)
.fi
.PP
Set a float from a 32 bit int\&. 
.PP
Definition at line 248 of file prim\&.h\&.
.SS "#define SET_HIGH_WORD(d, v)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type sh_u;   \
    sh_u\&.value = (d);              \
    sh_u\&.parts\&.msw = (v);          \
    (d) = sh_u\&.value;              \
  } while (0)
.fi
.PP
Set the more significant 32 bits of a double from an int\&. 
.PP
Definition at line 199 of file prim\&.h\&.
.SS "#define SET_LOW_WORD(d, v)"
\fBValue:\fP
.PP
.nf
do {                             \
    ieee_double_shape_type sl_u;   \
    sl_u\&.value = (d);              \
    sl_u\&.parts\&.lsw = (v);          \
    (d) = sl_u\&.value;              \
  } while (0)
.fi
.PP
Set the less significant 32 bits of a double from an int\&. 
.PP
Definition at line 211 of file prim\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef signed int \fBsword\fP"

.PP
32 bit signed integer\&. 
.PP
Definition at line 107 of file prim\&.h\&.
.SS "typedef unsigned int \fBuword\fP"

.PP
32 bit unsigned integer\&. 
.PP
Definition at line 101 of file prim\&.h\&.
.SH "Function Documentation"
.PP 
.SS "double __kernel_cos (double x, double y)"

.PP
Kernel cos function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.4 
.RE
.PP
\fBDate:\fP
.RS 4
96/03/07
.RE
.PP
.PP
.nf

Kernel cos function on [-pi/4, pi/4], pi/4 ~ 0\&.785398164
Input x is assumed to be bounded by ~pi/4 in magnitude\&.
Input y is the tail of x\&.
.fi
.PP
.PP
.PP
.nf
Algorithm
 1\&. Since cos(-x) = cos(x), we need only to consider positive x\&.
 2\&. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0\&.
 3\&. cos(x) is approximated by a polynomial of degree 14 on
    [0,pi/4]
                         4            14
        cos(x) ~ 1 - x*x/2 + C1*x + \&.\&.\&. + C6*x
    where the Remes error is
.fi
.PP
.PP
.PP
.nf
    |              2     4     6     8     10    12     14 |     -58
    |cos(x)-(1-\&.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2
    |                                      |
.fi
.PP
.PP
.PP
.nf
                   4     6     8     10    12     14
 4\&. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then
        cos(x) = 1 - x*x/2 + r
    since cos(x+y) ~ cos(x) - sin(x)*y
          ~ cos(x) - x*y,
    a correction term is necessary in cos(x) and hence
    cos(x+y) = 1 - (x*x/2 - (r - x*y))
    For better accuracy when x > 0\&.3, let qx = |x|/4 with
    the last 32 bits mask off, and if x > 0\&.78125, let qx = 0\&.28125\&.
    Then
    cos(x+y) = (1-qx) - ((x*x/2-qx) - (r-x*y))\&.
    Note that 1-qx and (x*x/2-qx) is EXACT here, and the
    magnitude of the latter is at least a quarter of x*x/2,
    thus, reducing the rounding error in the subtraction\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 100 of file kcos\&.c\&.
.PP
References C1, C2, C3, C4, C5, C6, and one\&.
.PP
Referenced by cos(), and sin()\&.
.PP
.nf
101 {
102     double a,hz,z,r,qx;
103     sword ix;
104     GET_HIGH_WORD(ix, x);
105     ix &= 0x7fffffff;   /* ix = |x|'s high word*/
106     if(ix<0x3e400000) {         /* if x < 2**27 */
107         if(((int)x)==0) return one;     /* generate inexact */
108     }
109     z  = x*x;
110     r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
111     if(ix < 0x3FD33333)             /* if |x| < 0\&.3 */
112         return one - (0\&.5*z - (z*r - x*y));
113     else {
114         if(ix > 0x3fe90000) {       /* x > 0\&.78125 */
115             qx = 0\&.28125;
116         } else {
117             INSERT_WORDS(qx,ix-0x00200000,0);
118         }
119         hz = 0\&.5*z-qx;
120         a  = one-qx;
121         return a - (hz - (z*r-x*y));
122     }
123 }
.fi
.SS "int __kernel_rem_pio2 (double * x, double * y, int e0, int nx, int prec, const int * ipio2)"

.PP
Kernel reduction function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.4 
.RE
.PP
\fBDate:\fP
.RS 4
96/03/07
.RE
.PP
.PP
.nf

__kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
double x[],y[]; int e0,nx,prec; int ipio2[];
.fi
.PP
.PP
.PP
.nf
__kernel_rem_pio2 return the last three digits of N with
    y = x - N*pi/2
so that |y| < pi/2\&.
.fi
.PP
.PP
.PP
.nf
The method is to compute the integer (mod 8) and fraction parts of
(2/pi)*x without doing the full multiplication\&. In general we
skip the part of the product that are known to be a huge integer (
more accurately, = 0 mod 8 )\&. Thus the number of operations are
independent of the exponent of the input\&.
.fi
.PP
.PP
.PP
.nf
(2/pi) is represented by an array of 24-bit integers in ipio2[]\&.
.fi
.PP
.PP
.PP
.nf
Input parameters:
    x[] The input value (must be positive) is broken into nx
    pieces of 24-bit integers in double precision format\&.
    x[i] will be the i-th 24 bit of x\&. The scaled exponent
    of x[0] is given in input parameter e0 (i\&.e\&., x[0]*2^e0
    match x's up to 24 bits\&.
.fi
.PP
.PP
.PP
.nf
    Example of breaking a double positive z into x[0]+x[1]+x[2]:
        e0 = ilogb(z)-23
        z  = scalbn(z,-e0)
    for i = 0,1,2
        x[i] = floor(z)
        z    = (z-x[i])*2**24
.fi
.PP
.PP
.PP
.nf
 y[]    ouput result in an array of double precision numbers\&.
    The dimension of y[] is:
        24-bit  precision   1
        53-bit  precision   2
        64-bit  precision   2
        113-bit precision   3
    The actual value is the sum of them\&. Thus for 113-bit
    precison, one may have to do something like:
.fi
.PP
.PP
.PP
.nf
    long double t,w,r_head, r_tail;
    t = (long double)y[2] + (long double)y[1];
    w = (long double)y[0];
    r_head = t+w;
    r_tail = w - (r_head - t);
.fi
.PP
.PP
.PP
.nf
 e0 The exponent of x[0]
.fi
.PP
.PP
.PP
.nf
 nx dimension of x[]
.fi
.PP
.PP
.PP
.nf
    prec    an integer indicating the precision:
        0   24  bits (single)
        1   53  bits (double)
        2   64  bits (extended)
        3   113 bits (quad)
.fi
.PP
.PP
.PP
.nf
 ipio2[]
    integer array, contains the (24*i)-th to (24*i+23)-th
    bit of 2/pi after binary point\&. The corresponding
    floating value is
.fi
.PP
.PP
.PP
.nf
        ipio2[i] * 2^(-24(i+1))\&.
.fi
.PP
.PP
.PP
.nf
External function:
 double \fBscalbn()\fP, \fBfloor()\fP;
.fi
.PP
.PP
.PP
.nf
Here is the description of some local variables:
.fi
.PP
.PP
.PP
.nf
    jk  jk+1 is the initial number of terms of ipio2[] needed
    in the computation\&. The recommended value is 2,3,4,
    6 for single, double, extended,and quad\&.
.fi
.PP
.PP
.PP
.nf
    jz  local integer variable indicating the number of
    terms of ipio2[] used\&.
.fi
.PP
.PP
.PP
.nf
 jx nx - 1
.fi
.PP
.PP
.PP
.nf
 jv index for pointing to the suitable ipio2[] for the
    computation\&. In general, we want
        ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
    is an integer\&. Thus
        e0-3-24*jv >= 0 or (e0-3)/24 >= jv
    Hence jv = max(0,(e0-3)/24)\&.
.fi
.PP
.PP
.PP
.nf
 jp jp+1 is the number of terms in PIo2[] needed, jp = jk\&.
.fi
.PP
.PP
.PP
.nf
    q[] double array with integral value, representing the
    24-bits chunk of the product of x and 2/pi\&.
.fi
.PP
.PP
.PP
.nf
 q0 the corresponding exponent of q[0]\&. Note that the
    exponent for q[i] would be q0-24*i\&.
.fi
.PP
.PP
.PP
.nf
 PIo2[] double precision array, obtained by cutting pi/2
    into 24 bits chunks\&.
.fi
.PP
.PP
.PP
.nf
 f[]    ipio2[] in floating point
.fi
.PP
.PP
.PP
.nf
 iq[]   integer array by breaking up q[] in 24-bits chunk\&.
.fi
.PP
.PP
.PP
.nf
 fq[]   final product of x*(2/pi) in fq[0],\&.\&.,fq[jk]
.fi
.PP
.PP
.PP
.nf
 ih integer\&. If >0 it indicates q[] is >= 0\&.5, hence
    it also indicates the *sign* of the result\&.
.fi
.PP
.PP
.PP
.nf
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 190 of file kremp2\&.c\&.
.PP
References init_jk, one, PIo2, scalbn(), two24, twon24, and zero\&.
.PP
Referenced by rempio2()\&.
.PP
.nf
191 {
192     int jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
193     double z,fw,f[20],fq[20],q[20];
194 
195     /* initialize jk*/
196     jk = init_jk[prec];
197     jp = jk;
198 
199     /* determine jx,jv,q0, note that 3>q0 */
200     jx =  nx-1;
201     jv = (e0-3)/24;
202     if(jv<0) jv=0;
203     q0 =  e0-24*(jv+1);
204 
205     /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
206     j = jv-jx;
207     m = jx+jk;
208     for(i=0; i<=m; i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
209 
210     /* compute q[0],q[1],\&.\&.\&.q[jk] */
211     for (i=0; i<=jk; i++) {
212         for(j=0,fw=0\&.0; j<=jx; j++) fw += x[j]*f[jx+i-j];
213         q[i] = fw;
214     }
215 
216     jz = jk;
217 recompute:
218     /* distill q[] into iq[] reversingly */
219     for(i=0,j=jz,z=q[jz]; j>0; i++,j--) {
220         fw    =  (double)((int)(twon24* z));
221         iq[i] =  (int)(z-two24*fw);
222         z     =  q[j-1]+fw;
223     }
224 
225     /* compute n */
226     z  = scalbn(z,q0);      /* actual value of z */
227     z -= 8\&.0*floor(z*0\&.125);      /* trim off integer >= 8 */
228     n  = (int) z;
229     z -= (double)n;
230     ih = 0;
231     if(q0>0) {  /* need iq[jz-1] to determine n */
232         i  = (iq[jz-1]>>(24-q0));
233         n += i;
234         iq[jz-1] -= i<<(24-q0);
235         ih = iq[jz-1]>>(23-q0);
236     }
237     else if(q0==0) ih = iq[jz-1]>>23;
238     else if(z>=0\&.5) ih=2;
239 
240     if(ih>0) {  /* q > 0\&.5 */
241         n += 1;
242         carry = 0;
243         for(i=0; i<jz ; i++) {  /* compute 1-q */
244             j = iq[i];
245             if(carry==0) {
246                 if(j!=0) {
247                     carry = 1;
248                     iq[i] = 0x1000000- j;
249                 }
250             } else  iq[i] = 0xffffff - j;
251         }
252         if(q0>0) {      /* rare case: chance is 1 in 12 */
253             switch(q0) {
254             case 1:
255                 iq[jz-1] &= 0x7fffff;
256                 break;
257             case 2:
258                 iq[jz-1] &= 0x3fffff;
259                 break;
260             }
261         }
262         if(ih==2) {
263             z = one - z;
264             if(carry!=0) z -= scalbn(one,q0);
265         }
266     }
267 
268     /* check if recomputation is needed */
269     if(z==zero) {
270         j = 0;
271         for (i=jz-1; i>=jk; i--) j |= iq[i];
272         if(j==0) { /* need recomputation */
273             for(k=1; iq[jk-k]==0; k++); /* k = no\&. of terms needed */
274 
275             for(i=jz+1; i<=jz+k; i++) { /* add q[jz+1] to q[jz+k] */
276                 f[jx+i] = (double) ipio2[jv+i];
277                 for(j=0,fw=0\&.0; j<=jx; j++) fw += x[j]*f[jx+i-j];
278                 q[i] = fw;
279             }
280             jz += k;
281             goto recompute;
282         }
283     }
284 
285     /* chop off zero terms */
286     if(z==0\&.0) {
287         jz -= 1;
288         q0 -= 24;
289         while(iq[jz]==0) {
290             jz--;
291             q0-=24;
292         }
293     } else { /* break z into 24-bit if necessary */
294         z = scalbn(z,-q0);
295         if(z>=two24) {
296             fw = (double)((int)(twon24*z));
297             iq[jz] = (int)(z-two24*fw);
298             jz += 1;
299             q0 += 24;
300             iq[jz] = (int) fw;
301         } else iq[jz] = (int) z ;
302     }
303 
304     /* convert integer "bit" chunk to floating-point value */
305     fw = scalbn(one,q0);
306     for(i=jz; i>=0; i--) {
307         q[i] = fw*(double)iq[i];
308         fw*=twon24;
309     }
310 
311     /* compute PIo2[0,\&.\&.\&.,jp]*q[jz,\&.\&.\&.,0] */
312     for(i=jz; i>=0; i--) {
313         for(fw=0\&.0,k=0; k<=jp&&k<=jz-i; k++) fw += PIo2[k]*q[i+k];
314         fq[jz-i] = fw;
315     }
316 
317     /* compress fq[] into y[] */
318     switch(prec) {
319     case 0:
320         fw = 0\&.0;
321         for (i=jz; i>=0; i--) fw += fq[i];
322         y[0] = (ih==0)? fw: -fw;
323         break;
324     case 1:
325     case 2:
326         fw = 0\&.0;
327         for (i=jz; i>=0; i--) fw += fq[i];
328         y[0] = (ih==0)? fw: -fw;
329         fw = fq[0]-fw;
330         for (i=1; i<=jz; i++) fw += fq[i];
331         y[1] = (ih==0)? fw: -fw;
332         break;
333     case 3: /* painful */
334         for (i=jz; i>0; i--) {
335             fw      = fq[i-1]+fq[i];
336             fq[i]  += fq[i-1]-fw;
337             fq[i-1] = fw;
338         }
339         for (i=jz; i>1; i--) {
340             fw      = fq[i-1]+fq[i];
341             fq[i]  += fq[i-1]-fw;
342             fq[i-1] = fw;
343         }
344         for (fw=0\&.0,i=jz; i>=2; i--) fw += fq[i];
345         if(ih==0) {
346             y[0] =  fq[0];
347             y[1] =  fq[1];
348             y[2] =  fw;
349         } else {
350             y[0] = -fq[0];
351             y[1] = -fq[1];
352             y[2] = -fw;
353         }
354     }
355     return n&7;
356 }
.fi
.SS "double __kernel_sin (double x, double y, int iy)"

.PP
Kernel sin function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
Kernel sin function on [-pi/4, pi/4], pi/4 ~ 0\&.7854 Input x is assumed to be bounded by ~pi/4 in magnitude\&. Input y is the tail of x\&. Input iy indicates whether y is 0\&. (if iy=0, y assume to be 0)\&.
.PP
Algorithm
.IP "1." 4
Since sin(-x) = -sin(x), we need only to consider positive x\&.
.IP "2." 4
if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0\&.
.IP "3." 4
sin(x) is approximated by a polynomial of degree 13 on [0,pi/4] 3 13 sin(x) ~ x + S1*x + \&.\&.\&. + S6*x where
.PP
|sin(x) 2 4 6 8 10 12 | -58 |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x +S6*x )| <= 2 | x |
.IP "4." 4
sin(x+y) = sin(x) + sin'(x')*y ~ sin(x) + (1-x*x/2)*y For better accuracy, let 3 2 2 2 2 r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6)))) then 3 2 sin(x) = x + (S1*x + (x *(r-y/2)+y))  
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP

.PP
Definition at line 92 of file ksin\&.c\&.
.PP
References half, S1, S2, S3, S4, S5, and S6\&.
.PP
Referenced by cos(), and sin()\&.
.PP
.nf
93 {
94     double z,r,v;
95     sword ix;
96     GET_HIGH_WORD(ix,x);
97     ix &=0x7fffffff;    /* high word of x */
98     if(ix<0x3e400000)           /* |x| < 2**-27 */
99     {
100         if((int)x==0) return x;   /* generate inexact */
101     }
102     z   =  x*x;
103     v   =  z*x;
104     r   =  S2+z*(S3+z*(S4+z*(S5+z*S6)));
105     if(iy==0) return x+v*(S1+z*r);
106     else      return x-((z*(half*y-v*r)-y)-v*S1);
107 }
.fi
.SS "double __kernel_tan (double x, double y, int iy)"

.PP
Kernel tan function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.5 
.RE
.PP
\fBDate:\fP
.RS 4
04/04/22
.RE
.PP
Kernel tan function on [-pi/4, pi/4], pi/4 ~ 0\&.7854 Input x is assumed to be bounded by ~pi/4 in magnitude\&. Input y is the tail of x\&. Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned\&.
.PP
Algorithm
.IP "1." 4
Since tan(-x) = -tan(x), we need only to consider positive x\&.
.IP "2." 4
if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0\&.
.IP "3." 4
tan(x) is approximated by a odd polynomial of degree 27 on [0,0\&.67434] 3 27 tan(x) ~ x + T1*x + \&.\&.\&. + T13*x where 
.PP
.nf
    |tan(x)         2     4            26   |     -59.2
    |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2
    |  x                    |

.fi
.PP
.PP
Note: tan(x+y) = tan(x) + tan'(x)*y ~ tan(x) + (1+x*x)*y Therefore, for better accuracy in computing tan(x+y), let 3 2 2 2 2 r = x *(T2+x *(T3+x *(\&.\&.\&.+x *(T12+x *T13)))) then 3 2 tan(x+y) = x + (T1*x + (x *(r+y)+y))
.IP "  4." 6
For x in [0\&.67434,pi/4], let y = pi/4 - x, then tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y)) = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))  
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP

.PP

.PP
Definition at line 112 of file ktan\&.c\&.
.PP
Referenced by tan()\&.
.PP
.nf
112                                                 {
113     double z, r, v, w, s;
114     sword ix, hx;
115 
116     GET_HIGH_WORD(hx,x); /* high word of x */
117     ix = hx & 0x7fffffff;           /* high word of |x| */
118     if (ix < 0x3e300000) {          /* x < 2**-28 */
119         if ((int) x == 0) {     /* generate inexact */
120             uword low;
121             GET_LOW_WORD(low,x);
122             if (((ix | low) | (iy + 1)) == 0)
123                 return one / fabs(x);
124             else {
125                 if (iy == 1)
126                     return x;
127                 else {  /* compute -1 / (x+y) carefully */
128                     double a, t;
129 
130                     z = w = x + y;
131                     SET_LOW_WORD(z,0);
132                     v = y - (z - x);
133                     t = a = -one / w;
134                     SET_LOW_WORD(t,0);
135                     s = one + t * z;
136                     return t + a * (s + t * v);
137                 }
138             }
139         }
140     }
141     if (ix >= 0x3FE59428) { /* |x| >= 0\&.6744 */
142         if (hx < 0) {
143             x = -x;
144             y = -y;
145         }
146         z = pio4 - x;
147         w = pio4lo - y;
148         x = z + w;
149         y = 0\&.0;
150     }
151     z = x * x;
152     w = z * z;
153     /*
154      * Break x^5*(T[1]+x^2*T[2]+\&.\&.\&.) into
155      * x^5(T[1]+x^4*T[3]+\&.\&.\&.+x^20*T[11]) +
156      * x^5(x^2*(T[2]+x^4*T[4]+\&.\&.\&.+x^22*[T12]))
157      */
158     r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +
159                                             w * T[11]))));
160     v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +
161                                      w * T[12])))));
162     s = z * x;
163     r = y + z * (s * (r + v) + y);
164     r += T[0] * s;
165     w = x + r;
166     if (ix >= 0x3FE59428) {
167         v = (double) iy;
168         return (double) (1 - ((hx >> 30) & 2)) *
169                (v - 2\&.0 * (x - (w * w / (w + v) - r)));
170     }
171     if (iy == 1)
172         return w;
173     else {
174         /*
175          * if allow error up to 2 ulp, simply return
176          * -1\&.0 / (x+r) here
177          */
178         /* compute -1\&.0 / (x+r) accurately */
179         double a, t;
180         z = w;
181         SET_LOW_WORD(z,0);
182         v = r - (z - x);    /* z+v = r+x */
183         t = a = -1\&.0 / w;    /* a = -1\&.0/w */
184         SET_LOW_WORD(t,0);
185         s = 1\&.0 + t * z;
186         return t + a * (s + t * v);
187     }
188 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
