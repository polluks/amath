.TH "lib/clib/mem.c" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib/mem.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'mem\&.h'\fP
.br
\fC#include 'clib\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBMemoryBlock\fP"
.br
.ti -1c
.RI "struct \fBMemoryList\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBALLOC_MEM\fP(x)   calloc(1L,x)"
.br
.ti -1c
.RI "#define \fBFREE_MEM\fP(x)   free(x)"
.br
.ti -1c
.RI "#define \fBDebug\fP(x,  y,  z,  w)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBalloc_error\fP (char *, size_t)"
.br
.ti -1c
.RI "void \fBdealloc_error\fP (char *, void *)"
.br
.ti -1c
.RI "void * \fBAllocMemSafe\fP (size_t size)"
.br
.ti -1c
.RI "void \fBFreeMemSafe\fP (void *block)"
.br
.ti -1c
.RI "void \fBFreeAllSafe\fP ()"
.br
.ti -1c
.RI "void \fBMemUsage\fP (long *blocks, long *size, long *peak)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBMemoryList\fP * \fBlist\fP = NULL"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ALLOC_MEM(x)   calloc(1L,x)"

.PP
Definition at line 41 of file mem\&.c\&.
.SS "#define Debug(x, y, z, w)"

.PP
Definition at line 43 of file mem\&.c\&.
.SS "#define FREE_MEM(x)   free(x)"

.PP
Definition at line 42 of file mem\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void alloc_error (char * descr, size_t size)"

.PP
Definition at line 204 of file mem\&.c\&.
.PP
Referenced by AllocMemSafe()\&.
.PP
.nf
205 {
206     Debug(NULL, "Mememory allocation error (%s) with size (%d)\n", descr, size);
207 }
.fi
.SS "void* AllocMemSafe (size_t size)"

.PP
Definition at line 67 of file mem\&.c\&.
.PP
References MemoryBlock::address, alloc_error(), MemoryList::count, MemoryList::first, MemoryList::last, list, MemoryBlock::next, MemoryList::peak, and MemoryList::size\&.
.PP
.nf
68 {
69     struct MemoryBlock *newblock;
70     size_t allocsize;
71 
72     if (list == NULL) {
73         list = (struct MemoryList*)ALLOC_MEM(sizeof(struct MemoryList));
74         if (!list) {
75             alloc_error("list", sizeof(struct MemoryList));
76             return 0;
77         }
78 
79         list->first = NULL;
80         list->last = NULL;
81         list->peak = 0;
82         list->size = 0;
83         list->count = 0;
84     }
85 
86 #if defined(__x86_64__) || defined(__aarch64__) || defined(_M_AMD64) || defined(_M_ARM64)
87     // Align to bytes of 8
88     allocsize = (size + 7) & ~0x07;
89 #else
90     // Align to bytes of 4
91     allocsize = (size + 3) & ~0x03;
92 #endif
93 
94     newblock = (struct MemoryBlock*)ALLOC_MEM(sizeof(struct MemoryBlock));
95     if (!newblock) {
96         alloc_error("block", sizeof(struct MemoryBlock));
97         return 0;
98     }
99 
100     newblock->address = (struct MemoryBlock*)ALLOC_MEM(allocsize);
101     if (!newblock->address) {
102         FREE_MEM(newblock);
103         alloc_error("memory", allocsize);
104         return 0;
105     }
106 
107     newblock->size = allocsize;
108     newblock->next = NULL;
109 
110     if(list->first == NULL) {
111         list->first = newblock;
112         list->last = newblock;
113     } else {
114         list->last->next = newblock;
115         list->last = newblock;
116     }
117 
118     list->size += allocsize;
119     list->count++;
120 
121     if (list->size > list->peak) {
122         list->peak = list->size;
123     }
124 
125     // DEBUG code
126     // Debug(NULL, "Mememory allocated at address (%x)\n", newblock->address);
127 
128     return newblock->address;
129 }
.fi
.SS "void dealloc_error (char * descr, void * p)"

.PP
Definition at line 209 of file mem\&.c\&.
.PP
Referenced by FreeMemSafe()\&.
.PP
.nf
210 {
211     Debug(NULL, "Mememory deallocation error (%s) address (%x)\n", descr, p);
212 }
.fi
.SS "void FreeAllSafe ()"

.PP
Definition at line 177 of file mem\&.c\&.
.PP
References MemoryBlock::address, MemoryList::first, list, and MemoryBlock::next\&.
.PP
Referenced by Cleanup()\&.
.PP
.nf
178 {
179     struct MemoryBlock *current, *next;
180 
181     if (list == NULL) {
182         return;
183     }
184 
185     current = list->first;
186     while (current != NULL) {
187         next = current->next;
188         FREE_MEM(current->address);
189         FREE_MEM(current);
190         current = next;
191     }
192 
193     FREE_MEM(list);
194     list = NULL;
195 }
.fi
.SS "void FreeMemSafe (void * block)"

.PP
Definition at line 131 of file mem\&.c\&.
.PP
References MemoryBlock::address, MemoryList::count, dealloc_error(), MemoryList::first, MemoryList::last, list, and MemoryBlock::next\&.
.PP
.nf
132 {
133     struct MemoryBlock *current, *last;
134 
135     if (list == NULL || block == NULL) {
136         dealloc_error("list", 0);
137         return;
138     }
139 
140     if (block == NULL) {
141         dealloc_error("memory", 0);
142         return;
143     }
144 
145     last = NULL;
146     current = list->first;
147     while (current != NULL && current->address != block) {
148         last = current;
149         current = current->next;
150     }
151 
152     if (current == NULL) {
153         dealloc_error("address not found", block);
154         return;
155     }
156 
157     list->size -= current->size;
158     list->count--;
159 
160     if (list->first == current) {
161         list->first = NULL;
162         list->last = NULL;
163     } else if (list->last == current) {
164         last->next = current->next;
165         list->last = last;
166     } else {
167         last->next = current->next;
168     }
169 
170     FREE_MEM(current->address);
171     FREE_MEM(current);
172 
173     // DEBUG code
174     // Debug(NULL, "Mememory deallocated at address (%x)\n", block);
175 }
.fi
.SS "void MemUsage (long * blocks, long * size, long * peak)"

.PP
Definition at line 197 of file mem\&.c\&.
.PP
References MemoryList::count, list, MemoryList::peak, and MemoryList::size\&.
.PP
Referenced by MemoryStatement::Execute()\&.
.PP
.nf
198 {
199     *blocks = list->count;
200     *size = list->size;
201     *peak = list->peak;;
202 }
.fi
.SH "Variable Documentation"
.PP 
.SS "struct \fBMemoryList\fP* list = NULL"

.PP
Definition at line 62 of file mem\&.c\&.
.PP
Referenced by AllocMemSafe(), FreeAllSafe(), FreeMemSafe(), and MemUsage()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
