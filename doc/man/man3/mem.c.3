.TH "lib/clib/mem.c" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/clib/mem.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'mem\&.h'\fP
.br
\fC#include 'clib\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBMemoryBlock\fP"
.br
.RI "\fIBlock of allocated memory\&. \fP"
.ti -1c
.RI "struct \fBMemoryList\fP"
.br
.RI "\fIList of allocated memory\&. Uses the LIFO principle\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBALLOC_MEM\fP(x)   calloc(1L,x)"
.br
.ti -1c
.RI "#define \fBFREE_MEM\fP(x)   free(x)"
.br
.ti -1c
.RI "#define \fBDebug\fP(x,  y,  z)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBalloc_error\fP (char *descr, size_t size)"
.br
.RI "\fILog a mememory allocation error\&. \fP"
.ti -1c
.RI "void \fBdealloc_error\fP (char *descr, void *p)"
.br
.RI "\fILog a mememory deallocation error\&. \fP"
.ti -1c
.RI "void * \fBAllocMemSafe\fP (size_t size)"
.br
.RI "\fIAllocate memory and add it to the global memory list\&. \fP"
.ti -1c
.RI "void \fBFreeMemSafe\fP (void *block)"
.br
.RI "\fIDeallocate memory from the global memory list\&. \fP"
.ti -1c
.RI "void \fBFreeAllSafe\fP ()"
.br
.RI "\fIDeallocate all memory in the global memory list\&. \fP"
.ti -1c
.RI "void \fBMemUsage\fP (long *blocks, long *size, long *peak)"
.br
.RI "\fIGet memory usage in the global memory list\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBMemoryList\fP * \fBlist\fP = NULL"
.br
.RI "\fIGlobal list of allocated memory\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ALLOC_MEM(x)   calloc(1L,x)"

.PP
Definition at line 41 of file mem\&.c\&.
.SS "#define Debug(x, y, z)"

.PP
Definition at line 43 of file mem\&.c\&.
.SS "#define FREE_MEM(x)   free(x)"

.PP
Definition at line 42 of file mem\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void alloc_error (char * descr, size_t size)"

.PP
Log a mememory allocation error\&. 
.PP
Definition at line 217 of file mem\&.c\&.
.PP
Referenced by AllocMemSafe()\&.
.PP
.nf
218 {
219     Debug("Mememory allocation error (%s) with size (%d)\n", descr, size);
220 }
.fi
.SS "void* AllocMemSafe (size_t size)"

.PP
Allocate memory and add it to the global memory list\&. 
.PP
Definition at line 78 of file mem\&.c\&.
.PP
References MemoryBlock::address, alloc_error(), MemoryList::count, MemoryList::first, list, MemoryBlock::next, MemoryList::peak, and MemoryList::size\&.
.PP
.nf
79 {
80     struct MemoryBlock *newblock;
81     size_t allocsize;
82 
83     if (list == NULL) {
84         list = (struct MemoryList*)ALLOC_MEM(sizeof(struct MemoryList));
85         if (!list) {
86             alloc_error("list", sizeof(struct MemoryList));
87             return 0;
88         }
89 
90         list->first = NULL;
91         list->peak = 0;
92         list->size = 0;
93         list->count = 0;
94     }
95 
96 #if defined(__x86_64__) || defined(__aarch64__) || defined(_M_AMD64) || defined(_M_ARM64)
97     // Align to bytes of 8
98     allocsize = (size + 7) & ~0x07;
99 #else
100     // Align to bytes of 4
101     allocsize = (size + 3) & ~0x03;
102 #endif
103 
104     newblock = (struct MemoryBlock*)ALLOC_MEM(sizeof(struct MemoryBlock));
105     if (!newblock) {
106         alloc_error("block", sizeof(struct MemoryBlock));
107         return 0;
108     }
109 
110     newblock->address = (struct MemoryBlock*)ALLOC_MEM(allocsize);
111     if (!newblock->address) {
112         FREE_MEM(newblock);
113         alloc_error("memory", allocsize);
114         return 0;
115     }
116 
117     newblock->size = allocsize;
118     newblock->next = list->first;
119     list->first = newblock;
120     list->size += allocsize;
121     list->count++;
122 
123     if (list->size > list->peak) {
124         list->peak = list->size;
125     }
126 
127     // DEBUG code
128     // Debug(NULL, "Mememory allocated at address (%x)\n", newblock->address);
129 
130     return newblock->address;
131 }
.fi
.SS "void dealloc_error (char * descr, void * p)"

.PP
Log a mememory deallocation error\&. 
.PP
Definition at line 225 of file mem\&.c\&.
.PP
Referenced by FreeMemSafe()\&.
.PP
.nf
226 {
227     Debug("Mememory deallocation error (%s) address (%x)\n", descr, p);
228 }
.fi
.SS "void FreeAllSafe ()"

.PP
Deallocate all memory in the global memory list\&. 
.PP
Definition at line 184 of file mem\&.c\&.
.PP
References MemoryBlock::address, MemoryList::first, list, and MemoryBlock::next\&.
.PP
Referenced by Cleanup()\&.
.PP
.nf
185 {
186     struct MemoryBlock *current, *next;
187 
188     if (list == NULL) {
189         return;
190     }
191 
192     current = list->first;
193     while (current != NULL) {
194         next = current->next;
195         FREE_MEM(current->address);
196         FREE_MEM(current);
197         current = next;
198     }
199 
200     FREE_MEM(list);
201     list = NULL;
202 }
.fi
.SS "void FreeMemSafe (void * block)"

.PP
Deallocate memory from the global memory list\&. 
.PP
Definition at line 136 of file mem\&.c\&.
.PP
References MemoryBlock::address, MemoryList::count, dealloc_error(), MemoryList::first, list, and MemoryBlock::next\&.
.PP
.nf
137 {
138     struct MemoryBlock *current, *previous;
139 
140     if (list == NULL || block == NULL) {
141         dealloc_error("list", 0);
142         return;
143     }
144 
145     if (block == NULL) {
146         dealloc_error("memory", 0);
147         return;
148     }
149 
150     previous = NULL;
151     current = list->first;
152     while (current != NULL && current->address != block) {
153         previous = current;
154         current = current->next;
155     }
156 
157     if (current == NULL) {
158         dealloc_error("address not found", block);
159         return;
160     }
161 
162     if (previous == NULL) {
163         list->first = current->next;
164     } else {
165         previous->next = current->next;
166     }
167 
168     list->size -= current->size;
169     list->count--;
170 
171     FREE_MEM(current->address);
172     current->address = NULL;
173     current->next = NULL;
174     current->size = 0;
175     FREE_MEM(current);
176 
177     // DEBUG code
178     // Debug("Mememory deallocated at address (%x)\n", block);
179 }
.fi
.SS "void MemUsage (long * blocks, long * size, long * peak)"

.PP
Get memory usage in the global memory list\&. 
.PP
Definition at line 207 of file mem\&.c\&.
.PP
References MemoryList::count, list, MemoryList::peak, and MemoryList::size\&.
.PP
Referenced by MemoryStatement::Execute()\&.
.PP
.nf
208 {
209     *blocks = list->count;
210     *size = list->size;
211     *peak = list->peak;;
212 }
.fi
.SH "Variable Documentation"
.PP 
.SS "struct \fBMemoryList\fP* list = NULL"

.PP
Global list of allocated memory\&. 
.PP
Definition at line 70 of file mem\&.c\&.
.PP
Referenced by AllocMemSafe(), FreeAllSafe(), FreeMemSafe(), and MemUsage()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
