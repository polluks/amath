.TH "lib/math.h" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/math.h \- Functions in math library for handling real numbers\&.  

.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPI\fP   3\&.141592653589793238462643383279"
.br
.ti -1c
.RI "#define \fBEULERS\fP   2\&.718281828459045235360287471352"
.br
.ti -1c
.RI "#define \fBsgn\fP(x)   x > 0\&.0 ? 1\&.0 : x < 0\&.0 ? \-1\&.0 : 0\&.0"
.br
.ti -1c
.RI "#define \fBlog2p\fP(x,  y)   \fBlog\fP(x)/\fBlog\fP(y)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBisnan\fP (double x)"
.br
.RI "\fIisnan(x) returns 1 is x is nan, else 0\&. \fP"
.ti -1c
.RI "int \fBfinite\fP (double x)"
.br
.RI "\fIFinite or infinite number\&. \fP"
.ti -1c
.RI "double \fBfabs\fP (double x)"
.br
.RI "\fIReturns the absolute value of x\&. \fP"
.ti -1c
.RI "double \fBceil\fP (double x)"
.br
.RI "\fIMathematical ceiling function\&. \fP"
.ti -1c
.RI "double \fBfloor\fP (double x)"
.br
.RI "\fIMathematical floor function\&. \fP"
.ti -1c
.RI "double \fBround\fP (double x)"
.br
.ti -1c
.RI "double \fBtrunc\fP (double x)"
.br
.ti -1c
.RI "double \fBexp\fP (double x)"
.br
.RI "\fIReturns the exponential of x\&. \fP"
.ti -1c
.RI "double \fBsqrt\fP (double x)"
.br
.RI "\fISquare root function\&. \fP"
.ti -1c
.RI "double \fBcbrt\fP (double x)"
.br
.RI "\fICube root function\&. \fP"
.ti -1c
.RI "double \fBlog\fP (double x)"
.br
.RI "\fINatural logarithm function (base e)\&. \fP"
.ti -1c
.RI "double \fBlog10\fP (double x)"
.br
.RI "\fIBase 10 logarithm function\&. \fP"
.ti -1c
.RI "double \fBcos\fP (double x)"
.br
.RI "\fITrigonometric cosine function\&. \fP"
.ti -1c
.RI "double \fBsin\fP (double x)"
.br
.RI "\fITrigonometric sine function\&. \fP"
.ti -1c
.RI "double \fBtan\fP (double x)"
.br
.RI "\fITrigonometric tangent function\&. \fP"
.ti -1c
.RI "double \fBacos\fP (double x)"
.br
.RI "\fIInverse trigonometric cosine function\&. \fP"
.ti -1c
.RI "double \fBasin\fP (double x)"
.br
.RI "\fIInverse trigonometric sine function\&. \fP"
.ti -1c
.RI "double \fBatan\fP (double x)"
.br
.RI "\fIInverse trigonometric tangent function\&. \fP"
.ti -1c
.RI "double \fBcosh\fP (double x)"
.br
.RI "\fIHyperbolic cosine function\&. \fP"
.ti -1c
.RI "double \fBsinh\fP (double x)"
.br
.RI "\fIHyperbolic sine function\&. \fP"
.ti -1c
.RI "double \fBtanh\fP (double x)"
.br
.RI "\fIHyperbolic tangent function\&. \fP"
.ti -1c
.RI "double \fBacosh\fP (double x)"
.br
.RI "\fIInverse hyperbolic cosine function\&. \fP"
.ti -1c
.RI "double \fBasinh\fP (double x)"
.br
.RI "\fIInverse hyperbolic sine function\&. \fP"
.ti -1c
.RI "double \fBatanh\fP (double x)"
.br
.RI "\fIInverse hyperbolic tangent function\&. \fP"
.ti -1c
.RI "double \fBpow\fP (double x, double y)"
.br
.RI "\fIExpontation function\&. \fP"
.ti -1c
.RI "double \fBfmod\fP (double x, double y)"
.br
.RI "\fIReturn x mod y in exact arithmetic\&. \fP"
.ti -1c
.RI "double \fBatan2\fP (double y, double x)"
.br
.ti -1c
.RI "double \fBhypot\fP (double x, double y)"
.br
.ti -1c
.RI "double \fBlog1p\fP (double x)"
.br
.ti -1c
.RI "double \fBexpm1\fP (double x)"
.br
.ti -1c
.RI "double \fBscalbn\fP (double x, int n)"
.br
.ti -1c
.RI "double \fBcopysign\fP (double x, double y)"
.br
.RI "\fIReturns a value with the magnitude of x and with the sign bit of y\&. \fP"
.ti -1c
.RI "int \fBrempio2\fP (double x, double *y)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions in math library for handling real numbers\&. 

The library is based on fdlib by Sun Microsystems\&. The original library can be downloaded at: http://www.netlib.org/fdlibm/
.PP
or from mirros site: http://www.hensa.ac.uk/
.PP
All headers and dates are preserved\&. 
.PP
Definition in file \fBmath\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define EULERS   2\&.718281828459045235360287471352"

.PP
Definition at line 46 of file math\&.h\&.
.SS "#define log2p(x, y)   \fBlog\fP(x)/\fBlog\fP(y)"

.PP
Definition at line 48 of file math\&.h\&.
.SS "#define PI   3\&.141592653589793238462643383279"

.PP
Definition at line 45 of file math\&.h\&.
.SS "#define sgn(x)   x > 0\&.0 ? 1\&.0 : x < 0\&.0 ? \-1\&.0 : 0\&.0"

.PP
Definition at line 47 of file math\&.h\&.
.SH "Function Documentation"
.PP 
.SS "double acos (double x)"

.PP
Inverse trigonometric cosine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
 acos(x)  = pi/2 - asin(x)
 acos(-x) = pi/2 + asin(x)
For |x|<=0\&.5
 acos(x) = pi/2 - (x + x*x^2*R(x^2))    (see \fBasin\&.c\fP)
For x>0\&.5
    acos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
    = 2asin(sqrt((1-x)/2))
    = 2s + 2s*z*R(z)    \&.\&.\&.z=(1-x)/2, s=sqrt(z)
    = 2f + (2c + 2s*z*R(z))
    where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
    for f so that f+c ~ sqrt(z)\&.
For x<-0\&.5
 acos(x) = pi - 2asin(sqrt((1-|x|)/2))
    = pi - 0\&.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)
.fi
.PP
.PP
.PP
.nf
Special cases:
 if x is NaN, return x itself;
 if |x|>1, return NaN with invalid signal\&.
.fi
.PP
.PP
.PP
.nf
Function needed: sqrt
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 96 of file acos\&.c\&.
.PP
References one, pi, pio2_hi, pio2_lo, pS0, pS1, pS2, pS3, pS4, pS5, qS1, qS2, qS3, qS4, and sqrt()\&.
.PP
Referenced by RealNumber::ArcCosine(), and RealNumber::ArcSecant()\&.
.PP
.nf
97 {
98     double z,p,q,r,w,s,c,df;
99     sword hx,ix;
100     GET_HIGH_WORD(hx,x);
101     ix = hx&0x7fffffff;
102     if(ix>=0x3ff00000) {    /* |x| >= 1 */
103         sword lx;
104         GET_LOW_WORD(lx,x);
105         if(((ix-0x3ff00000)|lx)==0) {   /* |x|==1 */
106             if(hx>0) return 0\&.0;     /* acos(1) = 0  */
107             else return pi+2\&.0*pio2_lo;  /* acos(-1)= pi */
108         }
109         return (x-x)/(x-x);     /* acos(|x|>1) is NaN */
110     }
111     if(ix<0x3fe00000) { /* |x| < 0\&.5 */
112         if(ix<=0x3c600000) return pio2_hi+pio2_lo;/*if|x|<2**-57*/
113         z = x*x;
114         p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
115         q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
116         r = p/q;
117         return pio2_hi - (x - (pio2_lo-x*r));
118     } else  if (hx<0) {     /* x < -0\&.5 */
119         z = (one+x)*0\&.5;
120         p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
121         q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
122         s = sqrt(z);
123         r = p/q;
124         w = r*s-pio2_lo;
125         return pi - 2\&.0*(s+w);
126     } else {            /* x > 0\&.5 */
127         z = (one-x)*0\&.5;
128         s = sqrt(z);
129         df = s;
130         SET_LOW_WORD(df,0);
131         c  = (z-df*df)/(s+df);
132         p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
133         q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
134         r = p/q;
135         w = r*s+c;
136         return 2\&.0*(df+w);
137     }
138 }
.fi
.SS "double acosh (double x)"

.PP
Inverse hyperbolic cosine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
 Based on
    acosh(x) = log [ x + sqrt(x*x-1) ]
 we have
    acosh(x) := log(x)+ln2, if x is large; else
    acosh(x) := log(2x-1/(sqrt(x*x-1)+x)) if x>2; else
    acosh(x) := log1p(t+sqrt(2\&.0*t+t*t)); where t=x-1\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 acosh(x) is NaN with signal if x<1\&.
 acosh(NaN) is NaN without signal\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 75 of file acosh\&.c\&.
.PP
References ln2, log1p(), one, and sqrt()\&.
.PP
Referenced by RealNumber::HypArcCosine(), and RealNumber::HypArcSecant()\&.
.PP
.nf
76 {
77     double t;
78     sword hx, lx;
79     GET_HIGH_WORD(hx,x);
80     GET_LOW_WORD(lx,x);
81 
82     if(hx<0x3ff00000) {     /* x < 1 */
83         return (x-x)/(x-x);
84     } else if(hx >=0x41b00000) {    /* x > 2**28 */
85         if(hx >=0x7ff00000) {   /* x is inf of NaN */
86             return x+x;
87         } else
88             return log(x)+ln2;  /* acosh(huge)=log(2x) */
89     } else if(((hx-0x3ff00000)|lx)==0) {
90         return 0\&.0;          /* acosh(1) = 0 */
91     } else if (hx > 0x40000000) {   /* 2**28 > x > 2 */
92         t=x*x;
93         return log(2\&.0*x-one/(x+sqrt(t-one)));
94     } else {            /* 1<x<2 */
95         t = x-one;
96         return log1p(t+sqrt(2\&.0*t+t*t));
97     }
98 }
.fi
.SS "double asin (double x)"

.PP
Inverse trigonometric sine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
 Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + \&.\&.\&.
 we approximate asin(x) on [0,0\&.5] by
    asin(x) = x + x*x^2*R(x^2)
 where
    R(x^2) is a rational approximation of (asin(x)-x)/x^3
 and its remez error is bounded by
    |(asin(x)-x)/x^3 - R(x^2)| < 2^(-58\&.75)
.fi
.PP
.PP
.PP
.nf
 For x in [0\&.5,1]
    asin(x) = pi/2-2*asin(sqrt((1-x)/2))
 Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
 then for x>0\&.98
    asin(x) = pi/2 - 2*(s+s*z*R(z))
        = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
 For x<=0\&.98, let pio4_hi = pio2_hi/2, then
    f = hi part of s;
    c = sqrt(z) - f = (z-f*f)/(s+f)     \&.\&.\&.f+c=sqrt(z)
 and
    asin(x) = pi/2 - 2*(s+s*z*R(z))
        = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
        = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
.fi
.PP
.PP
.PP
.nf
Special cases:
 if x is NaN, return x itself;
 if |x|>1, return NaN with invalid signal\&.
.fi
.PP
.PP
.PP
.nf
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 104 of file asin\&.c\&.
.PP
References huge, one, pio2_hi, pio2_lo, pio4_hi, pS0, pS1, pS2, pS3, pS4, pS5, qS1, qS2, qS3, qS4, and sqrt()\&.
.PP
Referenced by RealNumber::ArcCosecant(), and RealNumber::ArcSine()\&.
.PP
.nf
105 {
106     double t,w,p,q,c,r,s;
107     sword hx,ix;
108     GET_HIGH_WORD(hx,x);
109     ix = hx&0x7fffffff;
110     if(ix>= 0x3ff00000) {       /* |x|>= 1 */
111         uword lx;
112         GET_LOW_WORD(lx,x);
113         if(((ix-0x3ff00000)|lx)==0)
114             /* asin(1)=+-pi/2 with inexact */
115             return x*pio2_hi+x*pio2_lo;
116         return (x-x)/(x-x);     /* asin(|x|>1) is NaN */
117     } else if (ix<0x3fe00000) { /* |x|<0\&.5 */
118         if(ix<0x3e400000) {     /* if |x| < 2**-27 */
119             if(huge+x>one) {
120                 return x;/* return x with inexact if x!=0*/
121             } else {
122                 t = 0;
123             }
124         } else {
125             t = x*x;
126         }
127 
128         p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
129         q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
130         w = p/q;
131         return x+x*w;
132     }
133     /* 1> |x|>= 0\&.5 */
134     w = one-fabs(x);
135     t = w*0\&.5;
136     p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
137     q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
138     s = sqrt(t);
139     if(ix>=0x3FEF3333) {    /* if |x| > 0\&.975 */
140         w = p/q;
141         t = pio2_hi-(2\&.0*(s+s*w)-pio2_lo);
142     } else {
143         w  = s;
144         SET_LOW_WORD(w,0);
145         c  = (t-w*w)/(s+w);
146         r  = p/q;
147         p  = 2\&.0*s*r-(pio2_lo-2\&.0*c);
148         q  = pio4_hi-2\&.0*w;
149         t  = pio4_hi-(p-q);
150     }
151     if(hx>0) return t;
152     else return -t;
153 }
.fi
.SS "double asinh (double x)"

.PP
Inverse hyperbolic sine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
 Based on
    asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
 we have
 asinh(x) := x  if  1+x*x=1,
     := sign(x)*(log(x)+ln2)) for large |x|, else
     := sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|>2, else
     := sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 73 of file asinh\&.c\&.
.PP
References huge, ln2, log1p(), one, and sqrt()\&.
.PP
Referenced by RealNumber::HypArcCosecant(), and RealNumber::HypArcSine()\&.
.PP
.nf
74 {
75     double t,w;
76     sword hx,ix;
77     GET_HIGH_WORD(hx,x);
78     ix = hx&0x7fffffff;
79     if(ix>=0x7ff00000) return x+x;  /* x is inf or NaN */
80     if(ix< 0x3e300000) {    /* |x|<2**-28 */
81         if(huge+x>one) return x;    /* return x inexact except 0 */
82     }
83     if(ix>0x41b00000) { /* |x| > 2**28 */
84         w = log(fabs(x))+ln2;
85     } else if (ix>0x40000000) { /* 2**28 > |x| > 2\&.0 */
86         t = fabs(x);
87         w = log(2\&.0*t+one/(sqrt(x*x+one)+t));
88     } else {        /* 2\&.0 > |x| > 2**-28 */
89         t = x*x;
90         w =log1p(fabs(x)+t/(one+sqrt(one+t)));
91     }
92     if(hx>0) return w;
93     else return -w;
94 }
.fi
.SS "double atan (double x)"

.PP
Inverse trigonometric tangent function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method
  1\&. Reduce x to positive by atan(x) = -atan(-x)\&.
  2\&. According to the integer k=4t+0\&.25 chopped, t=x, the argument
     is further reduced to one of the following intervals and the
     arctangent of t is evaluated by the corresponding formula:
.fi
.PP
.PP
.PP
.nf
     [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+\&.\&.\&.(a10+t^2*a11)\&.\&.\&.)
     [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0\&.5)/(1+t/2) )
     [11/16\&.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
     [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1\&.5)/(1+1\&.5t) )
     [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 109 of file atan\&.c\&.
.PP
References aT, atanhi, atanlo, huge, and one\&.
.PP
Referenced by RealNumber::ArcCotangent(), RealNumber::ArcTangent(), and atan2()\&.
.PP
.nf
110 {
111     double w,s1,s2,z;
112     sword ix,hx,id;
113 
114     GET_HIGH_WORD(hx,x);
115     ix = hx&0x7fffffff;
116     if(ix>=0x44100000) {    /* if |x| >= 2^66 */
117         uword low;
118 
119         GET_LOW_WORD(low,x);
120         if(ix>0x7ff00000||
121                 (ix==0x7ff00000&&(low!=0)))
122             return x+x;     /* NaN */
123         if(hx>0) return  atanhi[3]+atanlo[3];
124         else     return -atanhi[3]-atanlo[3];
125     }
126     if (ix < 0x3fdc0000) {  /* |x| < 0\&.4375 */
127         if (ix < 0x3e200000) {  /* |x| < 2^-29 */
128             if(huge+x>one) return x;    /* raise inexact */
129         }
130         id = -1;
131     } else {
132         x = fabs(x);
133         if (ix < 0x3ff30000) {      /* |x| < 1\&.1875 */
134             if (ix < 0x3fe60000) {  /* 7/16 <=|x|<11/16 */
135                 id = 0;
136                 x = (2\&.0*x-one)/(2\&.0+x);
137             } else {            /* 11/16<=|x|< 19/16 */
138                 id = 1;
139                 x  = (x-one)/(x+one);
140             }
141         } else {
142             if (ix < 0x40038000) {  /* |x| < 2\&.4375 */
143                 id = 2;
144                 x  = (x-1\&.5)/(one+1\&.5*x);
145             } else {            /* 2\&.4375 <= |x| < 2^66 */
146                 id = 3;
147                 x  = -1\&.0/x;
148             }
149         }
150     }
151     /* end of argument reduction */
152     z = x*x;
153     w = z*z;
154     /* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
155     s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));
156     s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));
157     if (id<0) return x - x*(s1+s2);
158     else {
159         z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
160         return (hx<0)? -z:z;
161     }
162 }
.fi
.SS "double atan2 (double y, double x)"

.PP
Definition at line 86 of file atan2\&.c\&.
.PP
References atan(), pi, pi_lo, pi_o_2, pi_o_4, tiny, and zero\&.
.PP
Referenced by clog(), and cpow()\&.
.PP
.nf
87 {
88     double z;
89     sword k,m,hx,hy,ix,iy;
90     uword lx,ly;
91 
92     EXTRACT_WORDS(hx,lx,x);
93     ix = hx&0x7fffffff;
94     EXTRACT_WORDS(hy,ly,y);
95     iy = hy&0x7fffffff;
96     if(((ix|((lx|-lx)>>31))>0x7ff00000)||
97             ((iy|((ly|-ly)>>31))>0x7ff00000))   /* x or y is NaN */
98         return x+y;
99     if(((hx-0x3ff00000)|lx)==0) return atan(y);   /* x=1\&.0 */
100     m = ((hy>>31)&1)|((hx>>30)&2);  /* 2*sign(x)+sign(y) */
101 
102     /* when y = 0 */
103     if((iy|ly)==0) {
104         switch(m) {
105         case 0:
106         case 1:
107             return y;   /* atan(+-0,+anything)=+-0 */
108         case 2:
109             return  pi+tiny;/* atan(+0,-anything) = pi */
110         case 3:
111             return -pi-tiny;/* atan(-0,-anything) =-pi */
112         }
113     }
114     /* when x = 0 */
115     if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;
116 
117     /* when x is INF */
118     if(ix==0x7ff00000) {
119         if(iy==0x7ff00000) {
120             switch(m) {
121             case 0:
122                 return  pi_o_4+tiny;/* atan(+INF,+INF) */
123             case 1:
124                 return -pi_o_4-tiny;/* atan(-INF,+INF) */
125             case 2:
126                 return  3\&.0*pi_o_4+tiny;/*atan(+INF,-INF)*/
127             case 3:
128                 return -3\&.0*pi_o_4-tiny;/*atan(-INF,-INF)*/
129             }
130         } else {
131             switch(m) {
132             case 0:
133                 return  zero  ; /* atan(+\&.\&.\&.,+INF) */
134             case 1:
135                 return -zero  ; /* atan(-\&.\&.\&.,+INF) */
136             case 2:
137                 return  pi+tiny  ;  /* atan(+\&.\&.\&.,-INF) */
138             case 3:
139                 return -pi-tiny  ;  /* atan(-\&.\&.\&.,-INF) */
140             }
141         }
142     }
143     /* when y is INF */
144     if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;
145 
146     /* compute y/x */
147     k = (iy-ix)>>20;
148     if(k > 60) z=pi_o_2+0\&.5*pi_lo;   /* |y/x| >  2**60 */
149     else if(hx<0&&k<-60) z=0\&.0;  /* |y|/x < -2**60 */
150     else z=atan(fabs(y/x));     /* safe to do y/x */
151     switch (m) {
152     case 0:
153         return       z  ;   /* atan(+,+) */
154     case 1: {
155         uword zh;
156         GET_HIGH_WORD(zh,z);
157         SET_HIGH_WORD(z, zh ^ 0x80000000);
158     }
159     return       z  ;   /* atan(-,+) */
160     case 2:
161         return  pi-(z-pi_lo);/* atan(+,-) */
162     default: /* case 3 */
163         return  (z-pi_lo)-pi;/* atan(-,-) */
164     }
165 }
.fi
.SS "double atanh (double x)"

.PP
Inverse hyperbolic tangent function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
   1\&.Reduced x to positive by atanh(-x) = -atanh(x)
   2\&.For x>=0\&.5
                 1              2x                          x
 atanh(x) = --- * log(1 + -------) = 0\&.5 * log1p(2 * --------)
                 2             1 - x                      1 - x
.fi
.PP
.PP
.PP
.nf
    For x<0\&.5
 atanh(x) = 0\&.5*log1p(2x+2x*x/(1-x))
.fi
.PP
.PP
.PP
.nf
Special cases:
 atanh(x) is NaN if |x| > 1 with signal;
 atanh(NaN) is that NaN with no signal;
 atanh(+-1) is +-INF with signal\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 81 of file atanh\&.c\&.
.PP
References huge, log1p(), one, and zero\&.
.PP
Referenced by RealNumber::HypArcCotangent(), and RealNumber::HypArcTangent()\&.
.PP
.nf
82 {
83     double t;
84     sword hx,ix;
85     uword lx;
86     GET_HIGH_WORD(hx,x);
87     GET_LOW_WORD(lx,x);
88     ix = hx&0x7fffffff;
89     if ((ix|((lx|(-lx))>>31))>0x3ff00000) /* |x|>1 */
90         return (x-x)/(x-x);
91     if(ix==0x3ff00000)
92         return x/zero;
93     if(ix<0x3e300000&&(huge+x)>zero) return x;  /* x<2**-28 */
94     SET_HIGH_WORD(x, ix);       /* x <- |x| */
95     if(ix<0x3fe00000) {     /* x < 0\&.5 */
96         t = x+x;
97         t = 0\&.5*log1p(t+t*x/(one-x));
98     } else
99         t = 0\&.5*log1p((x+x)/(one-x));
100     if(hx>=0) return t;
101     else return -t;
102 }
.fi
.SS "double cbrt (double x)"

.PP
Cube root function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18 
.RE
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 67 of file cbrt\&.c\&.
.PP
References B1, B2, C, D, E, F, and G\&.
.PP
.nf
68 {
69     sword   hx, lx, ht;
70     double r,s,t=0\&.0,w;
71     uword sign;
72 
73     GET_HIGH_WORD(hx,x); /* high word of x */
74     sign=hx&0x80000000;         /* sign= sign(x) */
75     hx  ^=sign;
76     if(hx>=0x7ff00000) return(x+x); /* cbrt(NaN,INF) is itself */
77     GET_LOW_WORD(lx, x);
78     if((hx|lx)==0)
79         return(x);      /* cbrt(0) is itself */
80 
81     SET_HIGH_WORD(x,hx); /* x <- |x| */
82     /* rough cbrt to 5 bits */
83     if(hx<0x00100000)       /* subnormal number */
84     {
85         SET_HIGH_WORD(t,0x43500000);        /* set t= 2**54 */
86         t*=x;
87         GET_HIGH_WORD(ht,t);
88         SET_HIGH_WORD(t,ht/3+B2);
89     }
90     else
91         SET_HIGH_WORD(t,hx/3+B1);
92 
93     /* new cbrt to 23 bits, may be implemented in single precision */
94     r=t*t/x;
95     s=C+r*t;
96     t*=G+F/(s+E+D/s);
97 
98     /* chopped to 20 bits and make it larger than cbrt(x) */
99     SET_LOW_WORD(t,0);
100     GET_HIGH_WORD(ht,t);
101     SET_HIGH_WORD(t,ht + 0x00000001);
102 
103     /* one step newton iteration to 53 bits with error less than 0\&.667 ulps */
104     s=t*t;      /* t*t is exact */
105     r=x/s;
106     w=t+t;
107     r=(r-t)/(w+r);  /* r-s is exact */
108     t=t+t*r;
109 
110     /* retore the sign bit */
111     GET_HIGH_WORD(ht,t);
112     SET_HIGH_WORD(t,ht|sign);
113 
114     return(t);
115 }
.fi
.SS "double ceil (double x)"

.PP
Mathematical ceiling function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return x rounded toward -inf to integral value
Method:
 Bit twiddling\&.
Exception:
 Inexact flag raised if x not equal to ceil(x)\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 65 of file ceil\&.c\&.
.PP
References huge\&.
.PP
.nf
66 {
67     sword i0,i1,j0;
68     uword i,j;
69     EXTRACT_WORDS(i0,i1,x);
70     j0 = ((i0>>20)&0x7ff)-0x3ff;
71     if(j0<20) {
72         if(j0<0) {          /* raise inexact if x != 0 */
73             if(huge+x>0\&.0) {     /* return 0*sign(x) if |x|<1 */
74                 if(i0<0) {
75                     i0=0x80000000;
76                     i1=0;
77                 }
78                 else if((i0|i1)!=0) {
79                     i0=0x3ff00000;
80                     i1=0;
81                 }
82             }
83         } else {
84             i = (0x000fffff)>>j0;
85             if(((i0&i)|i1)==0) return x; /* x is integral */
86             if(huge+x>0\&.0) {     /* raise inexact flag */
87                 if(i0>0) i0 += (0x00100000)>>j0;
88                 i0 &= (~i);
89                 i1=0;
90             }
91         }
92     } else if (j0>51) {
93         if(j0==0x400) return x+x;   /* inf or NaN */
94         else return x;          /* x is integral */
95     } else {
96         i = ((uword)(0xffffffff))>>(j0-20);
97         if((i1&i)==0) return x;     /* x is integral */
98         if(huge+x>0\&.0) {         /* raise inexact flag */
99             if(i0>0) {
100                 if(j0==20) i0+=1;
101                 else {
102                     j = i1 + (1<<(52-j0));
103                     // NOTICE: Is this a correct cast?
104                     if((sword)j<(sword)i1) i0+=1;   /* got a carry */
105                     i1 = j;
106                 }
107             }
108             i1 &= (~i);
109         }
110     }
111     INSERT_WORDS(x,i0,i1);
112     return x;
113 }
.fi
.SS "double copysign (double x, double y)"

.PP
Returns a value with the magnitude of x and with the sign bit of y\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18 
.RE
.PP

.PP
Definition at line 52 of file copysign\&.c\&.
.PP
.nf
53 {
54     uword hx, hy;
55     GET_HIGH_WORD(hx, x);
56     GET_HIGH_WORD(hy, y);
57     SET_HIGH_WORD(x, (hx&0x7fffffff)|(hy&0x80000000));
58     return x;
59 }
.fi
.SS "double cos (double x)"

.PP
Trigonometric cosine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return cosine function of x\&.
.fi
.PP
.PP
.PP
.nf
kernel function:
 __kernel_sin       \&.\&.\&. sine function on [-pi/4,pi/4]
 __kernel_cos       \&.\&.\&. cosine function on [-pi/4,pi/4]
 rem_pio2       \&.\&.\&. argument reduction routine
.fi
.PP
.PP
.PP
.nf
Method\&.
     Let S,C and T denote the sin, cos and tan respectively on
 [-PI/4, +PI/4]\&. Reduce the argument x to y1+y2 = x-k*pi/2
 in [-pi/4 , +pi/4], and let n = k mod 4\&.
 We have
.fi
.PP
.PP
.PP
.nf
         n        sin(x)      cos(x)        tan(x)
    ----------------------------------------------------------
     0         S       C         T
     1         C      -S        -1/T
     2        -S      -C         T
     3        -C       S        -1/T
    ----------------------------------------------------------
.fi
.PP
.PP
.PP
.nf
Special cases:
     Let trig be any of sin, cos, or tan\&.
     trig(+-INF)  is NaN, with signals;
     trig(NaN)    is that NaN;
.fi
.PP
.PP
.PP
.nf
Accuracy:
 TRIG(x) returns trig(x) nearly rounded
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 87 of file cos\&.c\&.
.PP
References __kernel_cos(), __kernel_sin(), and rempio2()\&.
.PP
Referenced by cchc(), ccos(), ccosh(), ccot(), ccoth(), ccsc(), ccsch(), cexp(), RealNumber::Cosine(), cpow(), csec(), csech(), csin(), csinh(), ctan(), ctanh(), and RealNumber::Secant()\&.
.PP
.nf
88 {
89     double y[2],z=0\&.0;
90     sword n, ix;
91 
92     /* High word of x\&. */
93     GET_HIGH_WORD(ix,x);
94 
95     /* |x| ~< pi/4 */
96     ix &= 0x7fffffff;
97     if(ix <= 0x3fe921fb) return __kernel_cos(x,z);
98 
99     /* cos(Inf or NaN) is NaN */
100     else if (ix>=0x7ff00000) return x-x;
101 
102     /* argument reduction needed */
103     else {
104         n = rempio2(x,y);
105         switch(n&3) {
106         case 0:
107             return  __kernel_cos(y[0],y[1]);
108         case 1:
109             return -__kernel_sin(y[0],y[1],1);
110         case 2:
111             return -__kernel_cos(y[0],y[1]);
112         default:
113             return  __kernel_sin(y[0],y[1],1);
114         }
115     }
116 }
.fi
.SS "double cosh (double x)"

.PP
Hyperbolic cosine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2
 1\&. Replace x by |x| (cosh(x) = cosh(-x))\&.
 2\&.
                                            [ exp(x) - 1 ]^2
     0        <= x <= ln2/2  :  cosh(x) := 1 + -------------------
                                   2*exp(x)
.fi
.PP
.PP
.PP
.nf
                                      exp(x) +  1/exp(x)
     ln2/2    <= x <= 22     :  cosh(x) := -------------------
                                  2
     22       <= x <= lnovft :  cosh(x) := exp(x)/2
     lnovft   <= x <= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
     ln2ovft  <  x      :  cosh(x) := huge*huge (overflow)
.fi
.PP
.PP
.PP
.nf
Special cases:
 cosh(x) is |x| if x is +INF, -INF, or NaN\&.
 only cosh(0)=1 is exact for finite x\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 84 of file cosh\&.c\&.
.PP
References exp(), expm1(), half, huge, and one\&.
.PP
Referenced by cchc(), cchsh(), ccot(), ccoth(), ccsc(), ccsch(), csec(), csech(), ctan(), ctanh(), RealNumber::HypCosine(), and RealNumber::HypSecant()\&.
.PP
.nf
85 {
86     double t,w;
87     sword ix;
88     uword lx;
89 
90     /* High word of |x|\&. */
91     GET_HIGH_WORD(ix,x);
92     ix &= 0x7fffffff;
93 
94     /* x is INF or NaN */
95     if(ix>=0x7ff00000) return x*x;
96 
97     /* |x| in [0,0\&.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
98     if(ix<0x3fd62e43) {
99         t = expm1(fabs(x));
100         w = one+t;
101         if (ix<0x3c800000) return w;    /* cosh(tiny) = 1 */
102         return one+(t*t)/(w+w);
103     }
104 
105     /* |x| in [0\&.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
106     if (ix < 0x40360000) {
107         t = exp(fabs(x));
108         return half*t+half/t;
109     }
110 
111     /* |x| in [22, log(maxdouble)] return half*exp(|x|) */
112     if (ix < 0x40862E42)  return half*exp(fabs(x));
113 
114     /* |x| in [log(maxdouble), overflowthresold] */
115     lx = *( (((*(unsigned*)&one)>>29)) + (unsigned*)&x);
116     if (ix<0x408633CE ||
117             ((ix==0x408633ce)&&(lx<=(unsigned)0x8fb9f87d))) {
118         w = exp(half*fabs(x));
119         t = half*w;
120         return t*w;
121     }
122 
123     /* |x| > overflowthresold, cosh(x) overflow */
124     return huge*huge;
125 }
.fi
.SS "double exp (double x)"

.PP
Returns the exponential of x\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.6 
.RE
.PP
\fBDate:\fP
.RS 4
04/04/22
.RE
.PP
.PP
.nf

Method
  1\&. Argument reduction:
     Reduce x to an r so that |r| <= 0\&.5*ln2 ~ 0\&.34658\&.
 Given x, find r and integer k such that
.fi
.PP
.PP
.PP
.nf
              x = k*ln2 + r,  |r| <= 0\&.5*ln2\&.
.fi
.PP
.PP
.PP
.nf
     Here r will be represented as r = hi-lo for better
 accuracy\&.
.fi
.PP
.PP
.PP
.nf
  2\&. Approximation of exp(r) by a special rational function on
 the interval [0,0\&.34658]:
 Write
     R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + \&.\&.\&.
     We use a special Remes algorithm on [0,0\&.34658] to generate
    a polynomial of degree 5 to approximate R\&. The maximum error
 of this polynomial approximation is bounded by 2**-59\&. In
 other words,
     R(z) ~ 2\&.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
    (where z=r*r, and the values of P1 to P5 are listed below)
 and
     |                  5          |     -59
     | 2\&.0+P1*z+\&.\&.\&.+P5*z   -  R(z) | <= 2
     |                             |
 The computation of exp(r) thus becomes
                            2*r
    exp(r) = 1 + -------
                  R - r
                                r*R1(r)
           = 1 + r + ----------- (for better accuracy)
                      2 - R1(r)
 where
                 2       4             10
    R1(r) = r - (P1*r  + P2*r  + \&.\&.\&. + P5*r   )\&.
.fi
.PP
.PP
.PP
.nf
  3\&. Scale back to obtain exp(x):
 From step 1, we have
    exp(x) = 2^k * exp(r)
.fi
.PP
.PP
.PP
.nf
Special cases:
 exp(INF) is INF, exp(NaN) is NaN;
 exp(-INF) is 0, and
 for finite argument, only exp(0)=1 is exact\&.
.fi
.PP
.PP
.PP
.nf
Accuracy:
 according to an error analysis, the error is always less than
 1 ulp (unit in the last place)\&.
.fi
.PP
.PP
.PP
.nf
Misc\&. info\&.
 For IEEE double
     if x >  7\&.09782712893383973096e+02 then exp(x) overflow
     if x < -7\&.45133219101941108420e+02 then exp(x) underflow
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 134 of file exp\&.c\&.
.PP
References halF, huge, invln2, ln2HI, ln2LO, o_threshold, one, P1, P2, P3, P4, P5, twom1000, and u_threshold\&.
.PP
Referenced by cchsh(), cexp(), cosh(), cpow(), and sinh()\&.
.PP
.nf
135 {
136     double y,hi,lo,c,t;
137     sword k,xsb;
138     uword hx;
139 
140     lo = 0\&.0;
141     hi = 0\&.0;
142 
143     GET_HIGH_WORD(hx,x);    /* high word of x */
144     xsb = (hx>>31)&1;       /* sign bit of x */
145     hx &= 0x7fffffff;       /* high word of |x| */
146 
147     /* filter out non-finite argument */
148     if(hx >= 0x40862E42) {          /* if |x|>=709\&.78\&.\&.\&. */
149         if(hx>=0x7ff00000) {
150             uword lx;
151             GET_LOW_WORD(lx,x);
152             if(((hx&0xfffff)|lx)!=0)
153                 return x+x;             /* NaN */
154             else return (xsb==0)? x:0\&.0; /* exp(+-inf)={inf,0} */
155         }
156         if(x > o_threshold) return huge*huge; /* overflow */
157         if(x < u_threshold) return twom1000*twom1000; /* underflow */
158     }
159 
160     /* argument reduction */
161     if(hx > 0x3fd62e42) {       /* if  |x| > 0\&.5 ln2 */
162         if(hx < 0x3FF0A2B2) {       /* and |x| < 1\&.5 ln2 */
163             hi = x-ln2HI[xsb];
164             lo=ln2LO[xsb];
165             k = 1-xsb-xsb;
166         } else {
167             k  = (sword)(invln2*x+halF[xsb]);
168             t  = k;
169             hi = x - t*ln2HI[0];    /* t*ln2HI is exact here */
170             lo = t*ln2LO[0];
171         }
172         x  = hi - lo;
173     }
174     else if(hx < 0x3e300000)  {     /* when |x|<2**-28 */
175         if(huge+x>one) {
176             return one+x;   /* trigger inexact */
177         } else {
178             k = 0;
179         }
180     }
181     else k = 0;
182 
183     /* x is now in primary range */
184     t  = x*x;
185     c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
186     if(k==0)    return one-((x*c)/(c-2\&.0)-x);
187     else        y = one-((lo-(x*c)/(2\&.0-c))-hi);
188     if(k >= -1021) {
189         uword hy;
190         GET_HIGH_WORD(hy, y);
191         SET_HIGH_WORD(y, hy + (k<<20)); /* add k to y's exponent */
192         return y;
193     } else {
194         uword hy;
195         GET_HIGH_WORD(hy, y);
196         SET_HIGH_WORD(y, hy + ((k+1000)<<20));/* add k to y's exponent */
197         return y*twom1000;
198     }
199 }
.fi
.SS "double expm1 (double x)"

.PP
Definition at line 156 of file expm1\&.c\&.
.PP
References huge, invln2, ln2_hi, ln2_lo, o_threshold, one, Q1, Q2, Q3, Q4, Q5, and tiny\&.
.PP
Referenced by cosh(), sinh(), and tanh()\&.
.PP
.nf
157 {
158     double y,hi,lo,c,t,e,hxs,hfx,r1;
159     sword k,xsb;
160     uword hx;
161 
162     c = 0\&.0;
163 
164     GET_HIGH_WORD(hx,x); /* high word of x */
165     xsb = hx&0x80000000;        /* sign bit of x */
166     if(xsb==0) y=x;
167     else y= -x; /* y = |x| */
168     hx &= 0x7fffffff;       /* high word of |x| */
169 
170     /* filter out huge and non-finite argument */
171     if(hx >= 0x4043687A) {          /* if |x|>=56*ln2 */
172         if(hx >= 0x40862E42) {      /* if |x|>=709\&.78\&.\&.\&. */
173             if(hx>=0x7ff00000) {
174                 uword low;
175                 GET_LOW_WORD(low,x);
176                 if(((hx&0xfffff)|low)!=0)
177                     return x+x;      /* NaN */
178                 else return (xsb==0)? x:-1\&.0;/* exp(+-inf)={inf,-1} */
179             }
180             if(x > o_threshold) return huge*huge; /* overflow */
181         }
182         if(xsb!=0) { /* x < -56*ln2, return -1\&.0 with inexact */
183             if(x+tiny<0\&.0)       /* raise inexact */
184                 return tiny-one;    /* return -1 */
185         }
186     }
187 
188     /* argument reduction */
189     if(hx > 0x3fd62e42) {       /* if  |x| > 0\&.5 ln2 */
190         if(hx < 0x3FF0A2B2) {   /* and |x| < 1\&.5 ln2 */
191             if(xsb==0)
192             {
193                 hi = x - ln2_hi;
194                 lo =  ln2_lo;
195                 k =  1;
196             }
197             else
198             {
199                 hi = x + ln2_hi;
200                 lo = -ln2_lo;
201                 k = -1;
202             }
203         } else {
204             k  = (sword)(invln2*x+((xsb==0)?0\&.5:-0\&.5));
205             t  = k;
206             hi = x - t*ln2_hi;  /* t*ln2_hi is exact here */
207             lo = t*ln2_lo;
208         }
209         x  = hi - lo;
210         c  = (hi-x)-lo;
211     }
212     else if(hx < 0x3c900000) {      /* when |x|<2**-54, return x */
213         t = huge+x; /* return x with inexact flags when x!=0 */
214         return x - (t-(huge+x));
215     }
216     else k = 0;
217 
218     /* x is now in primary range */
219     hfx = 0\&.5*x;
220     hxs = x*hfx;
221     r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));
222     t  = 3\&.0-r1*hfx;
223     e  = hxs*((r1-t)/(6\&.0 - x*t));
224     if(k==0) return x - (x*e-hxs);      /* c is 0 */
225     else {
226         e  = (x*(e-c)-c);
227         e -= hxs;
228         if(k== -1) return 0\&.5*(x-e)-0\&.5;
229         if(k==1) {
230             if(x < -0\&.25) return -2\&.0*(e-(x+0\&.5));
231             else          return  one+2\&.0*(x-e);
232         }
233         if (k <= -2 || k>56) {   /* suffice to return exp(x)-1 */
234             uword hy;
235 
236             y = one-(e-x);
237             GET_HIGH_WORD(hy,y);
238             SET_HIGH_WORD(y, hy + (k<<20)); /* add k to y's exponent */
239             return y-one;
240         }
241         t = one;
242         if(k<20) {
243             uword hy;
244 
245             SET_HIGH_WORD(t, 0x3ff00000 - (0x200000>>k));  /* t=1-2^-k */
246             y = t-(e-x);
247             GET_HIGH_WORD(hy, y);
248             SET_HIGH_WORD(y, hy + (k<<20)); /* add k to y's exponent */
249         } else {
250             uword hy;
251 
252             SET_HIGH_WORD(t, (0x3ff-k)<<20);    /* 2^-k */
253             y = x-(e+t);
254             y += one;
255             GET_HIGH_WORD(hy, y);
256             SET_HIGH_WORD(y, hy + (k<<20)); /* add k to y's exponent */
257         }
258     }
259     return y;
260 }
.fi
.SS "double fabs (double x)"

.PP
Returns the absolute value of x\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18 
.RE
.PP

.PP
Definition at line 51 of file fabs\&.c\&.
.PP
.nf
52 {
53     uword hx;
54     GET_HIGH_WORD(hx,x);
55     SET_HIGH_WORD(x, hx & 0x7fffffff);
56     return x;
57 }
.fi
.SS "int finite (double x)"

.PP
Finite or infinite number\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
finite(x) returns 1 is x is finite, else 0\&. NOTICE: No branching! 
.PP
Definition at line 53 of file finite\&.c\&.
.PP
Referenced by PositionalNumeralSystem::GetText(), and RealNumber::IsFinite()\&.
.PP
.nf
54 {
55     uword hx;
56     GET_HIGH_WORD(hx,x);
57     return (unsigned)((hx&0x7fffffff)-0x7ff00000)>>31;
58 }
.fi
.SS "double floor (double x)"

.PP
Mathematical floor function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return x rounded toward -inf to integral value
Method:
 Bit twiddling\&.
Exception:
 Inexact flag raised if x not equal to floor(x)\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 66 of file floor\&.c\&.
.PP
References huge\&.
.PP
.nf
67 {
68     sword i0,i1,j0;
69     uword i,j;
70     EXTRACT_WORDS(i0,i1,x);
71     j0 = ((i0>>20)&0x7ff)-0x3ff;
72     if(j0<20) {
73         if(j0<0) {  /* raise inexact if x != 0 */
74             if(huge+x>0\&.0) {/* return 0*sign(x) if |x|<1 */
75                 if(i0>=0) {
76                     i0=i1=0;
77                 }
78                 else if(((i0&0x7fffffff)|i1)!=0)
79                 {
80                     i0=0xbff00000;
81                     i1=0;
82                 }
83             }
84         } else {
85             i = (0x000fffff)>>j0;
86             if(((i0&i)|i1)==0) return x; /* x is integral */
87             if(huge+x>0\&.0) { /* raise inexact flag */
88                 if(i0<0) i0 += (0x00100000)>>j0;
89                 i0 &= (~i);
90                 i1=0;
91             }
92         }
93     } else if (j0>51) {
94         if(j0==0x400) return x+x;   /* inf or NaN */
95         else return x;      /* x is integral */
96     } else {
97         i = ((uword)(0xffffffff))>>(j0-20);
98         if((i1&i)==0) return x; /* x is integral */
99         if(huge+x>0\&.0) {         /* raise inexact flag */
100             if(i0<0) {
101                 if(j0==20) i0+=1;
102                 else {
103                     j = i1+(1<<(52-j0));
104                     if(j<(uword)i1) i0 +=1 ;    /* got a carry */
105                     i1=j;
106                 }
107             }
108             i1 &= (~i);
109         }
110     }
111     INSERT_WORDS(x,i0,i1);
112     return x;
113 }
.fi
.SS "double fmod (double x, double y)"

.PP
Return x mod y in exact arithmetic\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
Method: shift and subtract 
.PP
Definition at line 58 of file fmod\&.c\&.
.PP
References one, and Zero\&.
.PP
.nf
59 {
60     sword n,hx,hy,hz,ix,iy,sx,i;
61     uword lx,ly,lz;
62 
63     EXTRACT_WORDS(hx,lx,x);
64     EXTRACT_WORDS(hy,ly,y);
65     sx = hx&0x80000000;     /* sign of x */
66     hx ^=sx;        /* |x| */
67     hy &= 0x7fffffff;   /* |y| */
68 
69     /* purge off exception values */
70     if((hy|ly)==0||(hx>=0x7ff00000)||   /* y=0,or x not finite */
71             ((hy|((ly|-ly)>>31))>0x7ff00000))   /* or y is NaN */
72         return (x*y)/(x*y);
73     if(hx<=hy) {
74         if((hx<hy)||(lx<ly)) return x;  /* |x|<|y| return x */
75         if(lx==ly)
76             return Zero[(uword)sx>>31]; /* |x|=|y| return x*0*/
77     }
78 
79     /* determine ix = ilogb(x) */
80     if(hx<0x00100000) { /* subnormal x */
81         if(hx==0) {
82             for (ix = -1043, i=lx; i>0; i<<=1) ix -=1;
83         } else {
84             for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;
85         }
86     } else ix = (hx>>20)-1023;
87 
88     /* determine iy = ilogb(y) */
89     if(hy<0x00100000) { /* subnormal y */
90         if(hy==0) {
91             for (iy = -1043, i=ly; i>0; i<<=1) iy -=1;
92         } else {
93             for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;
94         }
95     } else iy = (hy>>20)-1023;
96 
97     /* set up {hx,lx}, {hy,ly} and align y to x */
98     if(ix >= -1022)
99         hx = 0x00100000|(0x000fffff&hx);
100     else {      /* subnormal x, shift x to normal */
101         n = -1022-ix;
102         if(n<=31) {
103             hx = (hx<<n)|(lx>>(32-n));
104             lx <<= n;
105         } else {
106             hx = lx<<(n-32);
107             lx = 0;
108         }
109     }
110     if(iy >= -1022)
111         hy = 0x00100000|(0x000fffff&hy);
112     else {      /* subnormal y, shift y to normal */
113         n = -1022-iy;
114         if(n<=31) {
115             hy = (hy<<n)|(ly>>(32-n));
116             ly <<= n;
117         } else {
118             hy = ly<<(n-32);
119             ly = 0;
120         }
121     }
122 
123     /* fix point fmod */
124     n = ix - iy;
125     while(n--) {
126         hz=hx-hy;
127         lz=lx-ly;
128         if(lx<ly) hz -= 1;
129         if(hz<0) {
130             hx = hx+hx+(lx>>31);
131             lx = lx+lx;
132         }
133         else {
134             if((hz|lz)==0)      /* return sign(x)*0 */
135                 return Zero[(uword)sx>>31];
136             hx = hz+hz+(lz>>31);
137             lx = lz+lz;
138         }
139     }
140     hz=hx-hy;
141     lz=lx-ly;
142     if(lx<ly) hz -= 1;
143     if(hz>=0) {
144         hx=hz;
145         lx=lz;
146     }
147 
148     /* convert back to floating value and restore the sign */
149     if((hx|lx)==0)          /* return sign(x)*0 */
150         return Zero[(unsigned)sx>>31];
151     while(hx<0x00100000) {      /* normalize x */
152         hx = hx+hx+(lx>>31);
153         lx = lx+lx;
154         iy -= 1;
155     }
156     if(iy>= -1022) {    /* normalize output */
157         hx = ((hx-0x00100000)|((iy+1023)<<20));
158         INSERT_WORDS(x,hx|sx,lx);
159     } else {        /* subnormal output */
160         n = -1022 - iy;
161         if(n<=20) {
162             lx = (lx>>n)|((uword)hx<<(32-n));
163             hx >>= n;
164         } else if (n<=31) {
165             lx = (hx<<(32-n))|(lx>>n);
166             hx = sx;
167         } else {
168             lx = hx>>(n-32);
169             hx = sx;
170         }
171         INSERT_WORDS(x,hx|sx,lx);
172         x *= one;       /* create necessary signal */
173     }
174     return x;       /* exact output */
175 }
.fi
.SS "double hypot (double x, double y)"

.PP
Definition at line 79 of file hypot\&.c\&.
.PP
References sqrt()\&.
.PP
Referenced by cabs()\&.
.PP
.nf
80 {
81     double a=x,b=y,t1,t2,y1,y2,w;
82     uword j,k,ha,hb,hx,hy;
83 
84     GET_HIGH_WORD(hx,x);
85     GET_HIGH_WORD(hy,y);
86     ha = hx&0x7fffffff; /* high word of  x */
87     hb = hy&0x7fffffff; /* high word of  y */
88     if(hb > ha) {
89         a=y;
90         b=x;
91         j=ha;
92         ha=hb;
93         hb=j;
94     }
95     else {
96         a=x;
97         b=y;
98     }
99     SET_HIGH_WORD(a,ha); /* a <- |a| */
100     SET_HIGH_WORD(b,hb); /* b <- |b| */
101     if((ha-hb)>0x3c00000) {
102         return a+b;   /* x/y > 2**60 */
103     }
104     k=0;
105     if(ha > 0x5f300000) {   /* a>2**500 */
106         if(ha >= 0x7ff00000) {  /* Inf or NaN */
107             uword la, lb;
108             w = a+b;            /* for sNaN */
109             GET_LOW_WORD(la,a);
110             GET_LOW_WORD(lb,b);
111             if(((ha&0xfffff)|la)==0) w = a;
112             if(((hb^0x7ff00000)|lb)==0) w = b;
113             return w;
114         }
115         /* scale a and b by 2**-600 */
116         ha -= 0x25800000;
117         hb -= 0x25800000;
118         k += 600;
119         SET_HIGH_WORD(a,ha);
120         SET_HIGH_WORD(b,hb);
121     }
122     if(hb < 0x20b00000) {   /* b < 2**-500 */
123         if(hb <= 0x000fffff) {  /* subnormal b or 0 */
124             uword lb;
125             GET_LOW_WORD(lb,b);
126             if((hb|lb)==0) return a;
127             t1=0;
128             SET_HIGH_WORD(t1, 0x7fd00000);  /* t1=2^1022 */
129             b *= t1;
130             a *= t1;
131             k -= 1022;
132         } else {        /* scale a and b by 2^600 */
133             ha += 0x25800000;   /* a *= 2^600 */
134             hb += 0x25800000;   /* b *= 2^600 */
135             k -= 600;
136 
137             SET_HIGH_WORD(a,ha);
138             SET_HIGH_WORD(b,hb);
139         }
140     }
141     /* medium size a and b */
142     w = a-b;
143     if (w>b) {
144         t1 = 0;
145         SET_HIGH_WORD(t1, ha);
146         t2 = a-t1;
147         w  = sqrt(t1*t1-(b*(-b)-t2*(a+t1)));
148     } else {
149         a  = a+a;
150         y1 = 0;
151         SET_HIGH_WORD(y1, hb);
152         y2 = b - y1;
153         t1 = 0;
154         SET_HIGH_WORD(t1, ha+0x00100000);
155         t2 = a - t1;
156         w  = sqrt(t1*y1-(w*(-w)-(t1*y2+t2*b)));
157     }
158     if(k!=0) {
159         uword ht1;
160 
161         t1 = 1\&.0;
162         GET_HIGH_WORD(ht1, t1);
163         SET_HIGH_WORD(t1, ht1 + (k<<20));
164         return t1*w;
165     } else return w;
166 }
.fi
.SS "int isnan (double x)"

.PP
isnan(x) returns 1 is x is nan, else 0\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
NOTICE: No branching! 
.PP
Definition at line 49 of file isnan\&.c\&.
.PP
Referenced by PositionalNumeralSystem::GetText(), and RealNumber::IsNaN()\&.
.PP
.nf
50 {
51     return ((x) != (x));
52 }
.fi
.SS "double log (double x)"

.PP
Natural logarithm function (base e)\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.4 
.RE
.PP
\fBDate:\fP
.RS 4
96/03/07
.RE
.PP
.PP
.nf

Method :
  1\&. Argument Reduction: find k and f such that
        x = 2^k * (1+f),
    where  sqrt(2)/2 < 1+f < sqrt(2) \&.
.fi
.PP
.PP
.PP
.nf
  2\&. Approximation of log(1+f)\&.
 Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
     = 2s + 2/3 s**3 + 2/5 s**5 + \&.\&.\&.\&.\&.,
         = 2s + s*R
     We use a special Remes algorithm on [0,0\&.1716] to generate
    a polynomial of degree 14 to approximate R The maximum error
 of this polynomial approximation is bounded by 2**-58\&.45\&. In
 other words,
            2      4      6      8      10      12      14
     R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
    (the values of Lg1 to Lg7 are listed in the program)
 and
     |      2          14          |     -58\&.45
     | Lg1*s +\&.\&.\&.+Lg7*s    -  R(z) | <= 2
     |                             |
 Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2\&.
 In order to guarantee error in log below 1ulp, we compute log
 by
    log(1+f) = f - s*(f - R)    (if f is not too large)
    log(1+f) = f - (hfsq - s*(hfsq+R))\&. (better accuracy)
.fi
.PP
.PP
.PP
.nf
 3\&. Finally,  log(x) = k*ln2 + log(1+f)\&.
            = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
    Here ln2 is split into two floating point number:
        ln2_hi + ln2_lo,
    where n*ln2_hi is always exact for |n| < 2000\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 log(x) is NaN with signal if x < 0 (including -INF) ;
 log(+INF) is +INF; log(0) is -INF with signal;
 log(NaN) is that NaN with no signal\&.
.fi
.PP
.PP
.PP
.nf
Accuracy:
 according to an error analysis, the error is always less than
 1 ulp (unit in the last place)\&.
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 118 of file log\&.c\&.
.PP
References Lg1, Lg2, Lg3, Lg4, Lg5, Lg6, Lg7, ln2_hi, ln2_lo, two54, and zero\&.
.PP
.nf
119 {
120     double hfsq,f,s,z,R,w,t1,t2,dk;
121     sword k,hx,i,j;
122     uword lx;
123 
124     EXTRACT_WORDS(hx,lx,x);
125 
126     k=0;
127     if (hx < 0x00100000) {          /* x < 2**-1022  */
128         if (((hx&0x7fffffff)|lx)==0)
129             return -two54/zero;     /* log(+-0)=-inf */
130         if (hx<0) return (x-x)/zero;    /* log(-#) = NaN */
131         k -= 54;
132         x *= two54; /* subnormal number, scale up x */
133         GET_HIGH_WORD(hx,x);        /* high word of x */
134     }
135     if (hx >= 0x7ff00000) return x+x;
136     k += (hx>>20)-1023;
137     hx &= 0x000fffff;
138     i = (hx+0x95f64)&0x100000;
139     SET_HIGH_WORD(x,hx|(i^0x3ff00000)); /* normalize x or x/2 */
140     k += (i>>20);
141     f = x-1\&.0;
142     if((0x000fffff&(2+hx))<3) { /* |f| < 2**-20 */
143         if(f==zero) {
144             if(k==0)
145                 return zero;
146             else {
147                 dk=(double)k;
148                 return dk*ln2_hi+dk*ln2_lo;
149             }
150         }
151         R = f*f*(0\&.5-0\&.33333333333333333*f);
152         if(k==0) return f-R;
153         else {
154             dk=(double)k;
155             return dk*ln2_hi-((R-dk*ln2_lo)-f);
156         }
157     }
158     s = f/(2\&.0+f);
159     dk = (double)k;
160     z = s*s;
161     i = hx-0x6147a;
162     w = z*z;
163     j = 0x6b851-hx;
164     t1= w*(Lg2+w*(Lg4+w*Lg6));
165     t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
166     i |= j;
167     R = t2+t1;
168     if(i>0) {
169         hfsq=0\&.5*f*f;
170         if(k==0) return f-(hfsq-s*(hfsq+R));
171         else
172             return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
173     } else {
174         if(k==0) return f-s*(f-R);
175         else
176             return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
177     }
178 }
.fi
.SS "double log10 (double x)"

.PP
Base 10 logarithm function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
 Let log10_2hi = leading 40 bits of log10(2) and
     log10_2lo = log10(2) - log10_2hi,
     ivln10   = 1/log(10) rounded\&.
 Then
    n = ilogb(x),
    if(n<0)  n = n+1;
    x = scalbn(x,-n);
    log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))
.fi
.PP
.PP
.PP
.nf
Note 1:
 To guarantee log10(10**n)=n, where 10**n is normal, the rounding
 mode must set to Round-to-Nearest\&.
Note 2:
 [1/log(10)] rounded to 53 bits has error  \&.198   ulps;
 log10 is monotonic at all binary break points\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 log10(x) is NaN with signal if x < 0;
 log10(+INF) is +INF with no signal; log10(0) is -INF with signal;
 log10(NaN) is that NaN with no signal;
 log10(10**N) = N  for N=0,1,\&.\&.\&.,22\&.
.fi
.PP
.PP
.PP
.nf
Constants:
The hexadecimal values are the intended ones for the following constants\&.
The decimal values may be used, provided that the compiler will convert
from decimal to binary accurately enough to produce the hexadecimal values
shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 95 of file log10\&.c\&.
.PP
References ivln10, log10_2hi, log10_2lo, two54, and zero\&.
.PP
Referenced by DecimalSystem::GetRealText(), and RealNumber::Log10()\&.
.PP
.nf
96 {
97     double y,z;
98     sword i,k,hx;
99     uword lx;
100 
101     EXTRACT_WORDS(hx,lx,x);
102 
103     k=0;
104     if (hx < 0x00100000) {                  /* x < 2**-1022  */
105         if (((hx&0x7fffffff)|lx)==0)
106             return -two54/zero;             /* log(+-0)=-inf */
107         if (hx<0) return (x-x)/zero;        /* log(-#) = NaN */
108         k -= 54;
109         x *= two54; /* subnormal number, scale up x */
110         GET_HIGH_WORD(hx, x);              /* high word of x */
111     }
112     if (hx >= 0x7ff00000) return x+x;
113     k += (hx>>20)-1023;
114     i  = ((uword)k&0x80000000)>>31;
115     hx = (hx&0x000fffff)|((0x3ff-i)<<20);
116     y  = (double)(k+i);
117     SET_HIGH_WORD(x,hx);
118     z  = y*log10_2lo + ivln10*log(x);
119     return  z+y*log10_2hi;
120 }
.fi
.SS "double log1p (double x)"

.PP
Definition at line 125 of file log1p\&.c\&.
.PP
References ln2_hi, ln2_lo, Lp1, Lp2, Lp3, Lp4, Lp5, Lp6, Lp7, two54, and zero\&.
.PP
Referenced by acosh(), asinh(), and atanh()\&.
.PP
.nf
126 {
127     double hfsq,f,c,s,z,R,u;
128     sword k,hx,hu,ax;
129 
130     f = 0\&.0;
131     c = 0\&.0;
132     hu = 0;
133 
134     GET_HIGH_WORD(hx,x); /* high word of x */
135     ax = hx&0x7fffffff;
136 
137     k = 1;
138     if (hx < 0x3FDA827A) {          /* x < 0\&.41422  */
139         if(ax>=0x3ff00000) {        /* x <= -1\&.0 */
140             if(x==-1\&.0) return -two54/zero; /* log1p(-1)=+inf */
141             else return (x-x)/(x-x);    /* log1p(x<-1)=NaN */
142         }
143         if(ax<0x3e200000) {         /* |x| < 2**-29 */
144             if(two54+x>zero         /* raise inexact */
145                     &&ax<0x3c900000)        /* |x| < 2**-54 */
146                 return x;
147             else
148                 return x - x*x*0\&.5;
149         }
150         if(hx>0||hx<=((int)0xbfd2bec3)) {
151             k=0;
152             f=x;
153             hu=1;
154         }   /* -0\&.2929<x<0\&.41422 */
155     }
156     if (hx >= 0x7ff00000) return x+x;
157     if(k!=0) {
158         if(hx<0x43400000) {
159             u  = 1\&.0+x;
160             GET_HIGH_WORD(hu,u); /* high word of u */
161             k  = (hu>>20)-1023;
162             c  = (k>0)? 1\&.0-(u-x):x-(u-1\&.0);/* correction term */
163             c /= u;
164         } else {
165             u  = x;
166             GET_HIGH_WORD(hu,u); /* high word of u */
167             k  = (hu>>20)-1023;
168             c  = 0;
169         }
170         hu &= 0x000fffff;
171         if(hu<0x6a09e) {
172             SET_HIGH_WORD(u, hu|0x3ff00000);    /* normalize u */
173         } else {
174             k += 1;
175             SET_HIGH_WORD(u, hu|0x3fe00000);    /* normalize u/2 */
176             hu = (0x00100000-hu)>>2;
177         }
178         f = u-1\&.0;
179     }
180     hfsq=0\&.5*f*f;
181     if(hu==0) { /* |f| < 2**-20 */
182         if(f==zero) {
183             if(k==0) return zero;
184             else {
185                 c += k*ln2_lo;
186                 return k*ln2_hi+c;
187             }
188         }
189         R = hfsq*(1\&.0-0\&.66666666666666666*f);
190         if(k==0) return f-R;
191         else
192             return k*ln2_hi-((R-(k*ln2_lo+c))-f);
193     }
194     s = f/(2\&.0+f);
195     z = s*s;
196     R = z*(Lp1+z*(Lp2+z*(Lp3+z*(Lp4+z*(Lp5+z*(Lp6+z*Lp7))))));
197     if(k==0) return f-(hfsq-s*(hfsq+R));
198     else
199         return k*ln2_hi-((hfsq-(s*(hfsq+R)+(k*ln2_lo+c)))-f);
200 }
.fi
.SS "double pow (double x, double y)"

.PP
Expontation function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method:  Let x =  2   * (1+f)
 1\&. Compute and return log2(x) in two pieces:
    log2(x) = w1 + w2,
    where w1 has 53-24 = 29 bit trailing zeros\&.
 2\&. Perform y*log2(x) = n+y' by simulating muti-precision
    arithmetic, where |y'|<=0\&.5\&.
 3\&. Return x**y = 2**n*exp(y'*log2)
.fi
.PP
.PP
.PP
.nf
Special cases:
 1\&.  (anything) ** 0  is 1
 2\&.  (anything) ** 1  is itself
 3\&.  (anything) ** NAN is NAN
 4\&.  NAN ** (anything except 0) is NAN
 5\&.  +-(|x| > 1) **  +INF is +INF
 6\&.  +-(|x| > 1) **  -INF is +0
 7\&.  +-(|x| < 1) **  +INF is +0
 8\&.  +-(|x| < 1) **  -INF is +INF
 9\&.  +-1         ** +-INF is NAN
 10\&. +0 ** (+anything except 0, NAN)               is +0
 11\&. -0 ** (+anything except 0, NAN, odd integer)  is +0
 12\&. +0 ** (-anything except 0, NAN)               is +INF
 13\&. -0 ** (-anything except 0, NAN, odd integer)  is +INF
 14\&. -0 ** (odd integer) = -( +0 ** (odd integer) )
 15\&. +INF ** (+anything except 0,NAN) is +INF
 16\&. +INF ** (-anything except 0,NAN) is +0
 17\&. -INF ** (anything)  = -0 ** (-anything)
 18\&. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
 19\&. (-anything except 0 and inf) ** (non-integer) is NAN
.fi
.PP
.PP
.PP
.nf
Accuracy:
 pow(x,y) returns x**y nearly rounded\&. In particular
        pow(integer,integer)
 always returns the correct integer provided it is
 representable\&.
.fi
.PP
.PP
.PP
.nf
Constants :
The hexadecimal values are the intended ones for the following
constants\&. The decimal values may be used, provided that the
compiler will convert from decimal to binary accurately enough
to produce the hexadecimal values shown\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 139 of file pow\&.c\&.
.PP
References bp, cp, cp_h, cp_l, dp_h, dp_l, huge, ivln2, ivln2_h, ivln2_l, L1, L2, L3, L4, L5, L6, lg2, lg2_h, lg2_l, one, ovt, P1, P2, P3, P4, P5, scalbn(), sqrt(), tiny, two, two53, and zero\&.
.PP
Referenced by cpow(), DecimalSystem::GetRealText(), PositionalNumeralSystem::GetText(), PositionalNumeralSystem::Parse(), and RealNumber::Raise()\&.
.PP
.nf
140 {
141     double z,ax,z_h,z_l,p_h,p_l;
142     double y1,t1,t2,r,s,t,u,v,w;
143     sword i0,i1,i,j,k,yisint,n;
144     sword hx,hy,ix,iy;
145     uword lx,ly;
146 
147     i0 = ((*(int*)&one)>>29)^1;
148     i1=1-i0;
149     EXTRACT_WORDS(hx,lx,x);
150     EXTRACT_WORDS(hy,ly,y);
151     ix = hx&0x7fffffff;
152     iy = hy&0x7fffffff;
153 
154     /* y==zero: x**0 = 1 */
155     if((iy|ly)==0) return one;
156 
157     /* +-NaN return x+y */
158     if(ix > 0x7ff00000 || ((ix==0x7ff00000)&&(lx!=0)) ||
159             iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0)))
160         return x+y;
161 
162     /* determine if y is an odd int when x < 0
163      * yisint = 0   \&.\&.\&. y is not an integer
164      * yisint = 1   \&.\&.\&. y is an odd int
165      * yisint = 2   \&.\&.\&. y is an even int
166      */
167     yisint  = 0;
168     if(hx<0) {
169         if(iy>=0x43400000) yisint = 2; /* even integer y */
170         else if(iy>=0x3ff00000) {
171             k = (iy>>20)-0x3ff;    /* exponent */
172             if(k>20) {
173                 j = ly>>(52-k);
174                 if((uword)(j<<(52-k))==ly) yisint = 2-(j&1);
175             } else if(ly==0) {
176                 j = iy>>(20-k);
177                 if((j<<(20-k))==iy) yisint = 2-(j&1);
178             }
179         }
180     }
181 
182     /* special value of y */
183     if(ly==0) {
184         if (iy==0x7ff00000) {   /* y is +-inf */
185             if(((ix-0x3ff00000)|lx)==0)
186                 return  y - y;  /* inf**+-1 is NaN */
187             else if (ix >= 0x3ff00000)/* (|x|>1)**+-inf = inf,0 */
188                 return (hy>=0)? y: zero;
189             else            /* (|x|<1)**-,+inf = inf,0 */
190                 return (hy<0)?-y: zero;
191         }
192         if(iy==0x3ff00000) {    /* y is  +-1 */
193             if(hy<0) return one/x;
194             else return x;
195         }
196         if(hy==0x40000000) return x*x; /* y is  2 */
197         if(hy==0x3fe00000) {    /* y is  0\&.5 */
198             if(hx>=0)   /* x >= +0 */
199                 return sqrt(x);
200         }
201     }
202 
203     ax   = fabs(x);
204     /* special value of x */
205     if(lx==0) {
206         if(ix==0x7ff00000||ix==0||ix==0x3ff00000) {
207             z = ax;         /*x is +-0,+-inf,+-1*/
208             if(hy<0) z = one/z; /* z = (1/|x|) */
209             if(hx<0) {
210                 if(((ix-0x3ff00000)|yisint)==0) {
211                     z = (z-z)/(z-z); /* (-1)**non-int is NaN */
212                 } else if(yisint==1)
213                     z = -z;     /* (x<0)**odd = -(|x|**odd) */
214             }
215             return z;
216         }
217     }
218 
219     n = (hx>>31)+1;
220 
221     /* (x<0)**(non-int) is NaN */
222     if((n|yisint)==0) return (x-x)/(x-x);
223 
224     s = one; /* s (sign of result -ve**odd) = -1 else = 1 */
225     if((n|(yisint-1))==0) s = -one;/* (-ve)**(odd int) */
226 
227     /* |y| is huge */
228     if(iy>0x41e00000) { /* if |y| > 2**31 */
229         if(iy>0x43f00000) { /* if |y| > 2**64, must o/uflow */
230             if(ix<=0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;
231             if(ix>=0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;
232         }
233         /* over/underflow if x is not close to one */
234         if(ix<0x3fefffff) return (hy<0)? s*huge*huge:s*tiny*tiny;
235         if(ix>0x3ff00000) return (hy>0)? s*huge*huge:s*tiny*tiny;
236         /* now |1-x| is tiny <= 2**-20, suffice to compute
237            log(x) by x-x^2/2+x^3/3-x^4/4 */
238         t = ax-one;     /* t has 20 trailing zeros */
239         w = (t*t)*(0\&.5-t*(0\&.3333333333333333333333-t*0\&.25));
240         u = ivln2_h*t;  /* ivln2_h has 21 sig\&. bits */
241         v = t*ivln2_l-w*ivln2;
242         t1 = u+v;
243         SET_LOW_WORD(t1,0);
244         t2 = v-(t1-u);
245     } else {
246         double ss,s2,s_h,s_l,t_h,t_l;
247         n = 0;
248         /* take care subnormal number */
249         if(ix<0x00100000)
250         {
251             ax *= two53;
252             n -= 53;
253             GET_HIGH_WORD(ix,ax);
254         }
255         n  += ((ix)>>20)-0x3ff;
256         j  = ix&0x000fffff;
257         /* determine interval */
258         ix = j|0x3ff00000;      /* normalize ix */
259         if(j<=0x3988E) k=0;     /* |x|<sqrt(3/2) */
260         else if(j<0xBB67A) k=1; /* |x|<sqrt(3)   */
261         else {
262             k=0;
263             n+=1;
264             ix -= 0x00100000;
265         }
266         SET_HIGH_WORD(ax,ix);
267 
268         /* compute ss = s_h+s_l = (x-1)/(x+1) or (x-1\&.5)/(x+1\&.5) */
269         u = ax-bp[k];       /* bp[0]=1\&.0, bp[1]=1\&.5 */
270         v = one/(ax+bp[k]);
271         ss = u*v;
272         s_h = ss;
273         SET_LOW_WORD(s_h,0);
274         /* t_h=ax+bp[k] High */
275         t_h = zero;
276         SET_HIGH_WORD(t_h,((ix>>1)|0x20000000)+0x00080000+(k<<18));
277         t_l = ax - (t_h-bp[k]);
278         s_l = v*((u-s_h*t_h)-s_h*t_l);
279         /* compute log(ax) */
280         s2 = ss*ss;
281         r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
282         r += s_l*(s_h+ss);
283         s2  = s_h*s_h;
284         t_h = 3\&.0+s2+r;
285         SET_LOW_WORD(t_h,0);
286         t_l = r-((t_h-3\&.0)-s2);
287         /* u+v = ss*(1+\&.\&.\&.) */
288         u = s_h*t_h;
289         v = s_l*t_h+t_l*ss;
290         /* 2/(3log2)*(ss+\&.\&.\&.) */
291         p_h = u+v;
292         SET_LOW_WORD(p_h,0);
293         p_l = v-(p_h-u);
294         z_h = cp_h*p_h;     /* cp_h+cp_l = 2/(3*log2) */
295         z_l = cp_l*p_h+p_l*cp+dp_l[k];
296         /* log2(ax) = (ss+\&.\&.)*2/(3*log2) = n + dp_h + z_h + z_l */
297         t = (double)n;
298         t1 = (((z_h+z_l)+dp_h[k])+t);
299         SET_LOW_WORD(t1,0);
300         t2 = z_l-(((t1-t)-dp_h[k])-z_h);
301     }
302 
303     /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
304     y1  = y;
305     SET_LOW_WORD(y1,0);
306     p_l = (y-y1)*t1+y*t2;
307     p_h = y1*t1;
308     z = p_l+p_h;
309     EXTRACT_WORDS(j,i,z);
310     if (j>=0x40900000) {                /* z >= 1024 */
311         if(((j-0x40900000)|i)!=0)           /* if z > 1024 */
312             return s*huge*huge;         /* overflow */
313         else {
314             if(p_l+ovt>z-p_h) return s*huge*huge;   /* overflow */
315         }
316     } else if((j&0x7fffffff)>=0x4090cc00 ) {    /* z <= -1075 */
317         if(((j-0xc090cc00)|i)!=0)       /* z < -1075 */
318             return s*tiny*tiny;     /* underflow */
319         else {
320             if(p_l<=z-p_h) return s*tiny*tiny;  /* underflow */
321         }
322     }
323     /*
324      * compute 2**(p_h+p_l)
325      */
326     i = j&0x7fffffff;
327     k = (i>>20)-0x3ff;
328     n = 0;
329     if(i>0x3fe00000) {      /* if |z| > 0\&.5, set n = [z+0\&.5] */
330         n = j+(0x00100000>>(k+1));
331         k = ((n&0x7fffffff)>>20)-0x3ff; /* new k for n */
332         t = zero;
333         SET_HIGH_WORD(t,(n&~(0x000fffff>>k)));
334         n = ((n&0x000fffff)|0x00100000)>>(20-k);
335         if(j<0) n = -n;
336         p_h -= t;
337     }
338     t = p_l+p_h;
339     SET_LOW_WORD(t,0);
340     u = t*lg2_h;
341     v = (p_l-(t-p_h))*lg2+t*lg2_l;
342     z = u+v;
343     w = v-(z-u);
344     t  = z*z;
345     t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
346     r  = (z*t1)/(t1-two)-(w+z*w);
347     z  = one-(r-z);
348     GET_HIGH_WORD(j,z);
349     j += (n<<20);
350     if((j>>20)<=0) z = scalbn(z,n); /* subnormal output */
351     else
352     {
353         uword hz;
354         GET_HIGH_WORD(hz,z);
355         SET_HIGH_WORD(z,hz + (n<<20));
356     }
357     return s*z;
358 }
.fi
.SS "int rempio2 (double x, double * y)"

.PP
Definition at line 103 of file remp2\&.c\&.
.PP
References __kernel_rem_pio2(), half, invpio2, npio2_hw, pio2_1, pio2_1t, pio2_2, pio2_2t, pio2_3, pio2_3t, two24, two_over_pi, and zero\&.
.PP
Referenced by cos(), sin(), and tan()\&.
.PP
.nf
104 {
105     double z = 0\&.,w,t,r,fn;
106     double tx[3];
107     sword i,j,n,ix,hx;
108     int e0,nx;
109     uword low;
110 
111     GET_HIGH_WORD(hx,x);        /* high word of x */
112     ix = hx&0x7fffffff;
113     if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
114     {
115         y[0] = x;
116         y[1] = 0;
117         return 0;
118     }
119     if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
120         if(hx>0) {
121             z = x - pio2_1;
122             if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
123                 y[0] = z - pio2_1t;
124                 y[1] = (z-y[0])-pio2_1t;
125             } else {        /* near pi/2, use 33+33+53 bit pi */
126                 z -= pio2_2;
127                 y[0] = z - pio2_2t;
128                 y[1] = (z-y[0])-pio2_2t;
129             }
130             return 1;
131         } else {    /* negative x */
132             z = x + pio2_1;
133             if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
134                 y[0] = z + pio2_1t;
135                 y[1] = (z-y[0])+pio2_1t;
136             } else {        /* near pi/2, use 33+33+53 bit pi */
137                 z += pio2_2;
138                 y[0] = z + pio2_2t;
139                 y[1] = (z-y[0])+pio2_2t;
140             }
141             return -1;
142         }
143     }
144     if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
145         t  = fabs(x);
146         n  = (sword) (t*invpio2+half);
147         fn = (double)n;
148         r  = t-fn*pio2_1;
149         w  = fn*pio2_1t;    /* 1st round good to 85 bit */
150         if(n<32&&ix!=npio2_hw[n-1]) {
151             y[0] = r-w; /* quick check no cancellation */
152         } else {
153             uword high;
154 
155             j  = ix>>20;
156             y[0] = r-w;
157             GET_HIGH_WORD(high, y[0]);
158             i = j-((high>>20)&0x7ff);
159             if(i>16) {  /* 2nd iteration needed, good to 118 */
160                 t  = r;
161                 w  = fn*pio2_2;
162                 r  = t-w;
163                 w  = fn*pio2_2t-((t-r)-w);
164                 y[0] = r-w;
165                 GET_HIGH_WORD(high,y[0]);
166                 i = j-((high>>20)&0x7ff);
167                 if(i>49)  { /* 3rd iteration need, 151 bits acc */
168                     t  = r; /* will cover all possible cases */
169                     w  = fn*pio2_3;
170                     r  = t-w;
171                     w  = fn*pio2_3t-((t-r)-w);
172                     y[0] = r-w;
173                 }
174             }
175         }
176         y[1] = (r-y[0])-w;
177         if(hx<0)    {
178             y[0] = -y[0];
179             y[1] = -y[1];
180             return -n;
181         }
182         else     return n;
183     }
184     /*
185      * all other (large) arguments
186      */
187     if(ix>=0x7ff00000) {        /* x is inf or NaN */
188         y[0]=y[1]=x-x;
189         return 0;
190     }
191     /* set z = scalbn(|x|,ilogb(x)-23) */
192     GET_LOW_WORD(low,x);
193     SET_LOW_WORD(z,low);
194     e0  = (sword)(ix>>20)-1046; /* e0 = ilogb(z)-23; */
195     SET_HIGH_WORD(z,ix - (e0<<20));
196     for(i=0; i<2; i++) {
197         tx[i] = (double)((sword)(z));
198         z     = (z-tx[i])*two24;
199     }
200     tx[2] = z;
201     nx = 3;
202     while(tx[nx-1]==zero) nx--; /* skip zero term */
203     n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
204     if(hx<0) {
205         y[0] = -y[0];
206         y[1] = -y[1];
207         return -n;
208     }
209     return n;
210 }
.fi
.SS "double round (double x)"

.PP
Definition at line 30 of file round\&.c\&.
.PP
Referenced by cround(), DecimalSystem::GetRealText(), PositionalNumeralSystem::GetText(), and RealNumber::Round()\&.
.PP
.nf
31 {
32     return x > 0\&.0 ? floor(x + 0\&.5) : ceil(x - 0\&.5);
33 }
.fi
.SS "double scalbn (double x, int n)"

.PP
Definition at line 60 of file scalbn\&.c\&.
.PP
References huge, tiny, two54, and twom54\&.
.PP
Referenced by __kernel_rem_pio2(), and pow()\&.
.PP
.nf
61 {
62     sword  k,hx,lx;
63     EXTRACT_WORDS(hx,lx,x);
64     k = (hx&0x7ff00000)>>20;        /* extract exponent */
65     if (k==0) {             /* 0 or subnormal x */
66         if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
67         x *= two54;
68         GET_HIGH_WORD(hx,x);
69         k = ((hx&0x7ff00000)>>20) - 54;
70         if (n< -50000) return tiny*x;   /*underflow*/
71     }
72     if (k==0x7ff) return x+x;       /* NaN or Inf */
73     k = k+n;
74     if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
75     if (k > 0)              /* normal result */
76     {
77         SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
78         return x;
79     }
80     if (k <= -54) {
81         if (n > 50000)      /* in case integer overflow in n+k */
82             return huge*copysign(huge,x);   /*overflow*/
83         else return tiny*copysign(tiny,x);  /*underflow*/
84     }
85     k += 54;                /* subnormal result */
86     SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
87     return x*twom54;
88 }
.fi
.SS "double sin (double x)"

.PP
Trigonometric sine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return sine function of x\&.
.fi
.PP
.PP
.PP
.nf
kernel function:
 __kernel_sin       \&.\&.\&. sine function on [-pi/4,pi/4]
 __kernel_cos       \&.\&.\&. cose function on [-pi/4,pi/4]
 __ieee754_rem_pio2 \&.\&.\&. argument reduction routine
.fi
.PP
.PP
.PP
.nf
Method\&.
     Let S,C and T denote the sin, cos and tan respectively on
 [-PI/4, +PI/4]\&. Reduce the argument x to y1+y2 = x-k*pi/2
 in [-pi/4 , +pi/4], and let n = k mod 4\&.
 We have
.fi
.PP
.PP
.PP
.nf
         n        sin(x)      cos(x)        tan(x)
    ----------------------------------------------------------
     0         S       C         T
     1         C      -S        -1/T
     2        -S      -C         T
     3        -C       S        -1/T
    ----------------------------------------------------------
.fi
.PP
.PP
.PP
.nf
Special cases:
     Let trig be any of sin, cos, or tan\&.
     trig(+-INF)  is NaN, with signals;
     trig(NaN)    is that NaN;
.fi
.PP
.PP
.PP
.nf
Accuracy:
 TRIG(x) returns trig(x) nearly rounded
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 87 of file sin\&.c\&.
.PP
References __kernel_cos(), __kernel_sin(), and rempio2()\&.
.PP
Referenced by ccos(), ccosh(), ccot(), ccoth(), ccsc(), ccsch(), cexp(), RealNumber::Cosecant(), cpow(), csec(), csech(), csin(), csinh(), ctan(), ctanh(), and RealNumber::Sine()\&.
.PP
.nf
88 {
89     double y[2],z=0\&.0;
90     sword n, ix;
91 
92     /* High word of x\&. */
93     GET_HIGH_WORD(ix,x);
94 
95     /* |x| ~< pi/4 */
96     ix &= 0x7fffffff;
97     if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);
98 
99     /* sin(Inf or NaN) is NaN */
100     else if (ix>=0x7ff00000) return x-x;
101 
102     /* argument reduction needed */
103     else {
104         n = rempio2(x,y);
105         switch(n&3) {
106         case 0:
107             return  __kernel_sin(y[0],y[1],1);
108         case 1:
109             return  __kernel_cos(y[0],y[1]);
110         case 2:
111             return -__kernel_sin(y[0],y[1],1);
112         default:
113             return -__kernel_cos(y[0],y[1]);
114         }
115     }
116 }
.fi
.SS "double sinh (double x)"

.PP
Hyperbolic sine function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Method :
mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
 1\&. Replace x by |x| (sinh(-x) = -sinh(x))\&.
 2\&.
                                        E + E/(E+1)
     0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)
                                2
.fi
.PP
.PP
.PP
.nf
     22       <= x <= lnovft :  sinh(x) := exp(x)/2
     lnovft   <= x <= ln2ovft:  sinh(x) := exp(x/2)/2 * exp(x/2)
     ln2ovft  <  x      :  sinh(x) := x*shuge (overflow)
.fi
.PP
.PP
.PP
.nf
Special cases:
 sinh(x) is |x| if x is +INF, -INF, or NaN\&.
 only sinh(0)=0 is exact for finite x\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 81 of file sinh\&.c\&.
.PP
References exp(), expm1(), one, and shuge\&.
.PP
Referenced by cchsh(), ccot(), ccoth(), ccsc(), ccsch(), csec(), csech(), ctan(), ctanh(), RealNumber::HypCosecant(), and RealNumber::HypSine()\&.
.PP
.nf
82 {
83     double t,w,h;
84     sword ix,jx;
85     uword lx;
86 
87     /* High word of |x|\&. */
88     GET_HIGH_WORD(jx,x);
89     ix = jx&0x7fffffff;
90 
91     /* x is INF or NaN */
92     if(ix>=0x7ff00000) return x+x;
93 
94     h = 0\&.5;
95     if (jx<0) h = -h;
96     /* |x| in [0,22], return sign(x)*0\&.5*(E+E/(E+1))) */
97     if (ix < 0x40360000) {      /* |x|<22 */
98         if (ix<0x3e300000)      /* |x|<2**-28 */
99             if(shuge+x>one) return x;/* sinh(tiny) = tiny with inexact */
100         t = expm1(fabs(x));
101         if(ix<0x3ff00000) return h*(2\&.0*t-t*t/(t+one));
102         return h*(t+t/(t+one));
103     }
104 
105     /* |x| in [22, log(maxdouble)] return 0\&.5*exp(|x|) */
106     if (ix < 0x40862E42)  return h*exp(fabs(x));
107 
108     /* |x| in [log(maxdouble), overflowthresold] */
109     lx = *( (((*(uword*)&one)>>29)) + (uword*)&x);
110     if (ix<0x408633CE || ((ix==0x408633ce)&&(lx<=(uword)0x8fb9f87d))) {
111         w = exp(0\&.5*fabs(x));
112         t = h*w;
113         return t*w;
114     }
115 
116     /* |x| > overflowthresold, sinh(x) overflow */
117     return x*shuge;
118 }
.fi
.SS "double sqrt (double x)"

.PP
Square root function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return correctly rounded sqrt\&.
          ------------------------------------------
      |  Use the hardware sqrt if you have one |
          ------------------------------------------
Method:
  Bit by bit method using integer arithmetic\&. (Slow, but portable)
  1\&. Normalization
 Scale x to y in [1,4) with even powers of 2:
 find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
    sqrt(x) = 2^k * sqrt(y)
  2\&. Bit by bit computation
 Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
      i                          0
                                    i+1         2
     s  = 2*q , and y  =  2   * ( y - q  )\&.     (1)
      i      i            i                 i
.fi
.PP
.PP
.PP
.nf
 To compute q    from q , one checks whether
        i+1       i
.fi
.PP
.PP
.PP
.nf
              -(i+1) 2
        (q + 2      ) <= y\&.         (2)
                  i
                              -(i+1)
 If (2) is false, then q   = q ; otherwise q   = q  + 2      \&.
               i+1   i             i+1   i
.fi
.PP
.PP
.PP
.nf
 With some algebric manipulation, it is not difficult to see
 that (2) is equivalent to
                            -(i+1)
        s  +  2       <= y          (3)
         i                i
.fi
.PP
.PP
.PP
.nf
 The advantage of (3) is that s  and y  can be computed by
                  i      i
 the following recurrence formula:
     if (3) is false
.fi
.PP
.PP
.PP
.nf
     s     =  s  ,  y    = y   ;            (4)
      i+1      i         i+1    i
.fi
.PP
.PP
.PP
.nf
     otherwise,
                        -i                     -(i+1)
     s    =  s  + 2  ,  y    = y  -  s  - 2         (5)
          i+1      i          i+1    i     i
.fi
.PP
.PP
.PP
.nf
 One may easily use induction to prove (4) and (5)\&.
 Note\&. Since the left hand side of (3) contain only i+2 bits,
       it does not necessary to do a full (53-bit) comparison
       in (3)\&.
  3\&. Final rounding
 After generating the 53 bits result, we compute one more bit\&.
 Together with the remainder, we can decide whether the
 result is exact, bigger than 1/2ulp, or less than 1/2ulp
 (it will never equal to 1/2ulp)\&.
 The rounding mode can be detected by checking whether
 huge + tiny is equal to huge, and whether huge - tiny is
 equal to huge for some floating point number 'huge' and 'tiny'\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 sqrt(+-0) = +-0    \&.\&.\&. exact
 sqrt(inf) = inf
 sqrt(-ve) = NaN        \&.\&.\&. with invalid signal
 sqrt(NaN) = NaN        \&.\&.\&. with invalid signal for signaling NaN
.fi
.PP
 Other methods : see the \fBsquareroot\fP\&.
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 127 of file sqrt\&.c\&.
.PP
References one, and tiny\&.
.PP
Referenced by acos(), acosh(), asin(), asinh(), csqrt(), hypot(), pow(), and RealNumber::SquareRoot()\&.
.PP
.nf
128 {
129     double z;
130     sword   sign = (int)0x80000000;
131     uword r,t1,s1,ix1,q1;
132     sword ix0,s0,q,m,t,i;
133 
134     EXTRACT_WORDS(ix0,ix1,x);
135 
136     /* take care of Inf and NaN */
137     if((ix0&0x7ff00000)==0x7ff00000) {
138         return x*x+x;       /* sqrt(NaN)=NaN, sqrt(+inf)=+inf
139                        sqrt(-inf)=sNaN */
140     }
141     /* take care of zero */
142     if(ix0<=0) {
143         if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
144         else if(ix0<0)
145             return (x-x)/(x-x);     /* sqrt(-ve) = sNaN */
146     }
147     /* normalize x */
148     m = (ix0>>20);
149     if(m==0) {              /* subnormal x */
150         while(ix0==0) {
151             m -= 21;
152             ix0 |= (ix1>>11);
153             ix1 <<= 21;
154         }
155         for(i=0; (ix0&0x00100000)==0; i++) ix0<<=1;
156         m -= i-1;
157         ix0 |= (ix1>>(32-i));
158         ix1 <<= i;
159     }
160     m -= 1023;  /* unbias exponent */
161     ix0 = (ix0&0x000fffff)|0x00100000;
162     if(m&1) {   /* odd m, double x to make it even */
163         ix0 += ix0 + ((ix1&sign)>>31);
164         ix1 += ix1;
165     }
166     m >>= 1;    /* m = [m/2] */
167 
168     /* generate sqrt(x) bit by bit */
169     ix0 += ix0 + ((ix1&sign)>>31);
170     ix1 += ix1;
171     q = q1 = s0 = s1 = 0;   /* [q,q1] = sqrt(x) */
172     r = 0x00200000;     /* r = moving bit from right to left */
173 
174     while(r!=0) {
175         t = s0+r;
176         if(t<=ix0) {
177             s0   = t+r;
178             ix0 -= t;
179             q   += r;
180         }
181         ix0 += ix0 + ((ix1&sign)>>31);
182         ix1 += ix1;
183         r>>=1;
184     }
185 
186     r = sign;
187     while(r!=0) {
188         t1 = s1+r;
189         t  = s0;
190         if((t<ix0)||((t==ix0)&&(t1<=ix1))) {
191             s1  = t1+r;
192             if(((t1&sign)==(uword)sign)&&(s1&sign)==0) s0 += 1;
193             ix0 -= t;
194             if (ix1 < t1) ix0 -= 1;
195             ix1 -= t1;
196             q1  += r;
197         }
198         ix0 += ix0 + ((ix1&sign)>>31);
199         ix1 += ix1;
200         r>>=1;
201     }
202 
203     /* use floating add to find out rounding direction */
204     if((ix0|ix1)!=0) {
205         z = one-tiny; /* trigger inexact flag */
206         if (z>=one) {
207             z = one+tiny;
208             if (q1==(uword)0xffffffff) {
209                 q1=0;
210                 q += 1;
211             }
212             else if (z>one) {
213                 if (q1==(uword)0xfffffffe) q+=1;
214                 q1+=2;
215             } else
216                 q1 += (q1&1);
217         }
218     }
219     ix0 = (q>>1)+0x3fe00000;
220     ix1 =  q1>>1;
221     if ((q&1)==1) ix1 |= sign;
222     ix0 += (m <<20);
223     INSERT_WORDS(z,ix0,ix1);
224     return z;
225 }
.fi
.SS "double tan (double x)"

.PP
Trigonometric tangent function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return tangent function of x\&.
.fi
.PP
.PP
.PP
.nf
kernel function:
 __kernel_tan       \&.\&.\&. tangent function on [-pi/4,pi/4]
 __rem_pio2     \&.\&.\&. argument reduction routine
.fi
.PP
.PP
.PP
.nf
Method\&.
     Let S,C and T denote the sin, cos and tan respectively on
 [-PI/4, +PI/4]\&. Reduce the argument x to y1+y2 = x-k*pi/2
 in [-pi/4 , +pi/4], and let n = k mod 4\&.
 We have
.fi
.PP
.PP
.PP
.nf
         n        sin(x)      cos(x)        tan(x)
    ----------------------------------------------------------
     0         S       C         T
     1         C      -S        -1/T
     2        -S      -C         T
     3        -C       S        -1/T
    ----------------------------------------------------------
.fi
.PP
.PP
.PP
.nf
Special cases:
     Let trig be any of sin, cos, or tan\&.
     trig(+-INF)  is NaN, with signals;
     trig(NaN)    is that NaN;
.fi
.PP
.PP
.PP
.nf
Accuracy:
 TRIG(x) returns trig(x) nearly rounded
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 86 of file tan\&.c\&.
.PP
References __kernel_tan(), and rempio2()\&.
.PP
Referenced by RealNumber::Cotangent(), and RealNumber::Tangent()\&.
.PP
.nf
87 {
88     double y[2],z=0\&.0;
89     sword n, ix;
90 
91     /* High word of x\&. */
92     GET_HIGH_WORD(ix,x);
93 
94     /* |x| ~< pi/4 */
95     ix &= 0x7fffffff;
96     if(ix <= 0x3fe921fb) return __kernel_tan(x,z,1);
97 
98     /* tan(Inf or NaN) is NaN */
99     else if (ix>=0x7ff00000) return x-x;        /* NaN */
100 
101     /* argument reduction needed */
102     else {
103         n = rempio2(x,y);
104         return __kernel_tan(y[0],y[1],1-((n&1)<<1)); /*  1 -- n even
105                             -1 -- n odd */
106     }
107 }
.fi
.SS "double tanh (double x)"

.PP
Hyperbolic tangent function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.3 
.RE
.PP
\fBDate:\fP
.RS 4
95/01/18
.RE
.PP
.PP
.nf

Return the Hyperbolic Tangent of x
.fi
.PP
.PP
.PP
.nf
Method :
                   x    -x
                  e  - e
 0\&. tanh(x) is defined to be -----------
                   x    -x
                  e  + e
 1\&. reduce x to non-negative by tanh(-x) = -tanh(x)\&.
 2\&.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)
                        -t
     2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)
                       t + 2
                         2
     1      <= x <=  22\&.0  : tanh(x) := 1-  ----- ; t=expm1(2x)
                       t + 2
     22\&.0   <  x <= INF    : tanh(x) := 1\&.
.fi
.PP
.PP
.PP
.nf
Special cases:
 tanh(NaN) is NaN;
 only tanh(0)=0 is exact for finite argument\&.
.fi
.PP
 
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP
Definition at line 83 of file tanh\&.c\&.
.PP
References expm1(), one, tiny, and two\&.
.PP
Referenced by RealNumber::HypCotangent(), and RealNumber::HypTangent()\&.
.PP
.nf
84 {
85     double t,z;
86     sword jx,ix;
87 
88     /* High word of |x|\&. */
89     GET_HIGH_WORD(jx,x);
90     ix = jx&0x7fffffff;
91 
92     /* x is INF or NaN */
93     if(ix>=0x7ff00000) {
94         if (jx>=0) return one/x+one;    /* tanh(+-inf)=+-1 */
95         else       return one/x-one;    /* tanh(NaN) = NaN */
96     }
97 
98     /* |x| < 22 */
99     if (ix < 0x40360000) {      /* |x|<22 */
100         if (ix<0x3c800000)      /* |x|<2**-55 */
101             return x*(one+x);       /* tanh(small) = small */
102         if (ix>=0x3ff00000) {   /* |x|>=1  */
103             t = expm1(two*fabs(x));
104             z = one - two/(t+two);
105         } else {
106             t = expm1(-two*fabs(x));
107             z= -t/(t+two);
108         }
109         /* |x| > 22, return +-1 */
110     } else {
111         z = one - tiny;     /* raised inexact flag */
112     }
113     return (jx>=0)? z: -z;
114 }
.fi
.SS "double trunc (double x)"

.PP
Definition at line 30 of file trunc\&.c\&.
.PP
Referenced by ctrunc(), DecimalSystem::GetRealText(), PositionalNumeralSystem::GetText(), PositionalNumeralSystem::IntegerToBuffer(), and RealNumber::Trunc()\&.
.PP
.nf
31 {
32     return x > 0\&.0 ? floor(x) : ceil(x);
33 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
