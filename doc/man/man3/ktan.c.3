.TH "lib/real/ktan.c" 3 "Fri Jan 20 2017" "Version 1.6.0" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/real/ktan.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'prim\&.h'\fP
.br
\fC#include 'math\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBone\fP   \fBxxx\fP[13]"
.br
.ti -1c
.RI "#define \fBpio4\fP   \fBxxx\fP[14]"
.br
.ti -1c
.RI "#define \fBpio4lo\fP   \fBxxx\fP[15]"
.br
.ti -1c
.RI "#define \fBT\fP   \fBxxx\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fB__kernel_tan\fP (double x, double y, int iy)"
.br
.RI "\fIKernel tan function\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const double \fBxxx\fP []"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define one   \fBxxx\fP[13]"

.PP
Definition at line 64 of file ktan\&.c\&.
.SS "#define pio4   \fBxxx\fP[14]"

.PP
Definition at line 65 of file ktan\&.c\&.
.SS "#define pio4lo   \fBxxx\fP[15]"

.PP
Definition at line 66 of file ktan\&.c\&.
.SS "#define T   \fBxxx\fP"

.PP
Definition at line 67 of file ktan\&.c\&.
.SH "Function Documentation"
.PP 
.SS "double __kernel_tan (double x, double y, int iy)"

.PP
Kernel tan function\&. 
.PP
\fBVersion:\fP
.RS 4
1\&.5 
.RE
.PP
\fBDate:\fP
.RS 4
04/04/22
.RE
.PP
Kernel tan function on [-pi/4, pi/4], pi/4 ~ 0\&.7854 Input x is assumed to be bounded by ~pi/4 in magnitude\&. Input y is the tail of x\&. Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned\&.
.PP
Algorithm
.IP "1." 4
Since tan(-x) = -tan(x), we need only to consider positive x\&.
.IP "2." 4
if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0\&.
.IP "3." 4
tan(x) is approximated by a odd polynomial of degree 27 on [0,0\&.67434] 3 27 tan(x) ~ x + T1*x + \&.\&.\&. + T13*x where 
.PP
.nf
    |tan(x)         2     4            26   |     -59.2
    |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2
    |  x                    |

.fi
.PP
.PP
Note: tan(x+y) = tan(x) + tan'(x)*y ~ tan(x) + (1+x*x)*y Therefore, for better accuracy in computing tan(x+y), let 3 2 2 2 2 r = x *(T2+x *(T3+x *(\&.\&.\&.+x *(T12+x *T13)))) then 3 2 tan(x+y) = x + (T1*x + (x *(r+y)+y))
.IP "  4." 6
For x in [0\&.67434,pi/4], let y = pi/4 - x, then tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y)) = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))  
.PP
\fBCopyright:\fP
.RS 4
Copyright (C) 1993 by Sun Microsystems, Inc\&. All rights reserved\&.  Developed at SunSoft, a Sun Microsystems, Inc\&. business\&. Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved\&. 
.RE
.PP

.PP

.PP

.PP
Definition at line 112 of file ktan\&.c\&.
.PP
Referenced by tan()\&.
.PP
.nf
112                                                 {
113     double z, r, v, w, s;
114     sword ix, hx;
115 
116     GET_HIGH_WORD(hx,x); /* high word of x */
117     ix = hx & 0x7fffffff;           /* high word of |x| */
118     if (ix < 0x3e300000) {          /* x < 2**-28 */
119         if ((int) x == 0) {     /* generate inexact */
120             uword low;
121             GET_LOW_WORD(low,x);
122             if (((ix | low) | (iy + 1)) == 0)
123                 return one / fabs(x);
124             else {
125                 if (iy == 1)
126                     return x;
127                 else {  /* compute -1 / (x+y) carefully */
128                     double a, t;
129 
130                     z = w = x + y;
131                     SET_LOW_WORD(z,0);
132                     v = y - (z - x);
133                     t = a = -one / w;
134                     SET_LOW_WORD(t,0);
135                     s = one + t * z;
136                     return t + a * (s + t * v);
137                 }
138             }
139         }
140     }
141     if (ix >= 0x3FE59428) { /* |x| >= 0\&.6744 */
142         if (hx < 0) {
143             x = -x;
144             y = -y;
145         }
146         z = pio4 - x;
147         w = pio4lo - y;
148         x = z + w;
149         y = 0\&.0;
150     }
151     z = x * x;
152     w = z * z;
153     /*
154      * Break x^5*(T[1]+x^2*T[2]+\&.\&.\&.) into
155      * x^5(T[1]+x^4*T[3]+\&.\&.\&.+x^20*T[11]) +
156      * x^5(x^2*(T[2]+x^4*T[4]+\&.\&.\&.+x^22*[T12]))
157      */
158     r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +
159                                             w * T[11]))));
160     v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +
161                                      w * T[12])))));
162     s = z * x;
163     r = y + z * (s * (r + v) + y);
164     r += T[0] * s;
165     w = x + r;
166     if (ix >= 0x3FE59428) {
167         v = (double) iy;
168         return (double) (1 - ((hx >> 30) & 2)) *
169                (v - 2\&.0 * (x - (w * w / (w + v) - r)));
170     }
171     if (iy == 1)
172         return w;
173     else {
174         /*
175          * if allow error up to 2 ulp, simply return
176          * -1\&.0 / (x+r) here
177          */
178         /* compute -1\&.0 / (x+r) accurately */
179         double a, t;
180         z = w;
181         SET_LOW_WORD(z,0);
182         v = r - (z - x);    /* z+v = r+x */
183         t = a = -1\&.0 / w;    /* a = -1\&.0/w */
184         SET_LOW_WORD(t,0);
185         s = 1\&.0 + t * z;
186         return t + a * (s + t * v);
187     }
188 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const double xxx[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    3\&.33333333333334091986e-01,  
    1\&.33333333333201242699e-01,  
    5\&.39682539762260521377e-02,  
    2\&.18694882948595424599e-02,  
    8\&.86323982359930005737e-03,  
    3\&.59207910759131235356e-03,  
    1\&.45620945432529025516e-03,  
    5\&.88041240820264096874e-04,  
    2\&.46463134818469906812e-04,  
    7\&.81794442939557092300e-05,  
    7\&.14072491382608190305e-05,  
    -1\&.85586374855275456654e-05, 
    2\&.59073051863633712884e-05,  
         1\&.00000000000000000000e+00, 
         7\&.85398163397448278999e-01, 
         3\&.06161699786838301793e-17  
}
.fi
.PP
Definition at line 45 of file ktan\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
