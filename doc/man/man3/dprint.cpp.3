.TH "lib/dconv/dprint.cpp" 3 "Tue Jan 24 2017" "Version 1.6.2" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/dconv/dprint.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'clib\&.h'\fP
.br
\fC#include 'dmath\&.h'\fP
.br
\fC#include 'dprint\&.h'\fP
.br
\fC#include 'dragon4\&.h'\fP
.br
\fC#include <dstandard\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "union \fBtFloatUnion32\fP"
.br
.ti -1c
.RI "union \fBtFloatUnion64\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBmemcpy\fP   \fBMemCopy\fP"
.br
.ti -1c
.RI "#define \fBmemmove\fP   \fBMemCopy\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBtU32\fP \fBFormatPositional\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtS32\fP exponent, \fBtU32\fP mantissaHighBitIdx, \fBtB\fP hasUnequalMargins, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.ti -1c
.RI "\fBtU32\fP \fBFormatScientific\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtS32\fP exponent, \fBtU32\fP mantissaHighBitIdx, \fBtB\fP hasUnequalMargins, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.ti -1c
.RI "static \fBtU32\fP \fBPrintHex\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP value, \fBtU32\fP width)"
.br
.ti -1c
.RI "static \fBtU32\fP \fBPrintInfNan\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtU32\fP mantissaHexWidth)"
.br
.ti -1c
.RI "\fBtU32\fP \fBPrintFloat32\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtF32\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.ti -1c
.RI "\fBtU32\fP \fBPrintFloat64\fP (\fBtC8\fP *pOutBuffer, \fBtU32\fP bufferSize, \fBtF64\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define memcpy   \fBMemCopy\fP"

.PP
Definition at line 59 of file dprint\&.cpp\&.
.SS "#define memmove   \fBMemCopy\fP"

.PP
Definition at line 60 of file dprint\&.cpp\&.
.SH "Function Documentation"
.PP 
.SS "\fBtU32\fP FormatPositional (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtS32\fP exponent, \fBtU32\fP mantissaHighBitIdx, \fBtB\fP hasUnequalMargins, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 112 of file dprint\&.cpp\&.
.PP
References CutoffMode_FractionLength, CutoffMode_Unique, Dragon4(), and MemCopy()\&.
.PP
Referenced by PrintFloat32(), and PrintFloat64()\&.
.PP
.nf
124 {
125     RJ_ASSERT(bufferSize > 0);
126 
127     tS32 printExponent;
128     tU32 numPrintDigits;
129 
130     tU32 maxPrintLen = bufferSize - 1;
131 
132     if (precision < 0)
133     {
134         numPrintDigits = Dragon4(   mantissa,
135                                     exponent,
136                                     mantissaHighBitIdx,
137                                     hasUnequalMargins,
138                                     CutoffMode_Unique,
139                                     0,
140                                     pOutBuffer,
141                                     maxPrintLen,
142                                     &printExponent );
143     }
144     else
145     {
146         numPrintDigits = Dragon4(   mantissa,
147                                     exponent,
148                                     mantissaHighBitIdx,
149                                     hasUnequalMargins,
150                                     CutoffMode_FractionLength,
151                                     precision,
152                                     pOutBuffer,
153                                     maxPrintLen,
154                                     &printExponent );
155     }
156 
157     RJ_ASSERT( numPrintDigits > 0 );
158     RJ_ASSERT( numPrintDigits <= bufferSize );
159 
160     // track the number of digits past the decimal point that have been printed
161     tU32 numFractionDigits = 0;
162 
163     // if output has a whole number
164     if (printExponent >= 0)
165     {
166         // leave the whole number at the start of the buffer
167         tU32 numWholeDigits = printExponent+1;
168         if (numPrintDigits < numWholeDigits)
169         {
170             // don't overflow the buffer
171             if (numWholeDigits > maxPrintLen)
172                 numWholeDigits = maxPrintLen;
173 
174             // add trailing zeros up to the decimal point
175             for ( ; numPrintDigits < numWholeDigits; ++numPrintDigits )
176                 pOutBuffer[numPrintDigits] = '0';
177         }
178         // insert the decimal point prior to the fraction
179         else if (numPrintDigits > (tU32)numWholeDigits)
180         {
181             numFractionDigits = numPrintDigits - numWholeDigits;
182             tU32 maxFractionDigits = maxPrintLen - numWholeDigits - 1;
183             if (numFractionDigits > maxFractionDigits)
184                 numFractionDigits = maxFractionDigits;
185 
186             memmove(pOutBuffer + numWholeDigits + 1, pOutBuffer + numWholeDigits, numFractionDigits);
187             pOutBuffer[numWholeDigits] = decimalPoint;
188             numPrintDigits = numWholeDigits + 1 + numFractionDigits;
189         }
190     }
191     else
192     {
193         // shift out the fraction to make room for the leading zeros
194         if (maxPrintLen > 2)
195         {
196             tU32 numFractionZeros = (tU32)-printExponent - 1;
197             tU32 maxFractionZeros = maxPrintLen - 2;
198             if (numFractionZeros > maxFractionZeros)
199                 numFractionZeros = maxFractionZeros;
200 
201             tU32 digitsStartIdx = 2 + numFractionZeros;
202 
203             // shift the significant digits right such that there is room for leading zeros
204             numFractionDigits = numPrintDigits;
205             tU32 maxFractionDigits = maxPrintLen - digitsStartIdx;
206             if (numFractionDigits > maxFractionDigits)
207                 numFractionDigits = maxFractionDigits;
208 
209             memmove(pOutBuffer + digitsStartIdx, pOutBuffer, numFractionDigits);
210 
211             // insert the leading zeros
212             for (tU32 i = 2; i < digitsStartIdx; ++i)
213                 pOutBuffer[i] = '0';
214 
215             // update the counts
216             numFractionDigits += numFractionZeros;
217             numPrintDigits = numFractionDigits;
218         }
219 
220         // add the decimal point
221         if (maxPrintLen > 1)
222         {
223             pOutBuffer[1] = decimalPoint;
224             numPrintDigits += 1;
225         }
226 
227         // add the initial zero
228         if (maxPrintLen > 0)
229         {
230             pOutBuffer[0] = '0';
231             numPrintDigits += 1;
232         }
233     }
234 
235     // add trailing zeros up to precision length
236     if (precision > (tS32)numFractionDigits && numPrintDigits < maxPrintLen)
237     {
238         // add a decimal point if this is the first fractional digit we are printing
239         if (numFractionDigits == 0)
240         {
241             pOutBuffer[numPrintDigits++] = decimalPoint;
242         }
243 
244         // compute the number of trailing zeros needed
245         tU32 totalDigits = numPrintDigits + (precision - numFractionDigits);
246         if (totalDigits > maxPrintLen)
247             totalDigits = maxPrintLen;
248 
249         for ( ; numPrintDigits < totalDigits; ++numPrintDigits )
250             pOutBuffer[numPrintDigits] = '0';
251     }
252 
253     // terminate the buffer
254     RJ_ASSERT( numPrintDigits <= maxPrintLen );
255     pOutBuffer[numPrintDigits] = '\0';
256 
257     return numPrintDigits;
258 }
.fi
.SS "\fBtU32\fP FormatScientific (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtS32\fP exponent, \fBtU32\fP mantissaHighBitIdx, \fBtB\fP hasUnequalMargins, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 266 of file dprint\&.cpp\&.
.PP
References CutoffMode_TotalLength, CutoffMode_Unique, Dragon4(), and MemCopy()\&.
.PP
Referenced by PrintFloat32(), and PrintFloat64()\&.
.PP
.nf
278 {
279     RJ_ASSERT(bufferSize > 0);
280 
281     tS32 printExponent;
282     tU32 numPrintDigits;
283 
284     if (precision < 0)
285     {
286         numPrintDigits = Dragon4(   mantissa,
287                                     exponent,
288                                     mantissaHighBitIdx,
289                                     hasUnequalMargins,
290                                     CutoffMode_Unique,
291                                     0,
292                                     pOutBuffer,
293                                     bufferSize,
294                                     &printExponent );
295     }
296     else
297     {
298         numPrintDigits = Dragon4(   mantissa,
299                                     exponent,
300                                     mantissaHighBitIdx,
301                                     hasUnequalMargins,
302                                     CutoffMode_TotalLength,
303                                     precision + 1,
304                                     pOutBuffer,
305                                     bufferSize,
306                                     &printExponent );
307     }
308 
309     RJ_ASSERT( numPrintDigits > 0 );
310     RJ_ASSERT( numPrintDigits <= bufferSize );
311 
312     tC8 * pCurOut = pOutBuffer;
313 
314     // keep the whole number as the first digit
315     if (bufferSize > 1)
316     {
317         pCurOut += 1;
318         bufferSize -= 1;
319     }
320 
321     // insert the decimal point prior to the fractional number
322     tU32 numFractionDigits = numPrintDigits-1;
323     if (numFractionDigits > 0 && bufferSize > 1)
324     {
325         tU32 maxFractionDigits = bufferSize-2;
326         if (numFractionDigits > maxFractionDigits)
327             numFractionDigits =  maxFractionDigits;
328 
329         memmove(pCurOut + 1, pCurOut, numFractionDigits);
330         pCurOut[0] = decimalPoint;
331         pCurOut += (1 + numFractionDigits);
332         bufferSize -= (1 + numFractionDigits);
333     }
334 
335     // add trailing zeros up to precision length
336     if (precision > (tS32)numFractionDigits && bufferSize > 1)
337     {
338         // add a decimal point if this is the first fractional digit we are printing
339         if (numFractionDigits == 0)
340         {
341             *pCurOut = decimalPoint;
342             ++pCurOut;
343             --bufferSize;
344         }
345 
346         // compute the number of trailing zeros needed
347         tU32 numZeros = (precision - numFractionDigits);
348         if (numZeros > bufferSize-1)
349             numZeros = bufferSize-1;
350 
351         for (tC8 * pEnd = pCurOut + numZeros; pCurOut < pEnd; ++pCurOut )
352             *pCurOut = '0';
353     }
354 
355     // print the exponent into a local buffer and copy into output buffer
356     if (bufferSize > 1)
357     {
358         tC8 exponentBuffer[5];
359         exponentBuffer[0] = 'e';
360         if (printExponent >= 0)
361         {
362             exponentBuffer[1] = '+';
363         }
364         else
365         {
366             exponentBuffer[1] = '-';
367             printExponent = -printExponent;
368         }
369 
370         RJ_ASSERT(printExponent < 1000);
371         tU32 hundredsPlace  = printExponent / 100;
372         tU32 tensPlace      = (printExponent - hundredsPlace*100) / 10;
373         tU32 onesPlace      = (printExponent - hundredsPlace*100 - tensPlace*10);
374 
375         exponentBuffer[2] = (tC8)('0' + hundredsPlace);
376         exponentBuffer[3] = (tC8)('0' + tensPlace);
377         exponentBuffer[4] = (tC8)('0' + onesPlace);
378 
379         // copy the exponent buffer into the output
380         tU32 maxExponentSize = bufferSize-1;
381         tU32 exponentSize = (5 < maxExponentSize) ? 5 : maxExponentSize;
382         memcpy( pCurOut, exponentBuffer, exponentSize );
383 
384         pCurOut += exponentSize;
385         bufferSize -= exponentSize;
386     }
387 
388     RJ_ASSERT( bufferSize > 0 );
389     pCurOut[0] = '\0';
390 
391     return pCurOut - pOutBuffer;
392 }
.fi
.SS "\fBtU32\fP PrintFloat32 (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtF32\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 465 of file dprint\&.cpp\&.
.PP
References FormatPositional(), FormatScientific(), tFloatUnion32::GetExponent(), tFloatUnion32::GetMantissa(), tFloatUnion32::IsNegative(), LogBase2(), tFloatUnion32::m_floatingPoint, PrintFloatFormat_Positional, PrintFloatFormat_Scientific, and PrintInfNan()\&.
.PP
.nf
475 {
476     if (bufferSize == 0)
477         return 0;
478 
479     if (bufferSize == 1)
480     {
481         pOutBuffer[0] = '\0';
482         return 1;
483     }
484 
485     // deconstruct the floating point value
486     tFloatUnion32 floatUnion;
487     floatUnion\&.m_floatingPoint = value;
488     tU32 floatExponent = floatUnion\&.GetExponent();
489     tU32 floatMantissa = floatUnion\&.GetMantissa();
490 
491     // output the sign
492     if (floatUnion\&.IsNegative())
493     {
494         pOutBuffer[0] = '-';
495         ++pOutBuffer;
496         --bufferSize;
497         RJ_ASSERT(bufferSize > 0);
498     }
499 
500     // if this is a special value
501     if (floatExponent == 0xFF)
502     {
503         return PrintInfNan(pOutBuffer, bufferSize, floatMantissa, 6);
504     }
505     // else this is a number
506     else
507     {
508         // factor the value into its parts
509         tU32 mantissa;
510         tS32 exponent;
511         tU32 mantissaHighBitIdx;
512         tB hasUnequalMargins;
513         if (floatExponent != 0)
514         {
515             // normalized
516             // The floating point equation is:
517             //  value = (1 + mantissa/2^23) * 2 ^ (exponent-127)
518             // We convert the integer equation by factoring a 2^23 out of the exponent
519             //  value = (1 + mantissa/2^23) * 2^23 * 2 ^ (exponent-127-23)
520             //  value = (2^23 + mantissa) * 2 ^ (exponent-127-23)
521             // Because of the implied 1 in front of the mantissa we have 24 bits of precision\&.
522             //   m = (2^23 + mantissa)
523             //   e = (exponent-127-23)
524             mantissa            = (1UL << 23) | floatMantissa;
525             exponent            = floatExponent - 127 - 23;
526             mantissaHighBitIdx  = 23;
527             hasUnequalMargins   = (floatExponent != 1) && (floatMantissa == 0);
528         }
529         else
530         {
531             // denormalized
532             // The floating point equation is:
533             //  value = (mantissa/2^23) * 2 ^ (1-127)
534             // We convert the integer equation by factoring a 2^23 out of the exponent
535             //  value = (mantissa/2^23) * 2^23 * 2 ^ (1-127-23)
536             //  value = mantissa * 2 ^ (1-127-23)
537             // We have up to 23 bits of precision\&.
538             //   m = (mantissa)
539             //   e = (1-127-23)
540             mantissa           = floatMantissa;
541             exponent           = 1 - 127 - 23;
542             mantissaHighBitIdx = LogBase2(mantissa);
543             hasUnequalMargins   = false;
544         }
545 
546         // format the value
547         switch (format)
548         {
549         case PrintFloatFormat_Positional:
550             return FormatPositional(    pOutBuffer,
551                                         bufferSize,
552                                         mantissa,
553                                         exponent,
554                                         mantissaHighBitIdx,
555                                         hasUnequalMargins,
556                                         precision,
557                                         decimalPoint );
558 
559         case PrintFloatFormat_Scientific:
560             return FormatScientific(    pOutBuffer,
561                                         bufferSize,
562                                         mantissa,
563                                         exponent,
564                                         mantissaHighBitIdx,
565                                         hasUnequalMargins,
566                                         precision,
567                                         decimalPoint );
568 
569         default:
570             pOutBuffer[0] = '\0';
571             return 0;
572         }
573     }
574 }
.fi
.SS "\fBtU32\fP PrintFloat64 (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtF64\fP value, \fBtPrintFloatFormat\fP format, \fBtS32\fP precision, \fBtC8\fP decimalPoint)"

.PP
Definition at line 582 of file dprint\&.cpp\&.
.PP
References FormatPositional(), FormatScientific(), tFloatUnion64::GetExponent(), tFloatUnion64::GetMantissa(), tFloatUnion64::IsNegative(), LogBase2(), tFloatUnion64::m_floatingPoint, PrintFloatFormat_Positional, PrintFloatFormat_Scientific, and PrintInfNan()\&.
.PP
Referenced by DecimalSystem::GetRealText()\&.
.PP
.nf
592 {
593     if (bufferSize == 0)
594         return 0;
595 
596     if (bufferSize == 1)
597     {
598         pOutBuffer[0] = '\0';
599         return 1;
600     }
601 
602     // deconstruct the floating point value
603     tFloatUnion64 floatUnion;
604     floatUnion\&.m_floatingPoint = value;
605     tU32 floatExponent = floatUnion\&.GetExponent();
606     tU64 floatMantissa = floatUnion\&.GetMantissa();
607 
608     // output the sign
609     if (floatUnion\&.IsNegative())
610     {
611         pOutBuffer[0] = '-';
612         ++pOutBuffer;
613         --bufferSize;
614         RJ_ASSERT(bufferSize > 0);
615     }
616 
617     // if this is a special value
618     if (floatExponent == 0x7FF)
619     {
620         return PrintInfNan(pOutBuffer, bufferSize, floatMantissa, 13);
621     }
622     // else this is a number
623     else
624     {
625         // factor the value into its parts
626         tU64 mantissa;
627         tS32 exponent;
628         tU32 mantissaHighBitIdx;
629         tB hasUnequalMargins;
630 
631         if (floatExponent != 0)
632         {
633             // normal
634             // The floating point equation is:
635             //  value = (1 + mantissa/2^52) * 2 ^ (exponent-1023)
636             // We convert the integer equation by factoring a 2^52 out of the exponent
637             //  value = (1 + mantissa/2^52) * 2^52 * 2 ^ (exponent-1023-52)
638             //  value = (2^52 + mantissa) * 2 ^ (exponent-1023-52)
639             // Because of the implied 1 in front of the mantissa we have 53 bits of precision\&.
640             //   m = (2^52 + mantissa)
641             //   e = (exponent-1023+1-53)
642             mantissa            = (1ull << 52) | floatMantissa;
643             exponent            = floatExponent - 1023 - 52;
644             mantissaHighBitIdx  = 52;
645             hasUnequalMargins   = (floatExponent != 1) && (floatMantissa == 0);
646         }
647         else
648         {
649             // subnormal
650             // The floating point equation is:
651             //  value = (mantissa/2^52) * 2 ^ (1-1023)
652             // We convert the integer equation by factoring a 2^52 out of the exponent
653             //  value = (mantissa/2^52) * 2^52 * 2 ^ (1-1023-52)
654             //  value = mantissa * 2 ^ (1-1023-52)
655             // We have up to 52 bits of precision\&.
656             //   m = (mantissa)
657             //   e = (1-1023-52)
658             mantissa            = floatMantissa;
659             exponent            = 1 - 1023 - 52;
660             mantissaHighBitIdx  = LogBase2(mantissa);
661             hasUnequalMargins   = false;
662         }
663 
664         // format the value
665         switch (format)
666         {
667         case PrintFloatFormat_Positional:
668             return FormatPositional(    pOutBuffer,
669                                         bufferSize,
670                                         mantissa,
671                                         exponent,
672                                         mantissaHighBitIdx,
673                                         hasUnequalMargins,
674                                         precision,
675                                         decimalPoint );
676 
677         case PrintFloatFormat_Scientific:
678             return FormatScientific(    pOutBuffer,
679                                         bufferSize,
680                                         mantissa,
681                                         exponent,
682                                         mantissaHighBitIdx,
683                                         hasUnequalMargins,
684                                         precision,
685                                         decimalPoint );
686 
687         default:
688             pOutBuffer[0] = '\0';
689             return 0;
690         }
691     }
692 }
.fi
.SS "static \fBtU32\fP PrintHex (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP value, \fBtU32\fP width)\fC [static]\fP"

.PP
Definition at line 399 of file dprint\&.cpp\&.
.PP
Referenced by PrintInfNan()\&.
.PP
.nf
400 {
401     const tC8 digits[] = "0123456789abcdef";
402 
403     RJ_ASSERT(bufferSize > 0);
404 
405     tU32 maxPrintLen = bufferSize-1;
406     if (width > maxPrintLen)
407         width = maxPrintLen;
408 
409     tC8 * pCurOut = pOutBuffer;
410     while (width > 0)
411     {
412         --width;
413 
414         tU8 digit = (tU8)((value >> 4ull*(tU64)width) & 0xF);
415         *pCurOut = digits[digit];
416 
417         ++pCurOut;
418     }
419 
420     *pCurOut = '\0';
421     return pCurOut - pOutBuffer;
422 }
.fi
.SS "static \fBtU32\fP PrintInfNan (\fBtC8\fP * pOutBuffer, \fBtU32\fP bufferSize, \fBtU64\fP mantissa, \fBtU32\fP mantissaHexWidth)\fC [static]\fP"

.PP
Definition at line 429 of file dprint\&.cpp\&.
.PP
References MemCopy(), and PrintHex()\&.
.PP
Referenced by PrintFloat32(), and PrintFloat64()\&.
.PP
.nf
430 {
431     RJ_ASSERT(bufferSize > 0);
432 
433     tU32 maxPrintLen = bufferSize-1;
434 
435     // Check for infinity
436     if (mantissa == 0)
437     {
438         // copy and make sure the buffer is terminated
439         tU32 printLen = (3 < maxPrintLen) ? 3 : maxPrintLen;
440         ::memcpy( pOutBuffer, "Inf", printLen );
441         pOutBuffer[printLen] = '\0';
442         return printLen;
443     }
444     else
445     {
446         // copy and make sure the buffer is terminated
447         tU32 printLen = (3 < maxPrintLen) ? 3 : maxPrintLen;
448         ::memcpy( pOutBuffer, "NaN", printLen );
449         pOutBuffer[printLen] = '\0';
450 
451         // append HEX value
452         if (maxPrintLen > 3)
453             printLen += PrintHex(pOutBuffer+3, bufferSize-3, mantissa, mantissaHexWidth);
454 
455         return printLen;
456     }
457 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
