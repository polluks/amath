.TH "FunctionNode" 3 "Sun Jan 22 2017" "Version 1.6.1" "amath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FunctionNode \- Represents a mathematical function in a syntax tree\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <functions\&.h>\fP
.PP
Inherits \fBExpressionNode\fP\&.
.PP
Inherited by \fBAbsoluteFunctionNode\fP, \fBArcCosecantNode\fP, \fBArcCosineNode\fP, \fBArcCotangentNode\fP, \fBArcSecantNode\fP, \fBArcSineNode\fP, \fBArcTangentNode\fP, \fBBinaryLogNode\fP, \fBCeilingNode\fP, \fBCosecantNode\fP, \fBCosineNode\fP, \fBCotangentNode\fP, \fBCubeRootNode\fP, \fBFloorNode\fP, \fBHyperbolicArcCosecantNode\fP, \fBHyperbolicArccosineNode\fP, \fBHyperbolicArcCotangentNode\fP, \fBHyperbolicArcSecantNode\fP, \fBHyperbolicArcsineNode\fP, \fBHyperbolicArctangentNode\fP, \fBHyperbolicCosecantNode\fP, \fBHyperbolicCosineNode\fP, \fBHyperbolicCotangentNode\fP, \fBHyperbolicSecantNode\fP, \fBHyperbolicSineNode\fP, \fBHyperbolicTangentNode\fP, \fBLnRootNode\fP, \fBLogNode\fP, \fBRoundNode\fP, \fBSecantNode\fP, \fBSignumNode\fP, \fBSineNode\fP, \fBSquareRootNode\fP, \fBTangentNode\fP, \fBTruncNode\fP, and \fBUserFunctionNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFunctionNode\fP (\fBExpressionNode\fP *\fBexpression\fP)"
.br
.ti -1c
.RI "\fB~FunctionNode\fP ()"
.br
.ti -1c
.RI "int \fBGetPrecedence\fP ()"
.br
.ti -1c
.RI "char * \fBGetText\fP ()"
.br
.ti -1c
.RI "virtual \fBSyntaxNode\fP * \fBGetNext\fP ()"
.br
.ti -1c
.RI "virtual void \fBAttach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "virtual void \fBDetach\fP (\fBSyntaxNode\fP *node)"
.br
.ti -1c
.RI "virtual void \fBReplace\fP (\fBSyntaxNode\fP *n, \fBSyntaxNode\fP *x)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBExpressionNode\fP * \fBexpression\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Represents a mathematical function in a syntax tree\&. 

Function nodes in syntax trees can both be well known functions like cosine (cos) and also user defined functions\&. The function node represents a function call and not a function definition\&.
.PP
A formal description of mathematical functions can be found at Wikipedia: http://en.wikipedia.org/wiki/Function_(mathematics)
.PP
When instantiating a function node an argument must be supplied\&. The argument is a pointer to an expression node representing the value which should be used when computing the function value\&. 
.PP
Definition at line 55 of file functions\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "FunctionNode::FunctionNode (\fBExpressionNode\fP * expression)"

.PP
Definition at line 39 of file functions\&.cpp\&.
.PP
References expression, and ExpressionNode::ExpressionNode()\&.
.PP
Referenced by AbsoluteFunctionNode::AbsoluteFunctionNode(), ArcCosecantNode::ArcCosecantNode(), ArcCosineNode::ArcCosineNode(), ArcCotangentNode::ArcCotangentNode(), ArcSecantNode::ArcSecantNode(), ArcSineNode::ArcSineNode(), ArcTangentNode::ArcTangentNode(), BinaryLogNode::BinaryLogNode(), CeilingNode::CeilingNode(), CosecantNode::CosecantNode(), CosineNode::CosineNode(), CotangentNode::CotangentNode(), CubeRootNode::CubeRootNode(), FloorNode::FloorNode(), HyperbolicArcCosecantNode::HyperbolicArcCosecantNode(), HyperbolicArccosineNode::HyperbolicArccosineNode(), HyperbolicArcCotangentNode::HyperbolicArcCotangentNode(), HyperbolicArcSecantNode::HyperbolicArcSecantNode(), HyperbolicArcsineNode::HyperbolicArcsineNode(), HyperbolicArctangentNode::HyperbolicArctangentNode(), HyperbolicCosecantNode::HyperbolicCosecantNode(), HyperbolicCosineNode::HyperbolicCosineNode(), HyperbolicCotangentNode::HyperbolicCotangentNode(), HyperbolicSecantNode::HyperbolicSecantNode(), HyperbolicSineNode::HyperbolicSineNode(), HyperbolicTangentNode::HyperbolicTangentNode(), LnRootNode::LnRootNode(), LogNode::LogNode(), RoundNode::RoundNode(), SecantNode::SecantNode(), SignumNode::SignumNode(), SineNode::SineNode(), SquareRootNode::SquareRootNode(), TangentNode::TangentNode(), TruncNode::TruncNode(), and UserFunctionNode::UserFunctionNode()\&.
.PP
.nf
39                                                      :
40     ExpressionNode(), expression(expression) { }
.fi
.SS "FunctionNode::~FunctionNode ()"

.PP
Definition at line 42 of file functions\&.cpp\&.
.PP
References expression\&.
.PP
.nf
43 {
44     if (expression != NOMEM) {
45         delete expression;
46     }
47 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void FunctionNode::Attach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Reimplemented in \fBUserFunctionNode\fP\&.
.PP
Definition at line 79 of file functions\&.cpp\&.
.PP
References expression, and SyntaxNode::SetParent()\&.
.PP
.nf
80 {
81     if (expression == NOMEM) {
82         expression = (ExpressionNode*)node;
83         node->SetParent(this);
84     }
85 }
.fi
.SS "void FunctionNode::Detach (\fBSyntaxNode\fP * node)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Reimplemented in \fBUserFunctionNode\fP\&.
.PP
Definition at line 87 of file functions\&.cpp\&.
.PP
References expression\&.
.PP
.nf
88 {
89     if (expression == node) {
90         expression = NOMEM;
91     }
92 }
.fi
.SS "\fBSyntaxNode\fP * FunctionNode::GetNext ()\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Reimplemented in \fBUserFunctionNode\fP\&.
.PP
Definition at line 69 of file functions\&.cpp\&.
.PP
References expression, and SyntaxNode::iterator\&.
.PP
.nf
70 {
71     if (iterator == NOMEM) {
72         iterator = expression;
73         return expression;
74     }
75 
76     return NOMEM;
77 }
.fi
.SS "int FunctionNode::GetPrecedence ()\fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 49 of file functions\&.cpp\&.
.PP
.nf
50 {
51     return 5;
52 }
.fi
.SS "char * FunctionNode::GetText ()\fC [virtual]\fP"

.PP
Implements \fBExpressionNode\fP\&.
.PP
Definition at line 54 of file functions\&.cpp\&.
.PP
References CharBuffer::Append(), CharBuffer::Empty(), CharBuffer::EnsureSize(), expression, ExpressionNode::GetNodeText(), CharBuffer::GetString(), ExpressionNode::GetText(), SyntaxNode::output, and StrLen()\&.
.PP
.nf
55 {
56     const char *functionText = GetNodeText();
57     const char *expText = expression->GetText();
58 
59     output->EnsureSize(StrLen(functionText) + StrLen(expText) + 2 + 1);
60     output->Empty();
61     output->Append(functionText);
62     output->Append("(");
63     output->Append(expText);
64     output->Append(")");
65 
66     return output->GetString();
67 }
.fi
.SS "void FunctionNode::Replace (\fBSyntaxNode\fP * n, \fBSyntaxNode\fP * x)\fC [virtual]\fP"

.PP
Implements \fBSyntaxNode\fP\&.
.PP
Reimplemented in \fBUserFunctionNode\fP\&.
.PP
Definition at line 94 of file functions\&.cpp\&.
.PP
References expression\&.
.PP
.nf
95 {
96     if (expression == n) {
97         delete expression;
98         expression = (ExpressionNode*)x;
99     }
100 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBExpressionNode\fP* FunctionNode::expression\fC [protected]\fP"

.PP
Definition at line 68 of file functions\&.h\&.
.PP
Referenced by Attach(), Detach(), UserFunctionNode::Evaluate(), AbsoluteFunctionNode::Evaluate(), SignumNode::Evaluate(), RoundNode::Evaluate(), TruncNode::Evaluate(), FloorNode::Evaluate(), CeilingNode::Evaluate(), SquareRootNode::Evaluate(), CubeRootNode::Evaluate(), LogNode::Evaluate(), LnRootNode::Evaluate(), BinaryLogNode::Evaluate(), SineNode::Evaluate(), CosineNode::Evaluate(), TangentNode::Evaluate(), CotangentNode::Evaluate(), CosecantNode::Evaluate(), SecantNode::Evaluate(), ArcSineNode::Evaluate(), ArcCosineNode::Evaluate(), ArcTangentNode::Evaluate(), ArcCotangentNode::Evaluate(), ArcCosecantNode::Evaluate(), ArcSecantNode::Evaluate(), HyperbolicSineNode::Evaluate(), HyperbolicCosineNode::Evaluate(), HyperbolicTangentNode::Evaluate(), HyperbolicCotangentNode::Evaluate(), HyperbolicSecantNode::Evaluate(), HyperbolicCosecantNode::Evaluate(), HyperbolicArccosineNode::Evaluate(), HyperbolicArcsineNode::Evaluate(), HyperbolicArctangentNode::Evaluate(), HyperbolicArcCotangentNode::Evaluate(), HyperbolicArcCosecantNode::Evaluate(), HyperbolicArcSecantNode::Evaluate(), FunctionNode(), GetNext(), GetText(), Replace(), and ~FunctionNode()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for amath from the source code\&.
