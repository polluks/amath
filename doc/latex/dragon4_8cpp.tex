\hypertarget{dragon4_8cpp}{}\section{lib/dconv/dragon4.cpp File Reference}
\label{dragon4_8cpp}\index{lib/dconv/dragon4.\+cpp@{lib/dconv/dragon4.\+cpp}}
{\ttfamily \#include \char`\"{}math.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}dmath.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}dragon4.\+h\char`\"{}}\\*
Include dependency graph for dragon4.\+cpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=275pt]{dragon4_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structtBigInt}{t\+Big\+Int}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{t\+S32} \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{Big\+Int\+\_\+\+Compare} (const \hyperlink{structtBigInt}{t\+Big\+Int} \&lhs, const \hyperlink{structtBigInt}{t\+Big\+Int} \&rhs)
\item 
static void \hyperlink{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94}{Big\+Int\+\_\+\+Add} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, const \hyperlink{structtBigInt}{t\+Big\+Int} \&lhs, const \hyperlink{structtBigInt}{t\+Big\+Int} \&rhs)
\item 
static void \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{Big\+Int\+\_\+\+Multiply} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, const \hyperlink{structtBigInt}{t\+Big\+Int} \&lhs, const \hyperlink{structtBigInt}{t\+Big\+Int} \&rhs)
\item 
static void \hyperlink{dragon4_8cpp_ad042c6d884cdf9b09f77fb537b5dcc65}{Big\+Int\+\_\+\+Multiply} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, const \hyperlink{structtBigInt}{t\+Big\+Int} \&lhs, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} rhs)
\item 
static void \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{Big\+Int\+\_\+\+Multiply2} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, const \hyperlink{structtBigInt}{t\+Big\+Int} \&in)
\item 
static void \hyperlink{dragon4_8cpp_aa9a15bb474238742ede2b9bc5cce02ff}{Big\+Int\+\_\+\+Multiply2} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result)
\item 
static void \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{Big\+Int\+\_\+\+Multiply10} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result)
\item 
static void \hyperlink{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4}{Big\+Int\+\_\+\+Pow10} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} exponent)
\item 
static void \hyperlink{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183}{Big\+Int\+\_\+\+Multiply\+Pow10} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, const \hyperlink{structtBigInt}{t\+Big\+Int} \&in, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} exponent)
\item 
static void \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{Big\+Int\+\_\+\+Pow2} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} exponent)
\item 
static \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} \hyperlink{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626}{Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Dividend, const \hyperlink{structtBigInt}{t\+Big\+Int} \&divisor)
\item 
static void \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{Big\+Int\+\_\+\+Shift\+Left} (\hyperlink{structtBigInt}{t\+Big\+Int} $\ast$p\+Result, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} shift)
\item 
\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} \hyperlink{dragon4_8cpp_afc702da0bd9df1a3d2d5a93b5568b6db}{Dragon4} (const \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{t\+U64} mantissa, const \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{t\+S32} exponent, const \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} mantissa\+High\+Bit\+Idx, const \hyperlink{dstandard_8h_ad203aed3ab57b120eb54c2043f60dc49}{tB} has\+Unequal\+Margins, const \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220d}{t\+Cutoff\+Mode} cutoff\+Mode, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} cutoff\+Number, \hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{t\+C8} $\ast$p\+Out\+Buffer, \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} buffer\+Size, \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{t\+S32} $\ast$p\+Out\+Exponent)
\begin{DoxyCompactList}\small\item\em Dragon4 main. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks} = 35
\item 
static \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{t\+U32} \hyperlink{dragon4_8cpp_a4caa72077b00dbfcccd05daf04b74896}{g\+\_\+\+Power\+Of10\+\_\+\+U32} \mbox{[}$\,$\mbox{]}
\item 
static \hyperlink{structtBigInt}{t\+Big\+Int} \hyperlink{dragon4_8cpp_ae87ee958451e3a11f2110fd60d58750f}{g\+\_\+\+Power\+Of10\+\_\+\+Big} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Add@{Big\+Int\+\_\+\+Add}}
\index{Big\+Int\+\_\+\+Add@{Big\+Int\+\_\+\+Add}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Add(t\+Big\+Int $\ast$p\+Result, const t\+Big\+Int \&lhs, const t\+Big\+Int \&rhs)}{BigInt_Add(tBigInt *pResult, const tBigInt &lhs, const tBigInt &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Add (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{const {\bf t\+Big\+Int} \&}]{lhs, }
\item[{const {\bf t\+Big\+Int} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94}{}\label{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94}


Definition at line 173 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
174 \{
175     \textcolor{comment}{// determine which operand has the smaller length}
176     \textcolor{keyword}{const} \hyperlink{structtBigInt}{tBigInt} * pLarge;
177     \textcolor{keyword}{const} \hyperlink{structtBigInt}{tBigInt} * pSmall;
178     \textcolor{keywordflow}{if} (lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} < rhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length})
179     \{
180         pSmall = &lhs;
181         pLarge = &rhs;
182     \}
183     \textcolor{keywordflow}{else}
184     \{
185         pSmall = &rhs;
186         pLarge = &lhs;
187     \}
188 
189     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} largeLen = pLarge->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
190     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} smallLen = pSmall->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
191 
192     \textcolor{comment}{// The output will be at least as long as the largest input}
193     pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = largeLen;
194 
195     \textcolor{comment}{// Add each block and add carry the overflow to the next block}
196     \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} carry = 0;
197     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pLargeCur  = pLarge->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
198     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pLargeEnd  = pLargeCur + largeLen;
199     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pSmallCur  = pSmall->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
200     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pSmallEnd  = pSmallCur + smallLen;
201     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *       pResultCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
202     \textcolor{keywordflow}{while} (pSmallCur != pSmallEnd)
203     \{
204         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} sum = carry + (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})(*pLargeCur) + (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})(*pSmallCur);
205         carry = sum >> 32;
206         (*pResultCur) = sum & 0xFFFFFFFF;
207         ++pLargeCur;
208         ++pSmallCur;
209         ++pResultCur;
210     \}
211 
212     \textcolor{comment}{// Add the carry to any blocks that only exist in the large operand}
213     \textcolor{keywordflow}{while} (pLargeCur != pLargeEnd)
214     \{
215         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} sum = carry + (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})(*pLargeCur);
216         carry = sum >> 32;
217         (*pResultCur) = sum & 0xFFFFFFFF;
218         ++pLargeCur;
219         ++pResultCur;
220     \}
221 
222     \textcolor{comment}{// If there's still a carry, append a new block}
223     \textcolor{keywordflow}{if} (carry != 0)
224     \{
225         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(carry == 1);
226         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}((\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})(pResultCur - pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}) == largeLen && (largeLen < 
      \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks}));
227         *pResultCur = 1;
228         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = largeLen + 1;
229     \}
230     \textcolor{keywordflow}{else}
231     \{
232         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = largeLen;
233     \}
234 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Compare@{Big\+Int\+\_\+\+Compare}}
\index{Big\+Int\+\_\+\+Compare@{Big\+Int\+\_\+\+Compare}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Compare(const t\+Big\+Int \&lhs, const t\+Big\+Int \&rhs)}{BigInt_Compare(const tBigInt &lhs, const tBigInt &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf t\+S32} Big\+Int\+\_\+\+Compare (
\begin{DoxyParamCaption}
\item[{const {\bf t\+Big\+Int} \&}]{lhs, }
\item[{const {\bf t\+Big\+Int} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{}\label{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}


Definition at line 148 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9(), and Dragon4().


\begin{DoxyCode}
149 \{
150     \textcolor{comment}{// A bigger length implies a bigger number.}
151     \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} lengthDiff = lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} - rhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
152     \textcolor{keywordflow}{if} (lengthDiff != 0)
153         \textcolor{keywordflow}{return} lengthDiff;
154 
155     \textcolor{comment}{// Compare blocks one by one from high to low.}
156     \textcolor{keywordflow}{for} (\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} i = lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} - 1; i >= 0; --i)
157     \{
158         \textcolor{keywordflow}{if} (lhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i] == rhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i])
159             \textcolor{keywordflow}{continue};
160         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i] > rhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i])
161             \textcolor{keywordflow}{return} 1;
162         \textcolor{keywordflow}{else}
163             \textcolor{keywordflow}{return} -1;
164     \}
165 
166     \textcolor{comment}{// no blocks differed}
167     \textcolor{keywordflow}{return} 0;
168 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9@{Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9}}
\index{Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9@{Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9(t\+Big\+Int $\ast$p\+Dividend, const t\+Big\+Int \&divisor)}{BigInt_DivideWithRemainder_MaxQuotient9(tBigInt *pDividend, const tBigInt &divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf t\+U32} Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Dividend, }
\item[{const {\bf t\+Big\+Int} \&}]{divisor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626}{}\label{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626}


Definition at line 594 of file dragon4.\+cpp.



References Big\+Int\+\_\+\+Compare(), t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
595 \{
596     \textcolor{comment}{// Check that the divisor has been correctly shifted into range and that it is not}
597     \textcolor{comment}{// smaller than the dividend in length.}
598     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(  !divisor.\hyperlink{structtBigInt_a4e0c59f15fcb292ea4ec5d448fa10b58}{IsZero}() &&
599                 divisor.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[divisor.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length}-1] >= 8 &&
600                 divisor.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[divisor.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length}-1] < 0xFFFFFFFF &&
601                 pDividend->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} <= divisor.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} );
602 
603     \textcolor{comment}{// If the dividend is smaller than the divisor, the quotient is zero and the divisor is already}
604     \textcolor{comment}{// the remainder.}
605     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} length = divisor.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
606     \textcolor{keywordflow}{if} (pDividend->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} < divisor.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length})
607         \textcolor{keywordflow}{return} 0;
608 
609     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pFinalDivisorBlock  = divisor.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + length - 1;
610     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *       pFinalDividendBlock = pDividend->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + length - 1;
611 
612     \textcolor{comment}{// Compute an estimated quotient based on the high block value. This will either match the actual
       quotient or}
613     \textcolor{comment}{// undershoot by one.}
614     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32}  quotient = *pFinalDividendBlock / (*pFinalDivisorBlock + 1);
615     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(quotient <= 9);
616 
617     \textcolor{comment}{// Divide out the estimated quotient}
618     \textcolor{keywordflow}{if} (quotient != 0)
619     \{
620         \textcolor{comment}{// dividend = dividend - divisor*quotient}
621         \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pDivisorCur = divisor.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
622         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pDividendCur      = pDividend->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
623 
624         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} borrow = 0;
625         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} carry = 0;
626         \textcolor{keywordflow}{do}
627         \{
628             \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} product = (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})*pDivisorCur * (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})quotient + carry;
629             carry = product >> 32;
630 
631             \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} difference = (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})*pDividendCur - (product & 0xFFFFFFFF) - borrow;
632             borrow = (difference >> 32) & 1;
633 
634             *pDividendCur = difference & 0xFFFFFFFF;
635 
636             ++pDivisorCur;
637             ++pDividendCur;
638         \} \textcolor{keywordflow}{while}(pDivisorCur <= pFinalDivisorBlock);
639 
640         \textcolor{comment}{// remove all leading zero blocks from dividend}
641         \textcolor{keywordflow}{while} (length > 0 && pDividend->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[length - 1] == 0)
642             --length;
643 
644         pDividend->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = length;
645     \}
646 
647     \textcolor{comment}{// If the dividend is still larger than the divisor, we overshot our estimate quotient. To correct,}
648     \textcolor{comment}{// we increment the quotient and subtract one more divisor from the dividend.}
649     \textcolor{keywordflow}{if} ( \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{BigInt\_Compare}(*pDividend, divisor) >= 0 )
650     \{
651         ++quotient;
652 
653         \textcolor{comment}{// dividend = dividend - divisor}
654         \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pDivisorCur = divisor.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
655         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pDividendCur      = pDividend->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
656 
657         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} borrow = 0;
658         \textcolor{keywordflow}{do}
659         \{
660             \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} difference = (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})*pDividendCur - (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})*pDivisorCur - borrow;
661             borrow = (difference >> 32) & 1;
662 
663             *pDividendCur = difference & 0xFFFFFFFF;
664 
665             ++pDivisorCur;
666             ++pDividendCur;
667         \} \textcolor{keywordflow}{while}(pDivisorCur <= pFinalDivisorBlock);
668 
669         \textcolor{comment}{// remove all leading zero blocks from dividend}
670         \textcolor{keywordflow}{while} (length > 0 && pDividend->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[length - 1] == 0)
671             --length;
672 
673         pDividend->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = length;
674     \}
675 
676     \textcolor{keywordflow}{return} quotient;
677 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply@{Big\+Int\+\_\+\+Multiply}}
\index{Big\+Int\+\_\+\+Multiply@{Big\+Int\+\_\+\+Multiply}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply(t\+Big\+Int $\ast$p\+Result, const t\+Big\+Int \&lhs, const t\+Big\+Int \&rhs)}{BigInt_Multiply(tBigInt *pResult, const tBigInt &lhs, const tBigInt &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{const {\bf t\+Big\+Int} \&}]{lhs, }
\item[{const {\bf t\+Big\+Int} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{}\label{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}


Definition at line 239 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Big\+Int\+\_\+\+Multiply\+Pow10(), Big\+Int\+\_\+\+Pow10(), and Dragon4().


\begin{DoxyCode}
240 \{
241     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( pResult != &lhs && pResult != &rhs );
242 
243     \textcolor{comment}{// determine which operand has the smaller length}
244     \textcolor{keyword}{const} \hyperlink{structtBigInt}{tBigInt} * pLarge;
245     \textcolor{keyword}{const} \hyperlink{structtBigInt}{tBigInt} * pSmall;
246     \textcolor{keywordflow}{if} (lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} < rhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length})
247     \{
248         pSmall = &lhs;
249         pLarge = &rhs;
250     \}
251     \textcolor{keywordflow}{else}
252     \{
253         pSmall = &rhs;
254         pLarge = &lhs;
255     \}
256 
257     \textcolor{comment}{// set the maximum possible result length}
258     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} maxResultLen = pLarge->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + pSmall->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
259     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( maxResultLen <= \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks} );
260 
261     \textcolor{comment}{// clear the result data}
262     \textcolor{keywordflow}{for}(\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}, *pEnd = pCur + maxResultLen; pCur != pEnd; ++pCur)
263         *pCur = 0;
264 
265     \textcolor{comment}{// perform standard long multiplication}
266     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLargeBeg = pLarge->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
267     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLargeEnd = pLargeBeg + pLarge->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
268 
269     \textcolor{comment}{// for each small block}
270     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pResultStart = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
271     \textcolor{keywordflow}{for}(\textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pSmallCur = pSmall->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}, *pSmallEnd = pSmallCur + pSmall->
      \hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
272             pSmallCur != pSmallEnd;
273             ++pSmallCur, ++pResultStart)
274     \{
275         \textcolor{comment}{// if non-zero, multiply against all the large blocks and add into the result}
276         \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} multiplier = *pSmallCur;
277         \textcolor{keywordflow}{if} (multiplier != 0)
278         \{
279             \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLargeCur = pLargeBeg;
280             \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pResultCur = pResultStart;
281             \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} carry = 0;
282             \textcolor{keywordflow}{do}
283             \{
284                 \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} product = (*pResultCur) + (*pLargeCur)*(\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})multiplier + carry;
285                 carry = product >> 32;
286                 *pResultCur = product & 0xFFFFFFFF;
287                 ++pLargeCur;
288                 ++pResultCur;
289             \} \textcolor{keywordflow}{while}(pLargeCur != pLargeEnd);
290 
291             \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(pResultCur < pResult->m\_blocks + maxResultLen);
292             *pResultCur = (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})(carry & 0xFFFFFFFF);
293         \}
294     \}
295 
296     \textcolor{comment}{// check if the terminating block has no set bits}
297     \textcolor{keywordflow}{if} (maxResultLen > 0 && pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[maxResultLen - 1] == 0)
298         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = maxResultLen-1;
299     \textcolor{keywordflow}{else}
300         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = maxResultLen;
301 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply@{Big\+Int\+\_\+\+Multiply}}
\index{Big\+Int\+\_\+\+Multiply@{Big\+Int\+\_\+\+Multiply}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply(t\+Big\+Int $\ast$p\+Result, const t\+Big\+Int \&lhs, t\+U32 rhs)}{BigInt_Multiply(tBigInt *pResult, const tBigInt &lhs, tU32 rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{const {\bf t\+Big\+Int} \&}]{lhs, }
\item[{{\bf t\+U32}}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_ad042c6d884cdf9b09f77fb537b5dcc65}{}\label{dragon4_8cpp_ad042c6d884cdf9b09f77fb537b5dcc65}


Definition at line 306 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Big\+Int\+\_\+\+Multiply\+Pow10().


\begin{DoxyCode}
307 \{
308     \textcolor{comment}{// perform long multiplication}
309     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} carry = 0;
310     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pResultCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
311     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLhsCur = lhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
312     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLhsEnd = lhs.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
313     \textcolor{keywordflow}{for} ( ; pLhsCur != pLhsEnd; ++pLhsCur, ++pResultCur )
314     \{
315         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} product = (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})(*pLhsCur) * rhs + carry;
316         *pResultCur = (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})(product & 0xFFFFFFFF);
317         carry = product >> 32;
318     \}
319 
320     \textcolor{comment}{// if there is a remaining carry, grow the array}
321     \textcolor{keywordflow}{if} (carry != 0)
322     \{
323         \textcolor{comment}{// grow the array}
324         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1 <= \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks});
325         *pResultCur = (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})carry;
326         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1;
327     \}
328     \textcolor{keywordflow}{else}
329     \{
330         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = lhs.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
331     \}
332 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_ad042c6d884cdf9b09f77fb537b5dcc65_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply10@{Big\+Int\+\_\+\+Multiply10}}
\index{Big\+Int\+\_\+\+Multiply10@{Big\+Int\+\_\+\+Multiply10}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply10(t\+Big\+Int $\ast$p\+Result)}{BigInt_Multiply10(tBigInt *pResult)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply10 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{}\label{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}


Definition at line 394 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
395 \{
396     \textcolor{comment}{// multiply all the blocks}
397     \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} carry = 0;
398 
399     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
400     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pEnd = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
401     \textcolor{keywordflow}{for} ( ; pCur != pEnd; ++pCur )
402     \{
403         \hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64} product = (\hyperlink{dstandard_8h_a6625ae5505b2f796350b82c7f52fcf43}{tU64})(*pCur) * 10ull + carry;
404         (*pCur) = (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})(product & 0xFFFFFFFF);
405         carry = product >> 32;
406     \}
407 
408     \textcolor{keywordflow}{if} (carry != 0)
409     \{
410         \textcolor{comment}{// grow the array}
411         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1 <= \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks});
412         *pCur = (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32})carry;
413         ++pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
414     \}
415 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply2@{Big\+Int\+\_\+\+Multiply2}}
\index{Big\+Int\+\_\+\+Multiply2@{Big\+Int\+\_\+\+Multiply2}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply2(t\+Big\+Int $\ast$p\+Result, const t\+Big\+Int \&in)}{BigInt_Multiply2(tBigInt *pResult, const tBigInt &in)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply2 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{const {\bf t\+Big\+Int} \&}]{in}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{}\label{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}


Definition at line 337 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
338 \{
339     \textcolor{comment}{// shift all the blocks by one}
340     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} carry = 0;
341 
342     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pResultCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
343     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLhsCur = in.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
344     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pLhsEnd = in.\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + in.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
345     \textcolor{keywordflow}{for} ( ; pLhsCur != pLhsEnd; ++pLhsCur, ++pResultCur )
346     \{
347         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} cur = *pLhsCur;
348         *pResultCur = (cur << 1) | carry;
349         carry = cur >> 31;
350     \}
351 
352     \textcolor{keywordflow}{if} (carry != 0)
353     \{
354         \textcolor{comment}{// grow the array}
355         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(in.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1 <= \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks});
356         *pResultCur = carry;
357         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = in.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1;
358     \}
359     \textcolor{keywordflow}{else}
360     \{
361         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = in.\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
362     \}
363 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply2@{Big\+Int\+\_\+\+Multiply2}}
\index{Big\+Int\+\_\+\+Multiply2@{Big\+Int\+\_\+\+Multiply2}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply2(t\+Big\+Int $\ast$p\+Result)}{BigInt_Multiply2(tBigInt *pResult)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply2 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_aa9a15bb474238742ede2b9bc5cce02ff}{}\label{dragon4_8cpp_aa9a15bb474238742ede2b9bc5cce02ff}


Definition at line 368 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
369 \{
370     \textcolor{comment}{// shift all the blocks by one}
371     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} carry = 0;
372 
373     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
374     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *pEnd = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
375     \textcolor{keywordflow}{for} ( ; pCur != pEnd; ++pCur )
376     \{
377         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} cur = *pCur;
378         *pCur = (cur << 1) | carry;
379         carry = cur >> 31;
380     \}
381 
382     \textcolor{keywordflow}{if} (carry != 0)
383     \{
384         \textcolor{comment}{// grow the array}
385         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} + 1 <= \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks});
386         *pCur = carry;
387         ++pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
388     \}
389 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_aa9a15bb474238742ede2b9bc5cce02ff_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Multiply\+Pow10@{Big\+Int\+\_\+\+Multiply\+Pow10}}
\index{Big\+Int\+\_\+\+Multiply\+Pow10@{Big\+Int\+\_\+\+Multiply\+Pow10}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Multiply\+Pow10(t\+Big\+Int $\ast$p\+Result, const t\+Big\+Int \&in, t\+U32 exponent)}{BigInt_MultiplyPow10(tBigInt *pResult, const tBigInt &in, tU32 exponent)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Multiply\+Pow10 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{const {\bf t\+Big\+Int} \&}]{in, }
\item[{{\bf t\+U32}}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183}{}\label{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183}


Definition at line 511 of file dragon4.\+cpp.



References Big\+Int\+\_\+\+Multiply(), g\+\_\+\+Power\+Of10\+\_\+\+Big, g\+\_\+\+Power\+Of10\+\_\+\+U32, and t\+Big\+Int\+::operator=().



Referenced by Dragon4().


\begin{DoxyCode}
512 \{
513     \textcolor{comment}{// make sure the exponent is within the bounds of the lookup table data}
514     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(exponent < 512);
515 
516     \textcolor{comment}{// create two temporary values to reduce large integer copy operations}
517     \hyperlink{structtBigInt}{tBigInt} temp1;
518     \hyperlink{structtBigInt}{tBigInt} temp2;
519     \hyperlink{structtBigInt}{tBigInt} *pCurTemp = &temp1;
520     \hyperlink{structtBigInt}{tBigInt} *pNextTemp = &temp2;
521 
522     \textcolor{comment}{// initialize the result by looking up a 32-bit power of 10 corresponding to the first 3 bits}
523     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} smallExponent = exponent & 0x7;
524     \textcolor{keywordflow}{if} (smallExponent != 0)
525     \{
526         \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{BigInt\_Multiply}( pCurTemp, in, \hyperlink{dragon4_8cpp_a4caa72077b00dbfcccd05daf04b74896}{g\_PowerOf10\_U32}[smallExponent] );
527     \}
528     \textcolor{keywordflow}{else}
529     \{
530         *pCurTemp = in;
531     \}
532 
533     \textcolor{comment}{// remove the low bits that we used for the 32-bit lookup table}
534     exponent >>= 3;
535     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} tableIdx = 0;
536 
537     \textcolor{comment}{// while there are remaining bits in the exponent to be processed}
538     \textcolor{keywordflow}{while} (exponent != 0)
539     \{
540         \textcolor{comment}{// if the current bit is set, multiply it with the corresponding power of 10}
541         \textcolor{keywordflow}{if}(exponent & 1)
542         \{
543             \textcolor{comment}{// multiply into the next temporary}
544             \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{BigInt\_Multiply}( pNextTemp, *pCurTemp, 
      \hyperlink{dragon4_8cpp_ae87ee958451e3a11f2110fd60d58750f}{g\_PowerOf10\_Big}[tableIdx] );
545 
546             \textcolor{comment}{// swap to the next temporary}
547             \hyperlink{structtBigInt}{tBigInt} * pSwap = pCurTemp;
548             pCurTemp = pNextTemp;
549             pNextTemp = pSwap;
550         \}
551 
552         \textcolor{comment}{// advance to the next bit}
553         ++tableIdx;
554         exponent >>= 1;
555     \}
556 
557     \textcolor{comment}{// output the result}
558     *pResult = *pCurTemp;
559 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Pow10@{Big\+Int\+\_\+\+Pow10}}
\index{Big\+Int\+\_\+\+Pow10@{Big\+Int\+\_\+\+Pow10}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Pow10(t\+Big\+Int $\ast$p\+Result, t\+U32 exponent)}{BigInt_Pow10(tBigInt *pResult, tU32 exponent)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Pow10 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{{\bf t\+U32}}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4}{}\label{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4}


Definition at line 465 of file dragon4.\+cpp.



References Big\+Int\+\_\+\+Multiply(), g\+\_\+\+Power\+Of10\+\_\+\+Big, g\+\_\+\+Power\+Of10\+\_\+\+U32, t\+Big\+Int\+::operator=(), and t\+Big\+Int\+::\+Set\+U32().



Referenced by Dragon4().


\begin{DoxyCode}
466 \{
467     \textcolor{comment}{// make sure the exponent is within the bounds of the lookup table data}
468     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(exponent < 512);
469 
470     \textcolor{comment}{// create two temporary values to reduce large integer copy operations}
471     \hyperlink{structtBigInt}{tBigInt} temp1;
472     \hyperlink{structtBigInt}{tBigInt} temp2;
473     \hyperlink{structtBigInt}{tBigInt} *pCurTemp = &temp1;
474     \hyperlink{structtBigInt}{tBigInt} *pNextTemp = &temp2;
475 
476     \textcolor{comment}{// initialize the result by looking up a 32-bit power of 10 corresponding to the first 3 bits}
477     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} smallExponent = exponent & 0x7;
478     pCurTemp->\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}(\hyperlink{dragon4_8cpp_a4caa72077b00dbfcccd05daf04b74896}{g\_PowerOf10\_U32}[smallExponent]);
479 
480     \textcolor{comment}{// remove the low bits that we used for the 32-bit lookup table}
481     exponent >>= 3;
482     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} tableIdx = 0;
483 
484     \textcolor{comment}{// while there are remaining bits in the exponent to be processed}
485     \textcolor{keywordflow}{while} (exponent != 0)
486     \{
487         \textcolor{comment}{// if the current bit is set, multiply it with the corresponding power of 10}
488         \textcolor{keywordflow}{if}(exponent & 1)
489         \{
490             \textcolor{comment}{// multiply into the next temporary}
491             \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{BigInt\_Multiply}( pNextTemp, *pCurTemp, 
      \hyperlink{dragon4_8cpp_ae87ee958451e3a11f2110fd60d58750f}{g\_PowerOf10\_Big}[tableIdx] );
492 
493             \textcolor{comment}{// swap to the next temporary}
494             \hyperlink{structtBigInt}{tBigInt} * pSwap = pCurTemp;
495             pCurTemp = pNextTemp;
496             pNextTemp = pSwap;
497         \}
498 
499         \textcolor{comment}{// advance to the next bit}
500         ++tableIdx;
501         exponent >>= 1;
502     \}
503 
504     \textcolor{comment}{// output the result}
505     *pResult = *pCurTemp;
506 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=285pt]{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Pow2@{Big\+Int\+\_\+\+Pow2}}
\index{Big\+Int\+\_\+\+Pow2@{Big\+Int\+\_\+\+Pow2}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Pow2(t\+Big\+Int $\ast$p\+Result, t\+U32 exponent)}{BigInt_Pow2(tBigInt *pResult, tU32 exponent)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Pow2 (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{{\bf t\+U32}}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{}\label{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}


Definition at line 564 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
565 \{
566     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} blockIdx = exponent / 32;
567     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( blockIdx < \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks} );
568 
569     \textcolor{keywordflow}{for} ( \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} i = 0; i <= blockIdx; ++i)
570         pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i] = 0;
571 
572     pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = blockIdx + 1;
573 
574     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} bitIdx = (exponent % 32);
575     pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[blockIdx] |= (1 << bitIdx);
576 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Big\+Int\+\_\+\+Shift\+Left@{Big\+Int\+\_\+\+Shift\+Left}}
\index{Big\+Int\+\_\+\+Shift\+Left@{Big\+Int\+\_\+\+Shift\+Left}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Big\+Int\+\_\+\+Shift\+Left(t\+Big\+Int $\ast$p\+Result, t\+U32 shift)}{BigInt_ShiftLeft(tBigInt *pResult, tU32 shift)}}]{\setlength{\rightskip}{0pt plus 5cm}static void Big\+Int\+\_\+\+Shift\+Left (
\begin{DoxyParamCaption}
\item[{{\bf t\+Big\+Int} $\ast$}]{p\+Result, }
\item[{{\bf t\+U32}}]{shift}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{}\label{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}


Definition at line 682 of file dragon4.\+cpp.



References t\+Big\+Int\+::m\+\_\+blocks, and t\+Big\+Int\+::m\+\_\+length.



Referenced by Dragon4().


\begin{DoxyCode}
683 \{
684     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( shift != 0 );
685 
686     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} shiftBlocks = shift / 32;
687     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} shiftBits = shift % 32;
688 
689     \textcolor{comment}{// process blocks high to low so that we can safely process in place}
690     \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} *    pInBlocks   = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks};
691     \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32}            inLength    = pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
692     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( inLength + shiftBlocks < \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks} );
693 
694     \textcolor{comment}{// check if the shift is block aligned}
695     \textcolor{keywordflow}{if} (shiftBits == 0)
696     \{
697         \textcolor{comment}{// copy blcoks from high to low}
698         \textcolor{keywordflow}{for} (\hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} * pInCur = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks} + inLength, *pOutCur = pInCur + shiftBlocks;
699                 pInCur >= pInBlocks;
700                 --pInCur, --pOutCur)
701         \{
702             *pOutCur = *pInCur;
703         \}
704 
705         \textcolor{comment}{// zero the remaining low blocks}
706         \textcolor{keywordflow}{for} ( \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} i = 0; i < shiftBlocks; ++i)
707             pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i] = 0;
708 
709         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} += shiftBlocks;
710     \}
711     \textcolor{comment}{// else we need to shift partial blocks}
712     \textcolor{keywordflow}{else}
713     \{
714         \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} inBlockIdx  = inLength - 1;
715         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} outBlockIdx = inLength + shiftBlocks;
716 
717         \textcolor{comment}{// set the length to hold the shifted blocks}
718         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( outBlockIdx < \hyperlink{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{c\_BigInt\_MaxBlocks} );
719         pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} = outBlockIdx + 1;
720 
721         \textcolor{comment}{// output the initial blocks}
722         \textcolor{keyword}{const} \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} lowBitsShift = (32 - shiftBits);
723         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} highBits = 0;
724         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} block = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[inBlockIdx];
725         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} lowBits = block >> lowBitsShift;
726         \textcolor{keywordflow}{while} ( inBlockIdx > 0 )
727         \{
728             pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[outBlockIdx] = highBits | lowBits;
729             highBits = block << shiftBits;
730 
731             --inBlockIdx;
732             --outBlockIdx;
733 
734             block = pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[inBlockIdx];
735             lowBits = block >> lowBitsShift;
736         \}
737 
738         \textcolor{comment}{// output the final blocks}
739         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( outBlockIdx == shiftBlocks + 1 );
740         pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[outBlockIdx] = highBits | lowBits;
741         pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[outBlockIdx-1] = block << shiftBits;
742 
743         \textcolor{comment}{// zero the remaining low blocks}
744         \textcolor{keywordflow}{for} ( \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} i = 0; i < shiftBlocks; ++i)
745             pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[i] = 0;
746 
747         \textcolor{comment}{// check if the terminating block has no set bits}
748         if (pResult->\hyperlink{structtBigInt_a5e3b7b252d975532d51ae7ced6699351}{m\_blocks}[pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length} - 1] == 0)
749             --pResult->\hyperlink{structtBigInt_a86287c0800ba611962655553025b4920}{m\_length};
750     \}
751 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720_icgraph}
\end{center}
\end{figure}


\index{dragon4.\+cpp@{dragon4.\+cpp}!Dragon4@{Dragon4}}
\index{Dragon4@{Dragon4}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{Dragon4(const t\+U64 mantissa, const t\+S32 exponent, const t\+U32 mantissa\+High\+Bit\+Idx, const t\+B has\+Unequal\+Margins, const t\+Cutoff\+Mode cutoff\+Mode, t\+U32 cutoff\+Number, t\+C8 $\ast$p\+Out\+Buffer, t\+U32 buffer\+Size, t\+S32 $\ast$p\+Out\+Exponent)}{Dragon4(const tU64 mantissa, const tS32 exponent, const tU32 mantissaHighBitIdx, const tB hasUnequalMargins, const tCutoffMode cutoffMode, tU32 cutoffNumber, tC8 *pOutBuffer, tU32 bufferSize, tS32 *pOutExponent)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+U32} Dragon4 (
\begin{DoxyParamCaption}
\item[{{\bf t\+U64}}]{mantissa, }
\item[{{\bf t\+S32}}]{exponent, }
\item[{{\bf t\+U32}}]{mantissa\+High\+Bit\+Idx, }
\item[{{\bf tB}}]{has\+Unequal\+Margins, }
\item[{enum {\bf t\+Cutoff\+Mode}}]{cutoff\+Mode, }
\item[{{\bf t\+U32}}]{cutoff\+Number, }
\item[{{\bf t\+C8} $\ast$}]{p\+Out\+Buffer, }
\item[{{\bf t\+U32}}]{buffer\+Size, }
\item[{{\bf t\+S32} $\ast$}]{p\+Out\+Exponent}
\end{DoxyParamCaption}
)}\hypertarget{dragon4_8cpp_afc702da0bd9df1a3d2d5a93b5568b6db}{}\label{dragon4_8cpp_afc702da0bd9df1a3d2d5a93b5568b6db}


Dragon4 main. 

Downloaded from\+:~\newline
 \href{http://www.ryanjuckett.com/}{\tt http\+://www.\+ryanjuckett.\+com/}

This is an implementation the Dragon4 algorithm to convert a binary number in floating point format to a decimal number in string format. The function returns the number of digits written to the output buffer and the output is not N\+UL terminated.

The floating point input value is (mantissa $\ast$ 2$^\wedge$exponent).

See the following papers for more information on the algorithm\+:~\newline
 \char`\"{}\+How to Print Floating-\/\+Point Numbers Accurately\char`\"{}~\newline
 Steele and White~\newline
 \href{http://kurtstephens.com/files/p372-steele.pdf}{\tt http\+://kurtstephens.\+com/files/p372-\/steele.\+pdf}~\newline
 \char`\"{}\+Printing Floating-\/\+Point Numbers Quickly and Accurately\char`\"{}~\newline
 Burger and Dybvig~\newline
 \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf}{\tt http\+://citeseerx.\+ist.\+psu.\+edu/viewdoc/download?doi=10.\+1.\+1.\+72.\+4656\&rep=rep1\&type=pdf}~\newline
 

Definition at line 770 of file dragon4.\+cpp.



References Big\+Int\+\_\+\+Add(), Big\+Int\+\_\+\+Compare(), Big\+Int\+\_\+\+Divide\+With\+Remainder\+\_\+\+Max\+Quotient9(), Big\+Int\+\_\+\+Multiply(), Big\+Int\+\_\+\+Multiply10(), Big\+Int\+\_\+\+Multiply2(), Big\+Int\+\_\+\+Multiply\+Pow10(), Big\+Int\+\_\+\+Pow10(), Big\+Int\+\_\+\+Pow2(), Big\+Int\+\_\+\+Shift\+Left(), Cutoff\+Mode\+\_\+\+Fraction\+Length, Cutoff\+Mode\+\_\+\+Total\+Length, Cutoff\+Mode\+\_\+\+Unique, t\+Big\+Int\+::\+Get\+Block(), t\+Big\+Int\+::\+Get\+Length(), t\+Big\+Int\+::\+Is\+Zero(), Log\+Base2(), t\+Big\+Int\+::operator=(), t\+Big\+Int\+::\+Set\+U32(), and t\+Big\+Int\+::\+Set\+U64().



Referenced by Format\+Positional(), and Format\+Scientific().


\begin{DoxyCode}
781 \{
782     \hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{tC8} * pCurDigit = pOutBuffer;
783 
784     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( bufferSize > 0 );
785 
786     \textcolor{comment}{// if the mantissa is zero, the value is zero regardless of the exponent}
787     \textcolor{keywordflow}{if} (mantissa == 0)
788     \{
789         *pCurDigit = \textcolor{charliteral}{'0'};
790         *pOutExponent = 0;
791         \textcolor{keywordflow}{return} 1;
792     \}
793 
794     \textcolor{comment}{// compute the initial state in integral form such that}
795     \textcolor{comment}{//  value     = scaledValue / scale}
796     \textcolor{comment}{//  marginLow = scaledMarginLow / scale}
797     \hyperlink{structtBigInt}{tBigInt} scale;              \textcolor{comment}{// positive scale applied to value and margin such that they can be}
798     \textcolor{comment}{//  represented as whole numbers}
799     \hyperlink{structtBigInt}{tBigInt} scaledValue;        \textcolor{comment}{// scale * mantissa}
800     \hyperlink{structtBigInt}{tBigInt} scaledMarginLow;    \textcolor{comment}{// scale * 0.5 * (distance between this floating-point number and
       its}
801     \textcolor{comment}{//  immediate lower value)}
802 
803     \textcolor{comment}{// For normalized IEEE floating point values, each time the exponent is incremented the margin also}
804     \textcolor{comment}{// doubles. That creates a subset of transition numbers where the high margin is twice the size of}
805     \textcolor{comment}{// the low margin.}
806     \hyperlink{structtBigInt}{tBigInt} * pScaledMarginHigh;
807     \hyperlink{structtBigInt}{tBigInt} optionalMarginHigh;
808 
809     \textcolor{keywordflow}{if} ( hasUnequalMargins )
810     \{
811         \textcolor{comment}{// if we have no fractional component}
812         \textcolor{keywordflow}{if} (exponent > 0)
813         \{
814             \textcolor{comment}{// 1) Expand the input value by multiplying out the mantissa and exponent. This represents}
815             \textcolor{comment}{//    the input value in its whole number representation.}
816             \textcolor{comment}{// 2) Apply an additional scale of 2 such that later comparisons against the margin values}
817             \textcolor{comment}{//    are simplified.}
818             \textcolor{comment}{// 3) Set the margin value to the lowest mantissa bit's scale.}
819 
820             \textcolor{comment}{// scaledValue      = 2 * 2 * mantissa*2^exponent}
821             scaledValue.\hyperlink{structtBigInt_ab25f77e908d231d8836355cf4586f983}{SetU64}( 4 * mantissa );
822             \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{BigInt\_ShiftLeft}( &scaledValue, exponent );
823 
824             \textcolor{comment}{// scale            = 2 * 2 * 1}
825             scale.\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}( 4 );
826 
827             \textcolor{comment}{// scaledMarginLow  = 2 * 2^(exponent-1)}
828             \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{BigInt\_Pow2}( &scaledMarginLow, exponent );
829 
830             \textcolor{comment}{// scaledMarginHigh = 2 * 2 * 2^(exponent-1)}
831             \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{BigInt\_Pow2}( &optionalMarginHigh, exponent + 1 );
832         \}
833         \textcolor{comment}{// else we have a fractional exponent}
834         \textcolor{keywordflow}{else}
835         \{
836             \textcolor{comment}{// In order to track the mantissa data as an integer, we store it as is with a large scale}
837 
838             \textcolor{comment}{// scaledValue      = 2 * 2 * mantissa}
839             scaledValue.\hyperlink{structtBigInt_ab25f77e908d231d8836355cf4586f983}{SetU64}( 4 * mantissa );
840 
841             \textcolor{comment}{// scale            = 2 * 2 * 2^(-exponent)}
842             \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{BigInt\_Pow2}(&scale, -exponent + 2 );
843 
844             \textcolor{comment}{// scaledMarginLow  = 2 * 2^(-1)}
845             scaledMarginLow.\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}( 1 );
846 
847             \textcolor{comment}{// scaledMarginHigh = 2 * 2 * 2^(-1)}
848             optionalMarginHigh.\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}( 2 );
849         \}
850 
851         \textcolor{comment}{// the high and low margins are different}
852         pScaledMarginHigh = &optionalMarginHigh;
853     \}
854     \textcolor{keywordflow}{else}
855     \{
856         \textcolor{comment}{// if we have no fractional component}
857         \textcolor{keywordflow}{if} (exponent > 0)
858         \{
859             \textcolor{comment}{// 1) Expand the input value by multiplying out the mantissa and exponent. This represents}
860             \textcolor{comment}{//    the input value in its whole number representation.}
861             \textcolor{comment}{// 2) Apply an additional scale of 2 such that later comparisons against the margin values}
862             \textcolor{comment}{//    are simplified.}
863             \textcolor{comment}{// 3) Set the margin value to the lowest mantissa bit's scale.}
864 
865             \textcolor{comment}{// scaledValue     = 2 * mantissa*2^exponent}
866             scaledValue.\hyperlink{structtBigInt_ab25f77e908d231d8836355cf4586f983}{SetU64}( 2 * mantissa );
867             \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{BigInt\_ShiftLeft}( &scaledValue, exponent );
868 
869             \textcolor{comment}{// scale           = 2 * 1}
870             scale.\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}( 2 );
871 
872             \textcolor{comment}{// scaledMarginLow = 2 * 2^(exponent-1)}
873             \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{BigInt\_Pow2}( &scaledMarginLow, exponent );
874         \}
875         \textcolor{comment}{// else we have a fractional exponent}
876         \textcolor{keywordflow}{else}
877         \{
878             \textcolor{comment}{// In order to track the mantissa data as an integer, we store it as is with a large scale}
879 
880             \textcolor{comment}{// scaledValue     = 2 * mantissa}
881             scaledValue.\hyperlink{structtBigInt_ab25f77e908d231d8836355cf4586f983}{SetU64}( 2 * mantissa );
882 
883             \textcolor{comment}{// scale           = 2 * 2^(-exponent)}
884             \hyperlink{dragon4_8cpp_aec271fe4eb1817a10d3bb20baa5e7695}{BigInt\_Pow2}(&scale, -exponent + 1 );
885 
886             \textcolor{comment}{// scaledMarginLow = 2 * 2^(-1)}
887             scaledMarginLow.\hyperlink{structtBigInt_a1aec50a9a3a9129b283c43eecc6df8c3}{SetU32}( 1 );
888         \}
889 
890         \textcolor{comment}{// the high and low margins are equal}
891         pScaledMarginHigh = &scaledMarginLow;
892     \}
893 
894     \textcolor{comment}{// Compute an estimate for digitExponent that will be correct or undershoot by one.}
895     \textcolor{comment}{// This optimization is based on the paper "Printing Floating-Point Numbers Quickly and Accurately"}
896     \textcolor{comment}{// by Burger and Dybvig
       http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf}
897     \textcolor{comment}{// We perform an additional subtraction of 0.69 to increase the frequency of a failed estimate}
898     \textcolor{comment}{// because that lets us take a faster branch in the code. 0.69 is chosen because 0.69 + log10(2) is}
899     \textcolor{comment}{// less than one by a reasonable epsilon that will account for any floating point error.}
900     \textcolor{comment}{//}
901     \textcolor{comment}{// We want to set digitExponent to floor(log10(v)) + 1}
902     \textcolor{comment}{//  v = mantissa*2^exponent}
903     \textcolor{comment}{//  log2(v) = log2(mantissa) + exponent;}
904     \textcolor{comment}{//  log10(v) = log2(v) * log10(2)}
905     \textcolor{comment}{//  floor(log2(v)) = mantissaHighBitIdx + exponent;}
906     \textcolor{comment}{//  log10(v) - log10(2) < (mantissaHighBitIdx + exponent) * log10(2) <= log10(v)}
907     \textcolor{comment}{//  log10(v) < (mantissaHighBitIdx + exponent) * log10(2) + log10(2) <= log10(v) + log10(2)}
908     \textcolor{comment}{//  floor( log10(v) ) < ceil( (mantissaHighBitIdx + exponent) * log10(2) ) <= floor( log10(v) ) + 1}
909     \textcolor{keyword}{const} \hyperlink{dstandard_8h_a401388ecc207be71d44743e3b4cc4b4d}{tF64} log10\_2 = 0.30102999566398119521373889472449;
910     \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} digitExponent = (\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})(\hyperlink{math_8h_a1ea6d7b591132268abc2e843ababd084}{ceil}(\hyperlink{dstandard_8h_a401388ecc207be71d44743e3b4cc4b4d}{tF64}((\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})mantissaHighBitIdx + exponent) * 
      log10\_2 - 0.69));
911 
912     \textcolor{comment}{// if the digit exponent is smaller than the smallest desired digit for fractional cutoff,}
913     \textcolor{comment}{// pull the digit back into legal range at which point we will round to the appropriate value.}
914     \textcolor{comment}{// Note that while our value for digitExponent is still an estimate, this is safe because it}
915     \textcolor{comment}{// only increases the number. This will either correct digitExponent to an accurate value or it}
916     \textcolor{comment}{// will clamp it above the accurate value.}
917     \textcolor{keywordflow}{if} (cutoffMode == \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220da5ca840f5638b86f243a799c44c16898e}{CutoffMode\_FractionLength} && digitExponent <= -(
      \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})cutoffNumber)
918     \{
919         digitExponent = -(\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})cutoffNumber + 1;
920     \}
921 
922     \textcolor{comment}{// Divide value by 10^digitExponent.}
923     \textcolor{keywordflow}{if} (digitExponent > 0)
924     \{
925         \textcolor{comment}{// The exponent is positive creating a division so we multiply up the scale.}
926         \hyperlink{structtBigInt}{tBigInt} temp;
927         \hyperlink{dragon4_8cpp_a4956a6f2bde27b9ce21f660f4f210183}{BigInt\_MultiplyPow10}( &temp, scale, digitExponent );
928         scale = temp;
929     \}
930     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (digitExponent < 0)
931     \{
932         \textcolor{comment}{// The exponent is negative creating a multiplication so we multiply up the scaledValue,}
933         \textcolor{comment}{// scaledMarginLow and scaledMarginHigh.}
934         \hyperlink{structtBigInt}{tBigInt} pow10;
935         \hyperlink{dragon4_8cpp_a29b0dfce8001ff786da11c98281097c4}{BigInt\_Pow10}( &pow10, -digitExponent);
936 
937         \hyperlink{structtBigInt}{tBigInt} temp;
938         \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{BigInt\_Multiply}( &temp, scaledValue, pow10);
939         scaledValue = temp;
940 
941         \hyperlink{dragon4_8cpp_a706f0dc60cee9f4e28a81787aec73470}{BigInt\_Multiply}( &temp, scaledMarginLow, pow10);
942         scaledMarginLow = temp;
943 
944         \textcolor{keywordflow}{if} (pScaledMarginHigh != &scaledMarginLow)
945             \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{BigInt\_Multiply2}( pScaledMarginHigh, scaledMarginLow );
946     \}
947 
948     \textcolor{comment}{// If (value + marginHigh) >= 1, our estimate for digitExponent was too low}
949     \hyperlink{structtBigInt}{tBigInt} scaledValueHigh;
950     \hyperlink{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94}{BigInt\_Add}( &scaledValueHigh, scaledValue, *pScaledMarginHigh );
951     \textcolor{keywordflow}{if}( \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{BigInt\_Compare}(scaledValueHigh,scale) >= 0 )
952     \{
953         \textcolor{comment}{// The exponent estimate was incorrect.}
954         \textcolor{comment}{// Increment the exponent and don't perform the premultiply needed}
955         \textcolor{comment}{// for the first loop iteration.}
956         digitExponent = digitExponent + 1;
957     \}
958     \textcolor{keywordflow}{else}
959     \{
960         \textcolor{comment}{// The exponent estimate was correct.}
961         \textcolor{comment}{// Multiply larger by the output base to prepare for the first loop iteration.}
962         \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{BigInt\_Multiply10}( &scaledValue );
963         \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{BigInt\_Multiply10}( &scaledMarginLow );
964         \textcolor{keywordflow}{if} (pScaledMarginHigh != &scaledMarginLow)
965             \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{BigInt\_Multiply2}( pScaledMarginHigh, scaledMarginLow );
966     \}
967 
968     \textcolor{comment}{// Compute the cutoff exponent (the exponent of the final digit to print).}
969     \textcolor{comment}{// Default to the maximum size of the output buffer.}
970     \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} cutoffExponent = digitExponent - bufferSize;
971     \textcolor{keywordflow}{switch}(cutoffMode)
972     \{
973         \textcolor{comment}{// print digits until we pass the accuracy margin limits or buffer size}
974     \textcolor{keywordflow}{case} \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220da076774f759c6005f59bf2b5535abf570}{CutoffMode\_Unique}:
975         \textcolor{keywordflow}{break};
976 
977         \textcolor{comment}{// print cutoffNumber of digits or until we reach the buffer size}
978     \textcolor{keywordflow}{case} \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220dad8310b28d0e03277f3ca31dbf052f112}{CutoffMode\_TotalLength}:
979     \{
980         \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} desiredCutoffExponent = digitExponent - (\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})cutoffNumber;
981         \textcolor{keywordflow}{if} (desiredCutoffExponent > cutoffExponent)
982             cutoffExponent = desiredCutoffExponent;
983     \}
984     \textcolor{keywordflow}{break};
985 
986     \textcolor{comment}{// print cutoffNumber digits past the decimal point or until we reach the buffer size}
987     \textcolor{keywordflow}{case} \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220da5ca840f5638b86f243a799c44c16898e}{CutoffMode\_FractionLength}:
988     \{
989         \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} desiredCutoffExponent = -(\hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32})cutoffNumber;
990         \textcolor{keywordflow}{if} (desiredCutoffExponent > cutoffExponent)
991             cutoffExponent = desiredCutoffExponent;
992     \}
993     \textcolor{keywordflow}{break};
994     \}
995 
996     \textcolor{comment}{// Output the exponent of the first digit we will print}
997     *pOutExponent = digitExponent-1;
998 
999     \textcolor{comment}{// In preparation for calling BigInt\_DivideWithRemainder\_MaxQuotient9(),}
1000     \textcolor{comment}{// we need to scale up our values such that the highest block of the denominator}
1001     \textcolor{comment}{// is greater than or equal to 8. We also need to guarantee that the numerator}
1002     \textcolor{comment}{// can never have a length greater than the denominator after each loop iteration.}
1003     \textcolor{comment}{// This requires the highest block of the denominator to be less than or equal to}
1004     \textcolor{comment}{// 429496729 which is the highest number that can be multiplied by 10 without}
1005     \textcolor{comment}{// overflowing to a new block.}
1006     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( scale.\hyperlink{structtBigInt_aee567e4c77187577f77fc1643dc427ba}{GetLength}() > 0 );
1007     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} hiBlock = scale.\hyperlink{structtBigInt_a22350ff8e7010047b7ac5be70e8906bd}{GetBlock}( scale.\hyperlink{structtBigInt_aee567e4c77187577f77fc1643dc427ba}{GetLength}() - 1 );
1008     \textcolor{keywordflow}{if} (hiBlock < 8 || hiBlock > 429496729)
1009     \{
1010         \textcolor{comment}{// Perform a bit shift on all values to get the highest block of the denominator into}
1011         \textcolor{comment}{// the range [8,429496729]. We are more likely to make accurate quotient estimations}
1012         \textcolor{comment}{// in BigInt\_DivideWithRemainder\_MaxQuotient9() with higher denominator values so}
1013         \textcolor{comment}{// we shift the denominator to place the highest bit at index 27 of the highest block.}
1014         \textcolor{comment}{// This is safe because (2^28 - 1) = 268435455 which is less than 429496729. This means}
1015         \textcolor{comment}{// that all values with a highest bit at index 27 are within range.}
1016         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} hiBlockLog2 = \hyperlink{dmath_8cpp_a835ee0ad31a196742a7a5fd3c21a738b}{LogBase2}(hiBlock);
1017         \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(hiBlockLog2 < 3 || hiBlockLog2 > 27);
1018         \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32} shift = (32 + 27 - hiBlockLog2) % 32;
1019 
1020         \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{BigInt\_ShiftLeft}( &scale, shift );
1021         \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{BigInt\_ShiftLeft}( &scaledValue, shift);
1022         \hyperlink{dragon4_8cpp_ad7065d256b1e7c2b3dffe0918776f720}{BigInt\_ShiftLeft}( &scaledMarginLow, shift);
1023         \textcolor{keywordflow}{if} (pScaledMarginHigh != &scaledMarginLow)
1024             \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{BigInt\_Multiply2}( pScaledMarginHigh, scaledMarginLow );
1025     \}
1026 
1027     \textcolor{comment}{// These values are used to inspect why the print loop terminated so we can properly}
1028     \textcolor{comment}{// round the final digit.}
1029     \hyperlink{dstandard_8h_ad203aed3ab57b120eb54c2043f60dc49}{tB}      low;            \textcolor{comment}{// did the value get within marginLow distance from zero}
1030     \hyperlink{dstandard_8h_ad203aed3ab57b120eb54c2043f60dc49}{tB}      high;           \textcolor{comment}{// did the value get within marginHigh distance from one}
1031     \hyperlink{dstandard_8h_aee96db7e18784e05ed6b0bcaeec3f7f6}{tU32}    outputDigit;    \textcolor{comment}{// current digit being output}
1032 
1033     \textcolor{keywordflow}{if} (cutoffMode == \hyperlink{dragon4_8h_ae285d109bd9f429145b2656fb0b3220da076774f759c6005f59bf2b5535abf570}{CutoffMode\_Unique})
1034     \{
1035         \textcolor{comment}{// For the unique cutoff mode, we will try to print until we have reached a level of}
1036         \textcolor{comment}{// precision that uniquely distinguishes this value from its neighbors. If we run}
1037         \textcolor{comment}{// out of space in the output buffer, we terminate early.}
1038         \textcolor{keywordflow}{for} (;;)
1039         \{
1040             digitExponent = digitExponent-1;
1041 
1042             \textcolor{comment}{// divide out the scale to extract the digit}
1043             outputDigit = \hyperlink{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626}{BigInt\_DivideWithRemainder\_MaxQuotient9}(&
      scaledValue, scale);
1044             \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( outputDigit < 10 );
1045 
1046             \textcolor{comment}{// update the high end of the value}
1047             \hyperlink{dragon4_8cpp_a83565e877dc63daa2fbf89e2835ccc94}{BigInt\_Add}( &scaledValueHigh, scaledValue, *pScaledMarginHigh );
1048 
1049             \textcolor{comment}{// stop looping if we are far enough away from our neighboring values}
1050             \textcolor{comment}{// or if we have reached the cutoff digit}
1051             low = \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{BigInt\_Compare}(scaledValue, scaledMarginLow) < 0;
1052             high = \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{BigInt\_Compare}(scaledValueHigh, scale) > 0;
1053             \textcolor{keywordflow}{if} (low | high | (digitExponent == cutoffExponent))
1054                 \textcolor{keywordflow}{break};
1055 
1056             \textcolor{comment}{// store the output digit}
1057             *pCurDigit = (\hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{tC8})(\textcolor{charliteral}{'0'} + outputDigit);
1058             ++pCurDigit;
1059 
1060             \textcolor{comment}{// multiply larger by the output base}
1061             \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{BigInt\_Multiply10}( &scaledValue );
1062             \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{BigInt\_Multiply10}( &scaledMarginLow );
1063             \textcolor{keywordflow}{if} (pScaledMarginHigh != &scaledMarginLow)
1064                 \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{BigInt\_Multiply2}( pScaledMarginHigh, scaledMarginLow );
1065         \}
1066     \}
1067     \textcolor{keywordflow}{else}
1068     \{
1069         \textcolor{comment}{// For length based cutoff modes, we will try to print until we}
1070         \textcolor{comment}{// have exhausted all precision (i.e. all remaining digits are zeros) or}
1071         \textcolor{comment}{// until we reach the desired cutoff digit.}
1072         low = \textcolor{keyword}{false};
1073         high = \textcolor{keyword}{false};
1074 
1075         \textcolor{keywordflow}{for} (;;)
1076         \{
1077             digitExponent = digitExponent-1;
1078 
1079             \textcolor{comment}{// divide out the scale to extract the digit}
1080             outputDigit = \hyperlink{dragon4_8cpp_a09244488f43f59ceaf0909ef9b405626}{BigInt\_DivideWithRemainder\_MaxQuotient9}(&
      scaledValue, scale);
1081             \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}( outputDigit < 10 );
1082 
1083             \textcolor{keywordflow}{if} ( scaledValue.\hyperlink{structtBigInt_a4e0c59f15fcb292ea4ec5d448fa10b58}{IsZero}() | (digitExponent == cutoffExponent) )
1084                 \textcolor{keywordflow}{break};
1085 
1086             \textcolor{comment}{// store the output digit}
1087             *pCurDigit = (\hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{tC8})(\textcolor{charliteral}{'0'} + outputDigit);
1088             ++pCurDigit;
1089 
1090             \textcolor{comment}{// multiply larger by the output base}
1091             \hyperlink{dragon4_8cpp_a48c80464b1664cb339c7348ef2a2771b}{BigInt\_Multiply10}(&scaledValue);
1092         \}
1093     \}
1094 
1095     \textcolor{comment}{// round off the final digit}
1096     \textcolor{comment}{// default to rounding down if value got too close to 0}
1097     \hyperlink{dstandard_8h_ad203aed3ab57b120eb54c2043f60dc49}{tB} roundDown = low;
1098 
1099     \textcolor{comment}{// if it is legal to round up and down}
1100     \textcolor{keywordflow}{if} (low == high)
1101     \{
1102         \textcolor{comment}{// round to the closest digit by comparing value with 0.5. To do this we need to convert}
1103         \textcolor{comment}{// the inequality to large integer values.}
1104         \textcolor{comment}{//  compare( value, 0.5 )}
1105         \textcolor{comment}{//  compare( scale * value, scale * 0.5 )}
1106         \textcolor{comment}{//  compare( 2 * scale * value, scale )}
1107         \hyperlink{dragon4_8cpp_a1772b026d1a5802fd0214db6346f0cbc}{BigInt\_Multiply2}(&scaledValue);
1108         \hyperlink{dstandard_8h_ae3b25aefaa14d98873818cceec369577}{tS32} compare = \hyperlink{dragon4_8cpp_a1c02bba02f26528317e59d6599379d6f}{BigInt\_Compare}(scaledValue, scale);
1109         roundDown = compare < 0;
1110 
1111         \textcolor{comment}{// if we are directly in the middle, round towards the even digit (i.e. IEEE rouding rules)}
1112         \textcolor{keywordflow}{if} (compare == 0)
1113             roundDown = (outputDigit & 1) == 0;
1114     \}
1115 
1116     \textcolor{comment}{// print the rounded digit}
1117     \textcolor{keywordflow}{if} (roundDown)
1118     \{
1119         *pCurDigit = (\hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{tC8})(\textcolor{charliteral}{'0'} + outputDigit);
1120         ++pCurDigit;
1121     \}
1122     \textcolor{keywordflow}{else}
1123     \{
1124         \textcolor{comment}{// handle rounding up}
1125         \textcolor{keywordflow}{if} (outputDigit == 9)
1126         \{
1127             \textcolor{comment}{// find the first non-nine prior digit}
1128             \textcolor{keywordflow}{for} (;;)
1129             \{
1130                 \textcolor{comment}{// if we are at the first digit}
1131                 \textcolor{keywordflow}{if} (pCurDigit == pOutBuffer)
1132                 \{
1133                     \textcolor{comment}{// output 1 at the next highest exponent}
1134                     *pCurDigit = \textcolor{charliteral}{'1'};
1135                     ++pCurDigit;
1136                     *pOutExponent += 1;
1137                     \textcolor{keywordflow}{break};
1138                 \}
1139 
1140                 --pCurDigit;
1141                 \textcolor{keywordflow}{if} (*pCurDigit != \textcolor{charliteral}{'9'})
1142                 \{
1143                     \textcolor{comment}{// increment the digit}
1144                     *pCurDigit += 1;
1145                     ++pCurDigit;
1146                     \textcolor{keywordflow}{break};
1147                 \}
1148             \}
1149         \}
1150         \textcolor{keywordflow}{else}
1151         \{
1152             \textcolor{comment}{// values in the range [0,8] can perform a simple round up}
1153             *pCurDigit = (\hyperlink{dstandard_8h_a0dd9590397b73cba91a188b94be20ee1}{tC8})(\textcolor{charliteral}{'0'} + outputDigit + 1);
1154             ++pCurDigit;
1155         \}
1156     \}
1157 
1158     \textcolor{comment}{// return the number of digits output}
1159     \hyperlink{dstandard_8h_a89136b38084a3e1d69a63af0db6fec17}{RJ\_ASSERT}(pCurDigit - pOutBuffer <= (\hyperlink{dstandard_8h_a0a9a87afb721643d2bb6fe22a900303c}{tPtrDiff})bufferSize);
1160     \textcolor{keywordflow}{return} pCurDigit - pOutBuffer;
1161 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{dragon4_8cpp_afc702da0bd9df1a3d2d5a93b5568b6db_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dragon4_8cpp_afc702da0bd9df1a3d2d5a93b5568b6db_icgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\index{dragon4.\+cpp@{dragon4.\+cpp}!c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks@{c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks}}
\index{c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks@{c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks}{c_BigInt_MaxBlocks}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf t\+U32} c\+\_\+\+Big\+Int\+\_\+\+Max\+Blocks = 35}\hypertarget{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}{}\label{dragon4_8cpp_af3325cd84c7aeec94a132d7a160b4505}


Definition at line 61 of file dragon4.\+cpp.

\index{dragon4.\+cpp@{dragon4.\+cpp}!g\+\_\+\+Power\+Of10\+\_\+\+Big@{g\+\_\+\+Power\+Of10\+\_\+\+Big}}
\index{g\+\_\+\+Power\+Of10\+\_\+\+Big@{g\+\_\+\+Power\+Of10\+\_\+\+Big}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{g\+\_\+\+Power\+Of10\+\_\+\+Big}{g_PowerOf10_Big}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+Big\+Int} g\+\_\+\+Power\+Of10\+\_\+\+Big\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_ae87ee958451e3a11f2110fd60d58750f}{}\label{dragon4_8cpp_ae87ee958451e3a11f2110fd60d58750f}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
\{
    
    \{ 1, \{ 100000000 \} \},
    
    \{ 2, \{ 0x6fc10000, 0x002386f2 \} \},
    
    \{ 4, \{ 0x00000000, 0x85acef81, 0x2d6d415b, 0x000004ee, \} \},
    
    \{ 7, \{ 0x00000000, 0x00000000, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x00184f03, \} \},
    
    \{   14, \{ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2e953e01, 0x03df9909, 0x0f1538fd,
            0x2374e42f, 0xd3cff5ec, 0xc404dc08, 0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x0000024e,
        \}
    \},
    
    \{   27, \{ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70,
            0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0,
            0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x000553f7,
        \}
    \}
\}
\end{DoxyCode}


Definition at line 438 of file dragon4.\+cpp.



Referenced by Big\+Int\+\_\+\+Multiply\+Pow10(), and Big\+Int\+\_\+\+Pow10().

\index{dragon4.\+cpp@{dragon4.\+cpp}!g\+\_\+\+Power\+Of10\+\_\+\+U32@{g\+\_\+\+Power\+Of10\+\_\+\+U32}}
\index{g\+\_\+\+Power\+Of10\+\_\+\+U32@{g\+\_\+\+Power\+Of10\+\_\+\+U32}!dragon4.\+cpp@{dragon4.\+cpp}}
\subsubsection[{\texorpdfstring{g\+\_\+\+Power\+Of10\+\_\+\+U32}{g_PowerOf10_U32}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+U32} g\+\_\+\+Power\+Of10\+\_\+\+U32\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{dragon4_8cpp_a4caa72077b00dbfcccd05daf04b74896}{}\label{dragon4_8cpp_a4caa72077b00dbfcccd05daf04b74896}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
\{
    1,          
    10,         
    100,        
    1000,       
    10000,      
    100000,     
    1000000,    
    10000000,   
\}
\end{DoxyCode}


Definition at line 419 of file dragon4.\+cpp.



Referenced by Big\+Int\+\_\+\+Multiply\+Pow10(), and Big\+Int\+\_\+\+Pow10().

