\hypertarget{clib_8h}{}\section{lib/clib.h File Reference}
\label{clib_8h}\index{lib/clib.\+h@{lib/clib.\+h}}


C functions for manipulating strings and memory.  


{\ttfamily \#include \char`\"{}platform.\+h\char`\"{}}\\*
Include dependency graph for clib.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=160pt]{db/d16/clib_8h__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structtexttag}{texttag}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{clib_8h_a67ec56eb98b49515d35005a5b3bf9a32}{Str\+Len} (const char $\ast$string)
\begin{DoxyCompactList}\small\item\em Get the length of a null terminated string. \end{DoxyCompactList}\item 
\hyperlink{platform_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool} \hyperlink{clib_8h_a2a1f39d11cbbaac992d42e67557dac4b}{Str\+Is\+Equal} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em Compare two null terminated strings to each other. \end{DoxyCompactList}\item 
void \hyperlink{clib_8h_ad2d145e8bf756b862f006a6ea79578d5}{Mem\+Set} (void $\ast$destination, int c0, unsigned int length)
\item 
void \hyperlink{clib_8h_a09b7e057c69b9ddd4b481fc746997a7d}{Mem\+Copy} (void $\ast$destination, const void $\ast$source, unsigned int length)
\begin{DoxyCompactList}\small\item\em Copy a block of memory, handling overlap. \end{DoxyCompactList}\item 
unsigned int \hyperlink{clib_8h_a5bed05c70cb17e541fee570b5dc32e1a}{Alloc\+And\+Copy} (char $\ast$$\ast$destination, const char $\ast$source)
\begin{DoxyCompactList}\small\item\em Allocate memory and copy a string into the array. \end{DoxyCompactList}\item 
void \hyperlink{clib_8h_a13fd37f0e8fef81a052aab4cd5588fb6}{Untag} (char $\ast$destination, const char $\ast$source, \hyperlink{structtexttag}{texttag} tags\mbox{[}$\,$\mbox{]}, unsigned int tagcount)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
C functions for manipulating strings and memory. 



\subsection{Function Documentation}
\index{clib.\+h@{clib.\+h}!Alloc\+And\+Copy@{Alloc\+And\+Copy}}
\index{Alloc\+And\+Copy@{Alloc\+And\+Copy}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Alloc\+And\+Copy(char $\ast$$\ast$destination, const char $\ast$source)}{AllocAndCopy(char **destination, const char *source)}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Alloc\+And\+Copy (
\begin{DoxyParamCaption}
\item[{char $\ast$$\ast$}]{destination, }
\item[{const char $\ast$}]{source}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_a5bed05c70cb17e541fee570b5dc32e1a}{}\label{clib_8h_a5bed05c70cb17e541fee570b5dc32e1a}


Allocate memory and copy a string into the array. 



Definition at line 34 of file alloccpy.\+c.



Referenced by Ansi\+Conole\+Engine\+::\+Ansi\+Conole\+Engine(), Char\+Buffer\+::\+Clear\+And\+Copy(), Console\+Base\+::\+Console\+Base(), Ansi\+Conole\+Engine\+::\+Copy\+Line(), Delete\+Statement\+::\+Delete\+Statement(), Draw\+Statement\+::\+Draw\+Statement(), Error\+Node\+::\+Error\+Node(), Execute\+Statement\+::\+Execute\+Statement(), Help\+Statement\+::\+Help\+Statement(), Lexer\+::\+Lexer(), List\+Statement\+::\+List\+Statement(), Standard\+Language\+::\+Load\+Catalog(), Load\+Statement\+::\+Load\+Statement(), Plot\+Statement\+::\+Plot\+Statement(), Prompt\+Statement\+::\+Prompt\+Statement(), Save\+Statement\+::\+Save\+Statement(), Preferences\+Base\+::\+Set\+Defaults(), Preferences\+Base\+::\+Set\+Prompt(), Console\+Base\+::\+Set\+Prompt(), Ansi\+Conole\+Engine\+::\+Set\+Prompt(), Ansi\+Conole\+Engine\+::\+Show\+Last(), Show\+Statement\+::\+Show\+Statement(), Token\+::\+Token(), User\+Function\+::\+User\+Function(), and Variable\+::\+Variable().


\begin{DoxyCode}
35 \{
36     \textcolor{keywordtype}{char} *i, *s, *d;
37     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n, size;
38 
39     \textcolor{keywordflow}{if} (source == \hyperlink{platform_8h_a46ff2bfbf0d44b8466a2251d5bd5e6f8}{NOMEM}) \{
40         *destination = \hyperlink{platform_8h_a46ff2bfbf0d44b8466a2251d5bd5e6f8}{NOMEM};
41         \textcolor{keywordflow}{return} 0;
42     \}
43 
44     i = (\textcolor{keywordtype}{char}*)source;
45     s = (\textcolor{keywordtype}{char}*)source;
46     \textcolor{keywordflow}{while} (*i)
47         i++;
48 
49     n = i - s + 1;
50     size = n;
51     *destination = \hyperlink{mem_8h_ad19db35dcf54d18c2a8958f1cca6b299}{AllocMemSafe}(size);
52     d = *destination;
53 
54     \textcolor{keywordflow}{while} (n--)
55         *d++ = *s++;
56 
57     \textcolor{keywordflow}{return} size;
58 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/de5/clib_8h_a5bed05c70cb17e541fee570b5dc32e1a_icgraph}
\end{center}
\end{figure}


\index{clib.\+h@{clib.\+h}!Mem\+Copy@{Mem\+Copy}}
\index{Mem\+Copy@{Mem\+Copy}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Mem\+Copy(void $\ast$destination, const void $\ast$source, unsigned int length)}{MemCopy(void *destination, const void *source, unsigned int length)}}]{\setlength{\rightskip}{0pt plus 5cm}void Mem\+Copy (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{destination, }
\item[{const void $\ast$}]{source, }
\item[{unsigned int}]{length}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_a09b7e057c69b9ddd4b481fc746997a7d}{}\label{clib_8h_a09b7e057c69b9ddd4b481fc746997a7d}


Copy a block of memory, handling overlap. 

Original file can be found at\+: \href{https://svnweb.freebsd.org/base/release/9.0.0/lib/libc/string/bcopy.c?revision=229286}{\tt https\+://svnweb.\+freebsd.\+org/base/release/9.\+0.\+0/lib/libc/string/bcopy.\+c?revision=229286} 

Definition at line 60 of file memcpy.\+c.



Referenced by Char\+Buffer\+::\+Ensure\+Size(), Format\+Positional(), Format\+Scientific(), Lexer\+::\+Get\+Digit\+Value(), Lexer\+::\+Get\+Litteral(), Lexer\+::\+Get\+Quoted\+Ident(), Print\+Inf\+Nan(), and Language\+::\+Untag\+Text().


\begin{DoxyCode}
61 \{
62     \textcolor{keywordtype}{char} *dst = (\textcolor{keywordtype}{char}*) destination;
63     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *src = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*) source;
64     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} t;
65 
66     \textcolor{keywordflow}{if} (length == 0 || dst == src) \textcolor{comment}{// nothing to do}
67         \textcolor{keywordflow}{return};
68 
69     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})dst < (\textcolor{keywordtype}{unsigned} long)src) \{
70         \textcolor{comment}{// Copy forward}
71         t = (\textcolor{keywordtype}{unsigned} long)src; \textcolor{comment}{// only need low bits}
72         \textcolor{keywordflow}{if} ((t | (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})dst) & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask}) \{
73 
74             \textcolor{comment}{// Try to align operands.  This cannot be done unless the low bits match.}
75             \textcolor{keywordflow}{if} ((t ^ (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})dst) & wmask || length < \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize})
76                 t = length;
77             \textcolor{keywordflow}{else}
78                 t = \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize} - (t & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask});
79             length -= t;
80 
81             \hyperlink{memcpy_8c_a4d81791363bd2fd7e37c9a533be06f59}{TLOOP1}(*dst++ = *src++);
82         \}
83 
84         \textcolor{comment}{// Copy whole words, then mop up any trailing bytes.}
85         t = length / \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize};
86         \hyperlink{memcpy_8c_a74d8274a661a711f2c9e05a7f19eaf0f}{TLOOP}(*(\hyperlink{memcpy_8c_aafc9a69535613ac225df2d6195518116}{word} *)dst = *(\hyperlink{memcpy_8c_aafc9a69535613ac225df2d6195518116}{word} *)src; src += \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize}; dst += 
      \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize});
87 
88         t = length & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask};
89         \hyperlink{memcpy_8c_a74d8274a661a711f2c9e05a7f19eaf0f}{TLOOP}(*dst++ = *src++);
90 
91     \} \textcolor{keywordflow}{else} \{
92         \textcolor{comment}{// Copy backwards.  Otherwise essentially the same.}
93         \textcolor{comment}{// Alignment works as before, except that it takes}
94         \textcolor{comment}{// (t&wmask) bytes to align, not wsize-(t&wmask).}
95         src += length;
96         dst += length;
97         t = (\textcolor{keywordtype}{unsigned} long)src;
98         \textcolor{keywordflow}{if} ((t | (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})dst) & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask}) \{
99 
100             \textcolor{keywordflow}{if} ((t ^ (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})dst) & wmask || length <= \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize})
101                 t = length;
102             \textcolor{keywordflow}{else}
103                 t &= \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask};
104             length -= t;
105 
106             \hyperlink{memcpy_8c_a4d81791363bd2fd7e37c9a533be06f59}{TLOOP1}(*--dst = *--src);
107         \}
108 
109         t = length / \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize};
110         \hyperlink{memcpy_8c_a74d8274a661a711f2c9e05a7f19eaf0f}{TLOOP}(src -= \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize}; dst -= \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize}; *(\hyperlink{memcpy_8c_aafc9a69535613ac225df2d6195518116}{word} *)dst = *(
      \hyperlink{memcpy_8c_aafc9a69535613ac225df2d6195518116}{word} *)src);
111 
112         t = length & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask};
113         \hyperlink{memcpy_8c_a74d8274a661a711f2c9e05a7f19eaf0f}{TLOOP}(*--dst = *--src);
114     \}
115 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/de5/clib_8h_a09b7e057c69b9ddd4b481fc746997a7d_icgraph}
\end{center}
\end{figure}


\index{clib.\+h@{clib.\+h}!Mem\+Set@{Mem\+Set}}
\index{Mem\+Set@{Mem\+Set}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Mem\+Set(void $\ast$destination, int c0, unsigned int length)}{MemSet(void *destination, int c0, unsigned int length)}}]{\setlength{\rightskip}{0pt plus 5cm}void Mem\+Set (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{destination, }
\item[{int}]{c0, }
\item[{unsigned int}]{length}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_ad2d145e8bf756b862f006a6ea79578d5}{}\label{clib_8h_ad2d145e8bf756b862f006a6ea79578d5}


Definition at line 42 of file memset.\+c.


\begin{DoxyCode}
43 \{
44     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *dst = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) dst0;
45     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}  t;
46     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}  c;
47 
48     \textcolor{comment}{/*}
49 \textcolor{comment}{     * If not enough words, just fill bytes.  A length >= 2 words}
50 \textcolor{comment}{     * guarantees that at least one of them is `complete' after}
51 \textcolor{comment}{     * any necessary alignment.  For instance:}
52 \textcolor{comment}{     *}
53 \textcolor{comment}{     *  |-----------|-----------|-----------|}
54 \textcolor{comment}{     *  |00|01|02|03|04|05|06|07|08|09|0A|00|}
55 \textcolor{comment}{     *            ^---------------------^}
56 \textcolor{comment}{     *       dst         dst+length-1}
57 \textcolor{comment}{     *}
58 \textcolor{comment}{     * but we use a minimum of 3 here since the overhead of the code}
59 \textcolor{comment}{     * to do word writes is substantial.}
60 \textcolor{comment}{     */}
61     \textcolor{keywordflow}{if} (length < 3 * \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize}) \{
62         \textcolor{keywordflow}{while} (length != 0) \{
63             *dst++ = c0;
64             --length;
65         \}
66     \}
67 
68     \textcolor{keywordflow}{if} ((c = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})c0) != 0) \{ \textcolor{comment}{/* Fill the word. */}
69         c = (c << 8) | c;   \textcolor{comment}{/* u\_int is 16 bits. */}
70 \textcolor{preprocessor}{#if UINT\_MAX > 0xffff}
71         c = (c << 16) | c;  \textcolor{comment}{/* u\_int is 32 bits. */}
72 \textcolor{preprocessor}{#endif}
73 \textcolor{preprocessor}{#if UINT\_MAX > 0xffffffff}
74         c = (c << 32) | c;  \textcolor{comment}{/* u\_int is 64 bits. */}
75 \textcolor{preprocessor}{#endif}
76     \}
77 
78     \textcolor{comment}{/* Align destination by filling in bytes. */}
79     \textcolor{keywordflow}{if} ((t = (\textcolor{keywordtype}{long})dst & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask}) != 0) \{
80         t = \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize} - t;
81         length -= t;
82         \textcolor{keywordflow}{do} \{
83             *dst++ = c0;
84         \} \textcolor{keywordflow}{while} (--t != 0);
85     \}
86 
87     \textcolor{comment}{/* Fill words.  Length was >= 2*words so we know t >= 1 here. */}
88     t = length / \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize};
89     \textcolor{keywordflow}{do} \{
90         *(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)dst = c;
91         dst += \hyperlink{platform_8h_a01c6b59ca21f041b23efbb9845cc4e32}{wsize};
92     \} \textcolor{keywordflow}{while} (--t != 0);
93 
94     \textcolor{comment}{/* Mop up trailing bytes, if any. */}
95     t = length & \hyperlink{platform_8h_ab5deaef115ff5ca6ef1457d923d8331a}{wmask};
96     \textcolor{keywordflow}{if} (t != 0)
97         \textcolor{keywordflow}{do} \{
98             *dst++ = c0;
99         \} \textcolor{keywordflow}{while} (--t != 0);
100 \}
\end{DoxyCode}
\index{clib.\+h@{clib.\+h}!Str\+Is\+Equal@{Str\+Is\+Equal}}
\index{Str\+Is\+Equal@{Str\+Is\+Equal}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Str\+Is\+Equal(const char $\ast$s1, const char $\ast$s2)}{StrIsEqual(const char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} Str\+Is\+Equal (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_a2a1f39d11cbbaac992d42e67557dac4b}{}\label{clib_8h_a2a1f39d11cbbaac992d42e67557dac4b}


Compare two null terminated strings to each other. 



Definition at line 48 of file strcmp.\+c.



Referenced by Variable\+List\+::\+Create\+Variable(), Function\+List\+::\+Delete(), Language\+::\+Find\+Alias(), Function\+List\+::\+Get\+Function\+Call(), Function\+List\+::\+Get\+Function\+Def(), Language\+::\+Get\+Help\+Text(), Function\+List\+::\+Get\+System\+Function(), Variable\+List\+::\+Get\+Variable(), Char\+Buffer\+::\+Is(), Standard\+Filesystem\+::\+List\+Directory(), Char\+Buffer\+::\+Remove\+Trailing(), Standard\+Language\+::\+Str\+Is\+Equal\+Loc(), and Posix\+Language\+::\+Str\+Is\+Equal\+Loc().


\begin{DoxyCode}
49 \{
50     \textcolor{keywordtype}{int} r;
51 
52     \textcolor{keywordflow}{while} (*s1 == *s2++)
53         \textcolor{keywordflow}{if} (*s1++ == \textcolor{charliteral}{'\(\backslash\)0'})
54             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
55 
56     r = (*(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)s1 - *(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)(s2 - 1));
57 
58     \textcolor{keywordflow}{return} r == 0;
59 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/de5/clib_8h_a2a1f39d11cbbaac992d42e67557dac4b_icgraph}
\end{center}
\end{figure}


\index{clib.\+h@{clib.\+h}!Str\+Len@{Str\+Len}}
\index{Str\+Len@{Str\+Len}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Str\+Len(const char $\ast$string)}{StrLen(const char *string)}}]{\setlength{\rightskip}{0pt plus 5cm}int Str\+Len (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{string}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_a67ec56eb98b49515d35005a5b3bf9a32}{}\label{clib_8h_a67ec56eb98b49515d35005a5b3bf9a32}


Get the length of a null terminated string. 



Definition at line 31 of file strlen.\+c.



Referenced by Error\+Node\+::\+Error\+Node(), Version\+Statement\+::\+Execute(), Memory\+Statement\+::\+Execute(), Error\+Node\+::\+Execute(), Eval\+Statement\+::\+Execute(), Statement\+Block\+Node\+::\+Execute(), Delete\+Statement\+::\+Execute(), Input\+Statement\+::\+Execute(), Output\+Statement\+::\+Execute(), Digits\+Statement\+::\+Execute(), Save\+Statement\+::\+Execute(), Preferences\+Base\+::\+Get\+Description(), Positional\+Numeral\+System\+::\+Get\+Name(), Unary\+Node\+::\+Get\+Text(), Function\+Node\+::\+Get\+Text(), Absolute\+Node\+::\+Get\+Text(), Numeric\+Operator\+::\+Get\+Text(), Standard\+Program\+::\+Initialize(), Variable\+List\+::\+List\+Content(), Function\+List\+::\+List\+Content(), Standard\+Filesystem\+::\+List\+Directory(), Char\+Buffer\+::\+Remove\+Trailing(), Standard\+Console\+::\+Run(), Ansi\+Conole\+Engine\+::\+Show\+Last(), Ansi\+Conole\+Engine\+::\+Show\+Next(), Language\+::\+Untag\+Text(), and Standard\+Console\+::\+Write\+String().


\begin{DoxyCode}
32 \{
33     \textcolor{keywordtype}{char} *i = (\textcolor{keywordtype}{char}*)\textcolor{keywordtype}{string};
34     \textcolor{keywordtype}{char} *s = i;
35     \textcolor{keywordflow}{while} (*i)
36         i++;
37     \textcolor{keywordflow}{return} i - s;
38 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/de5/clib_8h_a67ec56eb98b49515d35005a5b3bf9a32_icgraph}
\end{center}
\end{figure}


\index{clib.\+h@{clib.\+h}!Untag@{Untag}}
\index{Untag@{Untag}!clib.\+h@{clib.\+h}}
\subsubsection[{\texorpdfstring{Untag(char $\ast$destination, const char $\ast$source, texttag tags[], unsigned int tagcount)}{Untag(char *destination, const char *source, texttag tags[], unsigned int tagcount)}}]{\setlength{\rightskip}{0pt plus 5cm}void Untag (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{destination, }
\item[{const char $\ast$}]{source, }
\item[{{\bf texttag}}]{tags\mbox{[}$\,$\mbox{]}, }
\item[{unsigned int}]{tagcount}
\end{DoxyParamCaption}
)}\hypertarget{clib_8h_a13fd37f0e8fef81a052aab4cd5588fb6}{}\label{clib_8h_a13fd37f0e8fef81a052aab4cd5588fb6}


Definition at line 29 of file untag.\+c.



References texttag\+::tag, and texttag\+::text.



Referenced by Language\+::\+Untag\+Text().


\begin{DoxyCode}
30 \{
31     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pos, *tmp, *tag;
32     \textcolor{keywordtype}{char} *dest;
33     \textcolor{keywordtype}{int} \textcolor{keywordtype}{unsigned} i, j, found;
34 
35     pos = source;
36     dest = destination;
37 
38     \textcolor{keywordflow}{while} (*pos != \textcolor{charliteral}{'\(\backslash\)0'}) \{
39         \textcolor{keywordflow}{if} (*pos != \textcolor{charliteral}{'#'}) \{
40             (*dest++ = *pos++);
41         \} \textcolor{keywordflow}{else} \{
42             \textcolor{comment}{// Try to replace tag}
43             found = 0;
44             \textcolor{keywordflow}{for} (i = 0; i < tagcount; i++) \{
45                 tag = tags[i].\hyperlink{structtexttag_abdc442e3844ddc31013194f47bc098f8}{tag};
46                 tmp = pos;
47                 j = 0;
48                 \textcolor{keywordflow}{while} (*tmp != \textcolor{charliteral}{'\(\backslash\)0'} && *tag != \textcolor{charliteral}{'\(\backslash\)0'} && *tmp == *tag) \{
49                     tmp++;
50                     tag++;
51                     j++;
52                 \}
53 
54                 \textcolor{keywordflow}{if} (j > 1 && *(--tag) == \textcolor{charliteral}{'#'}) \{
55                     \textcolor{comment}{// Tag found. Now replace.}
56                     tag = tags[i].\hyperlink{structtexttag_a50dedeb9b187ea41d2465a58e68ec424}{text};
57                     \textcolor{keywordflow}{while} ((*dest++ = *tag++));
58                     dest--;
59                     pos = tmp;
60                     found = 1;
61                     \textcolor{keywordflow}{break};
62                 \}
63             \}
64 
65             \textcolor{keywordflow}{if}(!found) \{
66                 (*dest++ = *pos++);
67             \}
68         \}
69     \}
70     *dest = \textcolor{charliteral}{'\(\backslash\)0'};
71 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/de5/clib_8h_a13fd37f0e8fef81a052aab4cd5588fb6_icgraph}
\end{center}
\end{figure}


